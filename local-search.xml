<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法 --- 排列和组合 Permutation and Combination</title>
    <link href="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88%20Permutation%20and%20Combination/"/>
    <url>/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88%20Permutation%20and%20Combination/</url>
    
    <content type="html"><![CDATA[<h1 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h1><h2 id="Permutation"><a href="#Permutation" class="headerlink" title="Permutation"></a>Permutation</h2><blockquote><ul><li>A  permutation of n distinct objects is an arrangment ( or ordering) of all n objects. </li><li><strong>Denoted as P(n)</strong></li><li><strong>P(n) &#x3D; n !</strong><blockquote><p>Example 1:<br>Suppose 10 students are sitting for a class picture. How many ways are there to arrange 10 students.<br> Answer: 10 * 9 *…… * 2 * 1 &#x3D;  10!</p></blockquote></li></ul></blockquote><blockquote><ul><li>An r-permutation n distinct objects is an arrangment (or ording) of r of the n objects.</li><li><strong>Denoted as P(n,r)</strong></li><li><strong>P(n, r) &#x3D; n! &#x2F; (n-r)!</strong><blockquote><p>Example 1:<br>Suppose 10 students are sitting for a class picture. How many ways are there to arrange  the row of 3 students.<br>Answer: 10 * 9 * 8 &#x3D;  720</p></blockquote></li></ul></blockquote><h2 id="Combination"><a href="#Combination" class="headerlink" title="Combination"></a>Combination</h2><blockquote><ul><li>An r-combination of n distinct objects is a selection (order doesn’t matter) of  r of n objects. (Alson known as Sets)</li><li><strong>Denoted as C(n, r)</strong></li><li><strong>C(n, r) &#x3D; {n !}   &#x2F;   {(n-r) ! r!}</strong></li></ul><blockquote><p>Example 1:<br>How many 5 letters subsets can be made from 26 English letter.<br>Answer C(26, 5)</p></blockquote><blockquote><p><strong>Example 2:</strong><br>Calculate all subsets of number 12345<br>Answer &#x3D; C(5,5) + C(5,4) + C(5,3) + C(5,2) + C(5,1) + C(5,0)  &#x3D; 2^5^<br><strong>Because for each digit, it has two options: choose or not choose</strong><br>Therefore: 2 * 2 * 2 * 2 * 2</p></blockquote></blockquote><h1 id="Permutation-1"><a href="#Permutation-1" class="headerlink" title="Permutation"></a>Permutation</h1><h2 id="Permutation-—-Leetcode-46"><a href="#Permutation-—-Leetcode-46" class="headerlink" title="Permutation  —  Leetcode 46"></a>Permutation  —  Leetcode 46</h2><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88%20Permutation%20and%20Combination/1.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permute</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; output = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();<br>        List&lt;Integer&gt; tempList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        <span class="hljs-keyword">return</span> permutation(tempList, nums, output);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">permutation</span><span class="hljs-params">(List&lt;Integer&gt; tempList, <span class="hljs-type">int</span> [] nums, List&lt;List&lt;Integer&gt;&gt; output)</span> &#123;<br>        <span class="hljs-comment">//output长度和数组长度一样，代表本次排列完成，可以返回</span><br>        <span class="hljs-keyword">if</span> (tempList.size() == nums.length) &#123;<br>            output.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(tempList));<br>            <span class="hljs-comment">//output.add(tempList); 就不可以， 因为加入的是tempList的地址，所以之前加入的tempList会因为后面对tempList的改变而改变</span><br>            <span class="hljs-keyword">return</span> output;<br>        &#125;<br><br>        <span class="hljs-comment">//对数组中每个元素进行遍历</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!tempList.contains(nums[i])) &#123; <span class="hljs-comment">//如果目前记录的output里有num[i]，则跳过此次循环（防止重复）</span><br>                tempList.add(nums[i]); <span class="hljs-comment">//把当前元素加入output</span><br>                permutation(tempList, nums, output); <span class="hljs-comment">//进行下一次循环, 完成dfs</span><br>                tempList.remove(tempList.size()-<span class="hljs-number">1</span>); <span class="hljs-comment">//回到本层之后，删除之前num[i]，完成回溯</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> output;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="String-Permutation-—-Lintcode-10"><a href="#String-Permutation-—-Lintcode-10" class="headerlink" title="String Permutation — Lintcode 10"></a>String Permutation — Lintcode 10</h2><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88%20Permutation%20and%20Combination/2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> str: A string</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: all permutations</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">stringPermutation2</span><span class="hljs-params">(String str)</span> &#123;<br>        str = sortString(str);<br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-type">boolean</span> [] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[str.length()];<br>        <br>        dfs(visited, str, temp, ans);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">boolean</span> [] visited, String str, StringBuilder temp, List&lt;String&gt; ans)</span> &#123;<br>        <span class="hljs-keyword">if</span> (temp.length() == str.length()) &#123;<br>            <br>           <span class="hljs-comment">//不能用注释掉的方式去重，会超时</span><br>            <span class="hljs-comment">/* </span><br><span class="hljs-comment">            if (!ans.contains(temp.toString())) &#123;</span><br><span class="hljs-comment">                ans.add(temp.toString());</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">            */</span>            <br>            ans.add(temp.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; str.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (visited[i]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        <br>            <span class="hljs-comment">//这里if的作用是去重： 不同位置的同样的字符，必须按照顺序用</span><br>            <span class="hljs-comment">// a&#x27; a&#x27;&#x27; b</span><br>            <span class="hljs-comment">// a&#x27; a&#x27;&#x27; b    ok</span><br>            <span class="hljs-comment">// a&#x27;&#x27; a&#x27; b    not ok</span><br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; str.charAt(i) == str.charAt(i-<span class="hljs-number">1</span>) &amp;&amp; !visited[i-<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <br>            temp.append(str.charAt(i));<br>            visited[i] = <span class="hljs-literal">true</span>;<br>            dfs(visited, str, temp, ans);<br>            visited[i] = <span class="hljs-literal">false</span>;<br>            temp = temp.deleteCharAt(temp.length()-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">sortString</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-type">char</span> [] charArray = str.toCharArray();<br>        Arrays.sort(charArray);<br>        str = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(charArray);<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Combination-1"><a href="#Combination-1" class="headerlink" title="Combination"></a>Combination</h1><h2 id="Subsets-without-duplicates-—-Leetcode-78"><a href="#Subsets-without-duplicates-—-Leetcode-78" class="headerlink" title="Subsets (without duplicates) — Leetcode 78"></a>Subsets (without duplicates) — Leetcode 78</h2><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88%20Permutation%20and%20Combination/3.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsets</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(temp));<br>            <span class="hljs-keyword">return</span> ans;<br>        &#125;<br>    <br>        dfs(ans, temp, nums, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; temp, <span class="hljs-type">int</span> [] nums, <span class="hljs-type">int</span> startIndex)</span> &#123;<br>        <span class="hljs-comment">//将集合加入ans</span><br>    　　<span class="hljs-comment">//用startIndex防止重复</span><br>    　　<span class="hljs-comment">//take N to copy to ans list</span><br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(temp));<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++) &#123; <br>            temp.add(nums[i]);<br>            dfs(ans, temp, nums, i + <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//backtracking</span><br>            temp.remove(temp.size()-<span class="hljs-number">1</span>);<br>        &#125;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Subsets-II-with-duplicates-—-Leetcode-90"><a href="#Subsets-II-with-duplicates-—-Leetcode-90" class="headerlink" title="Subsets II  (with duplicates) — Leetcode 90"></a>Subsets II  (with duplicates) — Leetcode 90</h2><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E6%8E%92%E5%88%97%E5%92%8C%E7%BB%84%E5%90%88%20Permutation%20and%20Combination/4.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">subsetsWithDup</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        Arrays.sort(nums); <span class="hljs-comment">//must sort in order to skip all the duplicate subsets</span><br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        dfs(nums, ans, temp, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> [] nums, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; temp, <span class="hljs-type">int</span> startIndex)</span> &#123;<br><br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;(temp));<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">// skip all the duplicate</span><br>            <span class="hljs-comment">//if the current number is same as previous one, then skip</span><br>            <span class="hljs-comment">//Exception: if the previous number is the startIndex ( i &gt; startIndex )</span><br>            <span class="hljs-comment">//Example: a  b&#x27; b&#x27;&#x27; b&#x27;&#x27;&#x27; d</span><br>            <span class="hljs-comment">//startIndex: 1</span><br>            <span class="hljs-comment">//a  b&#x27; b&#x27;&#x27;  d   ok</span><br>            <span class="hljs-comment">//a  b&#x27; b&#x27;&#x27;&#x27; d   not ok</span><br>            <span class="hljs-keyword">if</span> ( i &gt; startIndex &amp;&amp; nums[i-<span class="hljs-number">1</span>] == nums[i]) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            temp.add(nums[i]);<br>            dfs(nums, ans, temp, i + <span class="hljs-number">1</span>);<br>            temp.remove(temp.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">//backtracking</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><blockquote><ul><li><strong>Examples shown above are template for solving all combination and permutation problems.</strong></li><li>Combination needs startIndex, Permutations doesn’t need startIndex</li><li>For handling duplicated elements  in input:</li></ul><ol><li>Sort Input</li><li>Add following code in  for loop<blockquote><p>Combination:<br><code> if ( i &gt; startIndex &amp;&amp; nums[i-1] == nums[i]) &#123;              continue;          &#125;</code></p></blockquote></li></ol><blockquote><p>Permutation:<br><code>if (i &gt; 0 &amp;&amp; str.charAt(i) == str.charAt(i-1) &amp;&amp; !visited[i-1]) &#123;                 continue;             &#125;</code></p></blockquote></blockquote><h1 id="Time-Complexity-of-Combination-and-Permutation"><a href="#Time-Complexity-of-Combination-and-Permutation" class="headerlink" title="Time Complexity of Combination and Permutation"></a>Time Complexity of Combination and Permutation</h1><blockquote><ul><li>Combination  — <strong>Subsets problem (Leetcode 78)</strong><br><strong>2^n^ * n</strong> :  A total of 2^n^ possibilities and each possibility takes N to copy to the ans list<br> <strong>Why 2^n^</strong>:  for example, for string 12345, each number has an option of choose or not choose, therefore 2^n^</li><li>Permutation  — <strong>Permutation problem (Leetcode 46)</strong><br><strong>n! * n</strong>:   A total of n! possibilities and each possibility takes N to copy to the ans list</li></ul></blockquote><blockquote><p>General formula for DFS:<br><strong>Number of possibilities  *  Time to create each possibility</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法 --- 维护一个有序数组</title>
    <link href="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E9%AB%98%E6%95%88%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/"/>
    <url>/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E9%AB%98%E6%95%88%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p>  在数组大小是一定的情况下,也就是知道元素上限， 每次需要删除最大值或者最小值</p><blockquote><ul><li>使用堆<br>时间复杂度 O(logn)</li></ul></blockquote><p>在不知道元素上限的情况下，数组大小不固定，元素值非常随机</p><blockquote><ul><li>使用二叉树  时间复杂度 O(logn)</li><li>但是当元素不够随机时，如有递增趋势，则效率会下降，时间效率会降至O(n)</li></ul></blockquote><p> 如果元素值不随机，</p><blockquote><ul><li>可以使用自平衡二叉树，如红黑树</li><li>时间复杂度 O(n)</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法 --- 双指针 Two Pointers</title>
    <link href="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E5%8F%8C%E6%8C%87%E9%92%88%20Two%20Pointers/"/>
    <url>/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E5%8F%8C%E6%8C%87%E9%92%88%20Two%20Pointers/</url>
    
    <content type="html"><![CDATA[<p>@[TOC](双指针 Two Pointers)</p><h1 id="双指针题型"><a href="#双指针题型" class="headerlink" title="双指针题型"></a>双指针题型</h1><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E5%8F%8C%E6%8C%87%E9%92%88%20Two%20Pointers/1.png"></p><h1 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h1><h2 id="背向双指针"><a href="#背向双指针" class="headerlink" title="背向双指针"></a>背向双指针</h2><h3 id="Example-1-最长回文子串"><a href="#Example-1-最长回文子串" class="headerlink" title="Example 1: 最长回文子串"></a>Example 1: 最长回文子串</h3><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E5%8F%8C%E6%8C%87%E9%92%88%20Two%20Pointers/2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">解题思路：中心拓展</span><br><span class="hljs-comment"> 1.遍历整个字符串</span><br><span class="hljs-comment"> 2. 以每个字符为中心向两边拓展</span><br><span class="hljs-comment"> 3. 拓展分为两种情况：</span><br><span class="hljs-comment">    1. 回文子串长度为奇数：abcba, 以c为中心：helper(s, i, i);</span><br><span class="hljs-comment">    2. 回文子串长度为偶数：abba,  以中间的两个b为中心: helper(s, i, i+1);</span><br><span class="hljs-comment"> 4. 记录每次发现的回文长度, 取最大值 </span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            helper(s, i, i); <span class="hljs-comment">//处理长度为奇数的情况</span><br>            helper(s, i, i+<span class="hljs-number">1</span>); <span class="hljs-comment">//处理长度为偶数的情况    </span><br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(left, right+<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> left_cur, <span class="hljs-type">int</span> right_cur)</span> &#123;<br>        <span class="hljs-keyword">while</span>(left_cur &gt;= <span class="hljs-number">0</span> &amp;&amp; right_cur &lt; s.length()) &#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(left_cur) != s.charAt(right_cur)) &#123;<br>                <span class="hljs-comment">//如果不相等, 退出循环</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//相等的情况下, 左指针往左一步, 右指针往右一步</span><br>                left_cur--;<br>                right_cur++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//因为right_cur和left_cur退出循环时是不相等的,需要各回退一步,所以left_cur+1, right_cur-1</span><br>        <span class="hljs-comment">//对于aba以b为中心时的这种情况， 退出循环时: left_cur = -1, right_cur = 3</span><br>        <span class="hljs-comment">//right_cur-1 - (left_cur+1)计算回文子串的长度</span><br>        <span class="hljs-keyword">if</span>(right_cur-<span class="hljs-number">1</span> - (left_cur+<span class="hljs-number">1</span>) &gt; right - left) &#123;           <br>            left = left_cur+<span class="hljs-number">1</span>;<br>            right = right_cur-<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="相向双指针"><a href="#相向双指针" class="headerlink" title="相向双指针"></a>相向双指针</h2><h3 id="Example-2-2-Sum"><a href="#Example-2-2-Sum" class="headerlink" title="Example 2: 2 Sum"></a>Example 2: 2 Sum</h3><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E5%8F%8C%E6%8C%87%E9%92%88%20Two%20Pointers/3.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//左右两个指针</span><br><span class="hljs-comment">//如果array[left]+ array[right] 大于 target 则right--</span><br><span class="hljs-comment">//如果array[left]+ array[right] 小于 target 则left++</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] numbers, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> numbers.length -  <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> numbers[left] + numbers[right];<br>            <span class="hljs-keyword">if</span> (sum  == target) &#123;<br>               <span class="hljs-type">int</span> [] myArray = &#123;left + <span class="hljs-number">1</span>, right + <span class="hljs-number">1</span>&#125;;<br>               <span class="hljs-keyword">return</span> myArray;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (sum &lt; target) &#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                right--;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> [] myArray = &#123;left, right&#125;;<br>        <span class="hljs-keyword">return</span> myArray;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Example-2-2-Sum-Greater-than-target"><a href="#Example-2-2-Sum-Greater-than-target" class="headerlink" title="Example 2: 2 Sum - Greater than target"></a>Example 2: 2 Sum - Greater than target</h3><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E5%8F%8C%E6%8C%87%E9%92%88%20Two%20Pointers/3.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums: an array of integer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target: An integer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: an integer</span><br><span class="hljs-comment">     */</span><br> <br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">twoSum2</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        Arrays.sort(nums);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums .length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> nums[left] + nums[right];<br>            <span class="hljs-keyword">if</span> (sum &lt;= target) &#123;<br>                left++;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                count += (right - left);<br>                right--;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> count;<br>        <br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="Example-3-2-Sum-Cloest-to-target"><a href="#Example-3-2-Sum-Cloest-to-target" class="headerlink" title="Example 3: 2 Sum - Cloest to target"></a>Example 3: 2 Sum - Cloest to target</h3><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E5%8F%8C%E6%8C%87%E9%92%88%20Two%20Pointers/4.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums an integer array</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target an integer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the difference between the sum and the target</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">twoSumClosest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        Arrays.sort(nums);<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> Integer.MAX_VALUE;<br>        <br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-keyword">if</span> (nums[left] + nums[right] &lt; target) &#123;<br>                diff = Math.min(diff, target - nums[left] - nums[right]);<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                diff = Math.min(diff, nums[left] + nums[right] - target);<br>                right--;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> diff;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="同向双指针"><a href="#同向双指针" class="headerlink" title="同向双指针"></a>同向双指针</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><h4 id="Example-1-Move-Zeros"><a href="#Example-1-Move-Zeros" class="headerlink" title="Example 1: Move Zeros"></a>Example 1: Move Zeros</h4><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E5%8F%8C%E6%8C%87%E9%92%88%20Two%20Pointers/5.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*Solution: 双指针</span><br><span class="hljs-comment">Example:</span><br><span class="hljs-comment">8 7 0 0 9</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">初始：</span><br><span class="hljs-comment">R</span><br><span class="hljs-comment">L</span><br><span class="hljs-comment">8  7  0  0  9</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果 nums[right] != 0, 则num[left] = nums[right], 然后left++，right++ 直到 num[right] == 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">   R                         R</span><br><span class="hljs-comment">   L                         L</span><br><span class="hljs-comment">8  7   0   0   9      8   7  0   0   9       </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果 num[right] == 0, 则 right++ 直到 num[right] != 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">            R                            R</span><br><span class="hljs-comment">        L                        L</span><br><span class="hljs-comment">8   7   0   0   9        8   7   0   0   9</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果 nums[right] != 0, 则 num[left] = nums[right]</span><br><span class="hljs-comment">               R</span><br><span class="hljs-comment">        L</span><br><span class="hljs-comment">8   7   9   0  9</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">因为right指针到头，所以跳出循环</span><br><span class="hljs-comment">然后从left指针开始往后 num[left] = 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        while (left &lt; nums.length) &#123;</span><br><span class="hljs-comment">            nums[left] = 0;</span><br><span class="hljs-comment">            left++;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment"> Answer:  8 7 9 0 0</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (right &lt; nums.length) &#123;<br>            <span class="hljs-keyword">if</span> (nums[right] != <span class="hljs-number">0</span>) &#123;<br>                nums[left] = nums[right];<br>                left++;<br>                right++;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            right++;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (left &lt; nums.length) &#123;<br>            nums[left] = <span class="hljs-number">0</span>;<br>            left++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Example-2-Middle-of-Linked-List"><a href="#Example-2-Middle-of-Linked-List" class="headerlink" title="Example 2: Middle of Linked List"></a>Example 2: Middle of Linked List</h4><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E5%8F%8C%E6%8C%87%E9%92%88%20Two%20Pointers/6.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用快慢指针，</span><br><span class="hljs-comment">慢指针每走一步，快指针走两步</span><br><span class="hljs-comment">*/</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">middleNode</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">slow</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head;<br>        <br>        <span class="hljs-keyword">while</span> (fast.next != <span class="hljs-literal">null</span>) &#123;<br>            slow = slow.next;<br>            <br>            <span class="hljs-keyword">if</span> (fast.next.next != <span class="hljs-literal">null</span>) &#123;<br>                fast = fast.next.next;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> slow;<br>            &#125;<br>            <br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法 --- 记忆化搜索 Memorization Search</title>
    <link href="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%20Memorization%20Search/"/>
    <url>/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%20Memorization%20Search/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是记忆化搜索"><a href="#什么是记忆化搜索" class="headerlink" title="什么是记忆化搜索"></a>什么是记忆化搜索</h1><blockquote><ul><li>在递归函数中, 在函数返回前，记录函数的返回结果。在下一次以同样参数访问函数时直接返回记录下的结果</li><li>也就是对递归树进行剪枝，遇到已经计算过的节点就不再继续往下计算，直接返回储存在hash table中的值</li></ul></blockquote><h1 id="记忆化搜索函数的三个特点"><a href="#记忆化搜索函数的三个特点" class="headerlink" title="记忆化搜索函数的三个特点"></a>记忆化搜索函数的三个特点</h1><blockquote><ul><li>函数有返回值</li><li>函数返回结果和输入参数有关，和其他全局状态无关</li><li>参数列表中传入哈希表或者其他用于记录计算结果的数据结构</li></ul></blockquote><h1 id="记忆化搜索-vs-动态规划"><a href="#记忆化搜索-vs-动态规划" class="headerlink" title="记忆化搜索 vs 动态规划"></a>记忆化搜索 vs 动态规划</h1><blockquote><ul><li>记忆化搜索是动态规划的一种实现方式, 也就是top-down approach</li><li>动态规划的另一种实现方式是多重循环 (找出动态转移方程，循环遍历)， 也就是bottom-up approach</li></ul></blockquote><h1 id="三种适用于DP的场景"><a href="#三种适用于DP的场景" class="headerlink" title="三种适用于DP的场景"></a>三种适用于DP的场景</h1><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%20Memorization%20Search/1.png"></p><h1 id="三种不适用于DP的场景"><a href="#三种不适用于DP的场景" class="headerlink" title="三种不适用于DP的场景"></a>三种不适用于DP的场景</h1><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%20Memorization%20Search/2.png"></p><h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples:"></a>Examples:</h1><h2 id="Leetcode-140-单词拆分-II"><a href="#Leetcode-140-单词拆分-II" class="headerlink" title="Leetcode 140: 单词拆分 II"></a>Leetcode 140: 单词拆分 II</h2><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%20Memorization%20Search/3.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">利用dfs搜索 + 回溯</span><br><span class="hljs-comment">对于字符串 ss，如果某个前缀是单词列表中的单词，则拆分出该单词，然后对 s 的剩余部分继续拆分。如果可以将整个字符串 s 拆分成单词列表中的单词，则得到一个句子</span><br><span class="hljs-comment">Example:</span><br><span class="hljs-comment">catsanddog</span><br><span class="hljs-comment">c 不在字典里</span><br><span class="hljs-comment">ca 不在字典里</span><br><span class="hljs-comment">cat在字典里，所以将剩余部分 sanddog 送入递归， 进入下一层</span><br><span class="hljs-comment">以此类推</span><br><span class="hljs-comment">回溯时将每一层的字符串加入前一层返回的字符串</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">优化: 记忆化搜索</span><br><span class="hljs-comment">以上方法在个别测试用例时会超时，所以需要记忆化搜索剪枝</span><br><span class="hljs-comment">第一次查找后，用一个map记录每个index的答案</span><br><span class="hljs-comment">下次再遇到就直接用</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> &#123;<br>        <span class="hljs-comment">//用一个map实现记忆化搜索： &lt;index, 这个index之后的所有答案&gt;</span><br>        Map&lt;Integer, List&lt;String&gt;&gt; memo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(); <br>        <span class="hljs-keyword">return</span> dfs(s, wordDict, <span class="hljs-number">0</span>, memo);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">dfs</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict, <span class="hljs-type">int</span> startIndex, Map&lt;Integer, List&lt;String&gt;&gt; memo)</span> &#123;<br>       <span class="hljs-comment">//查看目前的startIndex是否已经被查找过，如果是，则直接返回答案</span><br>       <span class="hljs-keyword">if</span> (memo.get(startIndex) != <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> memo.get(startIndex);<br>       &#125;<br><br>       <span class="hljs-comment">//如果startIndex等于length，则说明已经触底，返回空</span><br>       <span class="hljs-keyword">if</span> (startIndex == s.length()) &#123;<br>           List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>           list.add(<span class="hljs-string">&quot;&quot;</span>);<br>           <span class="hljs-keyword">return</span> list;<br>       &#125;<br><br><br>        List&lt;String&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> startIndex; i &lt;= s.length(); i++) &#123;<br>            <span class="hljs-comment">//如果startIndex到 i - 1 组成的字符串在字典里 （substring方法不包括最后的i，所以for loop是  i &lt;= s.length()）</span><br>            <span class="hljs-keyword">if</span> (wordDict.contains(s.substring(startIndex, i))) &#123;<br>                <span class="hljs-comment">//i为startIndex，进入下一次递归</span><br>                List&lt;String&gt; tempList = dfs(s, wordDict, i, memo);<br>                <span class="hljs-comment">//处理返回的答案，将startIndex到i组成的字符串加入到 返回的list中的每个字符串</span><br>                <span class="hljs-keyword">for</span> (String tempString: tempList) &#123;<br>                    <span class="hljs-comment">//如果字符串为空，则后面不能有空格，特殊处理</span><br>                    <span class="hljs-keyword">if</span> (tempString == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>                        ans.add(s.substring(startIndex, i));<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    ans.add(s.substring(startIndex, i) + <span class="hljs-string">&quot; &quot;</span> + tempString);<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//记录startIndex的所有答案</span><br>            memo.put(startIndex, ans);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Leetcode-44-通配符匹配"><a href="#Leetcode-44-通配符匹配" class="headerlink" title="Leetcode 44: 通配符匹配"></a>Leetcode 44: 通配符匹配</h2><p><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2%20Memorization%20Search/4.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">本题有两种解法：</span><br><span class="hljs-comment">第一种：记忆化递归</span><br><span class="hljs-comment">分别用ss和pp遍历字符串s和p</span><br><span class="hljs-comment">case 1：如果 ss==pp 或者 pp= &quot;?&quot; 则ss++, pp++, 进入下一层递归</span><br><span class="hljs-comment">case 2：如果 pp == &quot;*&quot;</span><br><span class="hljs-comment">        for (int i = s_start; i &lt;= s.length(); i++) &#123;</span><br><span class="hljs-comment">            将 i 和 pp + 1 送入递归函数, 进行对比</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">使用两个boolean数组：记录 visited[i][j] 和 results[i][j]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">第二种：动态规范</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMatch</span><span class="hljs-params">(String s, String p)</span> &#123;<br>        <span class="hljs-keyword">if</span> (s ==<span class="hljs-literal">null</span> || p == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-type">boolean</span> [][] visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()][p.length()];<br>        <span class="hljs-type">boolean</span> [][] results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[s.length()][p.length()];<br>        <span class="hljs-keyword">return</span> helper(s, <span class="hljs-number">0</span>, p, <span class="hljs-number">0</span>, visited, results);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">helper</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> s_start, String p, <span class="hljs-type">int</span> p_start,</span><br><span class="hljs-params">                          <span class="hljs-type">boolean</span> [][] visited, <span class="hljs-type">boolean</span> [][] results)</span> &#123;<br><br>        <span class="hljs-comment">//如果p_start等于p.length，则说明p字符串已经处理完毕，s需要也处理完毕，否则就是false    </span><br>        <span class="hljs-comment">//注意这里是p.length 不是 p.length - 1                 </span><br>        <span class="hljs-keyword">if</span> (p_start == p.length()) &#123;<br>            <span class="hljs-keyword">return</span> s_start == s.length();<br>        &#125;<br><br>        <span class="hljs-comment">//如果s字符串处理完毕，则p剩下的字符需要全部是 *</span><br>        <span class="hljs-keyword">if</span> (s_start == s.length()) &#123;<br>            <span class="hljs-keyword">return</span> ifAllStar(p, p_start);<br>        &#125;<br><br>        <span class="hljs-comment">//判断目前的index是否处理过</span><br>        <span class="hljs-keyword">if</span> (visited[s_start][p_start]) &#123;<br>            <span class="hljs-keyword">return</span> results[s_start][p_start];<br>        &#125;<br><br>        <span class="hljs-type">char</span> <span class="hljs-variable">pp</span> <span class="hljs-operator">=</span> p.charAt(p_start);<br>        <span class="hljs-type">char</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> s.charAt(s_start);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">match</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br><br>        <span class="hljs-keyword">if</span> (pp != <span class="hljs-string">&#x27;*&#x27;</span>) &#123; <br>            <span class="hljs-comment">//如果 ss==pp 或者 pp= &quot;?&quot; 则ss++, pp++, 进入下一层递归</span><br>            match = ifSameChar(ss, pp) &amp;&amp; helper(s, s_start + <span class="hljs-number">1</span>, p, p_start + <span class="hljs-number">1</span>, visited, results);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//这行代码和下面注释掉的fou loop是一个意思， 本质是 将 i不断递增 然后 和 pp + 1 送入递归函数, 进行对比</span><br>            <span class="hljs-comment">//注释掉的代码有点慢</span><br>            match = helper(s, s_start, p, p_start + <span class="hljs-number">1</span>, visited, results) || helper(s, s_start + <span class="hljs-number">1</span>, p, p_start, visited, results);<br>        &#125;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">        else &#123;</span><br><span class="hljs-comment">            for (int i = s_start; i &lt;= s.length(); i++) &#123;</span><br><span class="hljs-comment">                match = helper(s, i, p, p_start + 1, visited, results) || match;</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">        */</span><br>        <br>        results[s_start][p_start] = match;<br>        visited[s_start][p_start] = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-keyword">return</span> match;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">ifAllStar</span><span class="hljs-params">(String p, <span class="hljs-type">int</span> p_start)</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> p_start; i &lt; p.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (p.charAt(i) != <span class="hljs-string">&#x27;*&#x27;</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">ifSameChar</span><span class="hljs-params">(<span class="hljs-type">char</span> s, <span class="hljs-type">char</span> p)</span> &#123;<br>        <span class="hljs-keyword">return</span> (s == p || p == <span class="hljs-string">&#x27;?&#x27;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>算法 --- 二分查找 binarySearch</title>
    <link href="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%20binarySearch/"/>
    <url>/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%20binarySearch/</url>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><blockquote><p>在一串有序数组中（上升或下降）找出一个key值。<br>•如果key小于中值，则继续查找左边（上升）或者右边（下降）<br>•如果key等于中值，则查找成功<br>•如果key大于中值，则继续查找右边（上升）或者左边（下降）</p></blockquote><h1 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h1><blockquote><p>时间复杂度: O(nlogn + 1)      空间复杂度: O(1)<br>关于时间复杂度：<br>let n be a power of 2. After the first comparison, n&#x2F;2 elements are left for further search; after the second comparison, (n&#x2F;2)&#x2F;2 elements are left. After the kth comparison, n&#x2F;2^k elements are left for further search. When k &#x3D; log2n, only one element is left in the array, and you need only one more comparison. Therefore, in the worst case when using the binary search approach, you need log2n+1 comparison to find an element in the sorted array. In the worst case for a list of 1024 (2^10) elements, binary search requires only 11 comparisons, whereas a linear search requires 1023 comparisons in the worst case.<br><img src="/2024/04/27/%E7%AE%97%E6%B3%95%20---%20%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%20binarySearch/1.png"></p></blockquote><h1 id="如何取mid"><a href="#如何取mid" class="headerlink" title="如何取mid"></a>如何取mid</h1><blockquote><ul><li>第一种方法：(left + right) &#x2F; 2;</li><li>第二种方法:   left + (right - left) &#x2F; 2;</li></ul></blockquote><blockquote><p>第一种方法在left和right都近似int的最大值 2^31 的情况下会出现溢出，所以用第二种方法</p></blockquote><h1 id="Level-1-一般实现"><a href="#Level-1-一般实现" class="headerlink" title="Level 1:  一般实现"></a>Level 1:  一般实现</h1><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchNoneRecursive</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> [] input)</span>&#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> input.length -<span class="hljs-number">1</span>;<br><span class="hljs-type">int</span> mid;<br><br><span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>mid = (left+right)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span>(key == input[mid]) &#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br><span class="hljs-keyword">if</span>(key &lt; input[mid]) &#123;<br>right = mid - <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; input[mid]) &#123;<br>left =  mid + <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearchRecursive</span><span class="hljs-params">(<span class="hljs-type">int</span> key, <span class="hljs-type">int</span> [] input, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br><span class="hljs-keyword">if</span>(right &lt; left)<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - end) / <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span>(input[mid] == key) &#123;<br><span class="hljs-keyword">return</span> mid;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; input[mid]) &#123;<br><span class="hljs-keyword">return</span> binarySearchRecursive(key, input, left, mid-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; input[mid]) &#123;<br><span class="hljs-keyword">return</span> binarySearchRecursive(key, input, mid+<span class="hljs-number">1</span>, right);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Level-2-First-or-Last-Position-of-Target"><a href="#Level-2-First-or-Last-Position-of-Target" class="headerlink" title="Level 2: First or Last Position of Target"></a>Level 2: First or Last Position of Target</h1><h2 id="Last-Position-of-Target"><a href="#Last-Position-of-Target" class="headerlink" title="Last Position of Target"></a>Last Position of Target</h2><p>Last Position of Target： 取数组中最后一次出现的target的index, 比如: [1,2,3,3,3,56],取第三个3的下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums: The integer array.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target: Target to find.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: The first position of target. Position starts from 0.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lastPosition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//这里是left + 1 &lt; right</span><br>        <span class="hljs-comment">//也就是还有两个数的时候退出循环</span><br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>          <span class="hljs-comment">//这里是left = mid,不直接return 因为不确定是否是最后一次出现的位置</span><br>          <span class="hljs-comment">//left=mid 把二分的范围向右收缩，这样可以找到最后一次出现的target</span><br>                left = mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[mid]) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    <br>    <span class="hljs-comment">//退出循环的时候还有两个数，所以要分别判断是否是target</span><br>    <span class="hljs-comment">//因为是找最后一次出现的位置，所以先判断right</span><br>        <span class="hljs-keyword">if</span> (nums[right] == target) &#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (nums[left] == target) &#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="First-Position-of-Target"><a href="#First-Position-of-Target" class="headerlink" title="First Position of Target"></a>First Position of Target</h2><p>First Position of Target： 取数组中第一次出现的target的index, 比如: [1,2,3,3,3,56],取第一个3的下标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums: The integer array.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> target: Target to find.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: The first position of target. Position starts from 0.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">binarySearch</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length -<span class="hljs-number">1</span>;<br>         <span class="hljs-comment">//这里是left + 1 &lt; right</span><br>        <span class="hljs-comment">//也就是还有两个数的时候退出循环</span><br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span> &lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <br>          <span class="hljs-comment">//这里是right=mid,不直接return 因为不确定是否是第一次出现的位置</span><br>          <span class="hljs-comment">//right=mid 把二分的范围向左收缩，这样可以找到第一次出现的target</span><br>            <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>                right = mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &lt; nums[mid]) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">//退出循环的时候还有两个数，所以要分别判断是否是target</span><br>    <span class="hljs-comment">//因为是找第一次出现的位置，所以先判断left</span><br>        <span class="hljs-keyword">if</span> (nums[left] == target) &#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;        <br>        <span class="hljs-keyword">if</span> (nums[right] == target) &#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Level-3-Find-Minimum-in-Rotated-Sorted-Array"><a href="#Level-3-Find-Minimum-in-Rotated-Sorted-Array" class="headerlink" title="Level 3: Find Minimum in Rotated Sorted Array"></a>Level 3: Find Minimum in Rotated Sorted Array</h1><blockquote><p>Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums &#x3D; [0,1,2,4,5,6,7] might become:</p><blockquote><ul><li>[4,5,6,7,0,1,2] if it was rotated 4 times.</li><li>[0,1,2,4,5,6,7] if it was rotated 7 times.</li></ul></blockquote><p>Notice that rotating an array [a[0], a[1], a[2], …, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], …, a[n-2]].<br>Given the sorted rotated array nums, return the minimum element of this array.</p></blockquote><blockquote><p>Example 1:<br>Input: nums &#x3D; [3,4,5,1,2]<br>Output: 1<br>Explanation: The original array was [1,2,3,4,5] rotated 3 times.<br>Example 2:</p></blockquote><blockquote><p>Input: nums &#x3D; [4,5,6,7,0,1,2]<br>Output: 0<br>Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.<br>Example 3:</p></blockquote><blockquote><p>Input: nums &#x3D; [11,13,15,17]<br>Output: 11<br>Explanation: The original array was [11,13,15,17] and it was rotated 4 times. </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">原理是利用二分法：</span><br><span class="hljs-comment">对于任意一个旋转过的数组：</span><br><span class="hljs-comment">Example: 6,7,1,2,3,4,5</span><br><span class="hljs-comment">如果mid的值大于right的值 （Example中的 2大于5） 则说明最小值在右边</span><br><span class="hljs-comment">如果mid的值小于right的值 则说明最小值在左边</span><br><span class="hljs-comment">如果mid的左边的值比mid大，mid右边的值也比mid大，则说明mid就是最小值 （3,1,2)</span><br><span class="hljs-comment">*/</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findMin</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left)/<span class="hljs-number">2</span>;<br><br>            <span class="hljs-comment">//处理mid等于第一个元素时的情况</span><br>            <span class="hljs-keyword">if</span> (mid == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>] &lt; nums[<span class="hljs-number">1</span>] ? nums[<span class="hljs-number">0</span>] : nums[<span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-comment">//处理mid等于最后一个元素时的情况</span><br>            <span class="hljs-keyword">if</span> (mid == nums.length - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> nums[nums.length-<span class="hljs-number">1</span>] &lt; nums[nums.length - <span class="hljs-number">2</span>] ? nums[nums.length - <span class="hljs-number">1</span>] : nums[nums.length - <span class="hljs-number">2</span>];<br>            &#125;<br><br>            <span class="hljs-comment">//如果mid的左边的值比mid大，mid右边的值也比mid大，则说明mid就是最小值 （3,1,2)</span><br>            <span class="hljs-keyword">if</span> (nums[mid - <span class="hljs-number">1</span>] &gt; nums[mid] &amp;&amp; nums[mid + <span class="hljs-number">1</span>] &gt; nums[mid]) &#123;<br>                <span class="hljs-keyword">return</span> nums[mid];<br>            &#125;<br>            <span class="hljs-comment">//如果mid的值大于right的值, 则说明最小值在右边</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[right]) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-comment">//其余情况在左边 (mid的值小于right的值 则说明最小值在左边)</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Level-4-Search-in-Rotated-Sorted-Array"><a href="#Level-4-Search-in-Rotated-Sorted-Array" class="headerlink" title="Level 4: Search in Rotated Sorted Array"></a>Level 4: Search in Rotated Sorted Array</h1><blockquote><p>You are given an integer array nums sorted in ascending order (with distinct values), and an integer target.<br>Suppose that nums is rotated at some pivot unknown to you beforehand (i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).<br>If target is found in the array return its index, otherwise, return -1.</p></blockquote><blockquote><p>Example 1:<br>Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 0<br>Output: 4<br>Example 2:</p></blockquote><blockquote><p>Input: nums &#x3D; [4,5,6,7,0,1,2], target &#x3D; 3<br>Output: -1<br>Example 3:</p></blockquote><blockquote><p>Input: nums &#x3D; [1], target &#x3D; 0<br>Output: -1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">采用二分法：</span><br><span class="hljs-comment">Example    6 7 8 9 1 2 3 4 5</span><br><span class="hljs-comment">在中间切一刀</span><br><span class="hljs-comment">如果nums[mid] &gt; nums[left]，则说明left到mid有序（递增顺序）</span><br><span class="hljs-comment">    判断 target是否在 left到mid之间，如果在则说明在左边，如果不在说明在右边</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果 nums[mid] &lt; nums[left], 则说明mid到right有序（递增顺序）</span><br><span class="hljs-comment">    判断 target是否在 mid到right之间，如果在则说明在右边，如果不在说明在左边</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">search</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> nums.length - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span> (left + <span class="hljs-number">1</span>&lt; right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <br>            <span class="hljs-comment">//如果nums[mid] &gt; nums[left]，则说明left到mid有序（递增顺序）</span><br>            <span class="hljs-keyword">if</span> (nums[mid] &gt; nums[left]) &#123;<br>                <span class="hljs-comment">// 判断 target是否在 left到mid之间</span><br>                <span class="hljs-keyword">if</span> (target &gt;= nums[left] &amp;&amp; target &lt;= nums[mid]) &#123;<br>                    right = mid;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    left = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//如果 nums[mid] &lt; nums[left], 则说明mid到right有序（递增顺序）</span><br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 判断 target是否在 mid到right之间</span><br>                <span class="hljs-keyword">if</span> (target &gt;= nums[mid] &amp;&amp; target &lt;= nums[right]) &#123;<br>                    left = mid;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (nums[left] == target) &#123;<br>            <span class="hljs-keyword">return</span> left;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nums[right] == target) &#123;<br>            <span class="hljs-keyword">return</span> right;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Level-5-Find-K-Closest-Elements"><a href="#Level-5-Find-K-Closest-Elements" class="headerlink" title="Level 5: Find K Closest Elements"></a>Level 5: Find K Closest Elements</h1><h1 id="Level-6-Wood-Cut"><a href="#Level-6-Wood-Cut" class="headerlink" title="Level 6: Wood Cut"></a>Level 6: Wood Cut</h1><blockquote><p>Given n pieces of wood with length L[i] (integer array). Cut them into small pieces to guarantee you could have equal or more than k pieces with the same length. What is the longest length you can get from the n pieces of wood? Given L &amp; k, return the maximum length of the small pieces.</p></blockquote><blockquote><p>Example 1<br>Input:<br>L &#x3D; [232, 124, 456]<br>k &#x3D; 7<br>Output: 114<br>Explanation: We can cut it into 7 pieces if any piece is 114cm long, however we can’t cut it into 7 pieces if any piece is 115cm long.<br>Example 2</p></blockquote><blockquote><p>Input:<br>L &#x3D; [1, 2, 3]<br>k &#x3D; 7<br>Output: 0<br>Explanation: It is obvious we can’t make it.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/*基于答案值域的二分法。</span><br><span class="hljs-comment">木头长度的范围在 1 到 max(L)，在这个范围内二分出一个长度 length，</span><br><span class="hljs-comment">然后看看以这个 wood length 为前提的基础上，能切割出多少木头，</span><br><span class="hljs-comment">如果少于 k 根，说明要短一些才行，如果多余 k，说明可以继续边长一些。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> L: Given n pieces of wood with length L[i]</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> k: An integer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>: The maximum length of the small pieces</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">woodCut</span><span class="hljs-params">(<span class="hljs-type">int</span>[] L, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>            maxL = Math.max(maxL, L[i]);<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> maxL;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> count(mid, L);<br>            <br>            <span class="hljs-keyword">if</span> (temp &gt;= k) &#123;<br>                result = mid;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">count</span><span class="hljs-params">(<span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> [] L)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; L.length; i++) &#123;<br>            sum += L[i] / mid;<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>系统设计 --- E2E Test System</title>
    <link href="/2024/04/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%20---%20E2E%20Test%20System/"/>
    <url>/2024/04/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%20---%20E2E%20Test%20System/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是E2E"><a href="#什么是E2E" class="headerlink" title="什么是E2E"></a>什么是E2E</h1><blockquote><ul><li>E2E（端到端）测试是一种软件测试方法，旨在模拟真实的用户场景，测试整个应用程序或系统的端到端功能和交互流程。E2E 测试涵盖了从用户界面到后端系统的完整路径，以确保应用程序在各个组件和系统之间正确地集成和协同工作</li><li>E2E 测试通常涵盖以下方面：<blockquote><ul><li>用户场景模拟： E2E 测试通过模拟真实用户的操作和交互来测试应用程序的功能。这包括模拟用户在应用程序中的点击、输入、导航和操作等行为。</li><li>数据流和交互测试： E2E 测试验证不同组件之间的数据传递和交互是否正确。它可以测试用户界面与后端服务、数据库、第三方集成等之间的数据流和交互。</li><li>系统集成和部署测试： E2E 测试还可以验证应用程序在不同环境中的集成和部署情况。它可以测试应用程序在不同的操作系统、浏览器、设备或网络条件下的兼容性和可靠性。</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>简单来说就是 一个系统中会包括很多个workflow, 比如一个电商网站可能会包括 用户注册登陆, 添加商品到购物车,  下单等</li><li>对于每个workflow, 都有对应的测试用例. 保证这些workflow的正确性以确保系统的可用性, 防止新加入的代码破坏这些workflow</li><li>对于每个环境, 都会单独跑E2E, 保证每个环境下workflow的正常运转</li><li>E2E test 通常是一个定时任务, 比如每15分钟触发一次</li><li>E2E的通过率代表了系统的可用性</li></ul></blockquote><h1 id="E2E-Architecture-Example"><a href="#E2E-Architecture-Example" class="headerlink" title="E2E Architecture Example"></a>E2E Architecture Example</h1><p><img src="/2024/04/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%20---%20E2E%20Test%20System/1.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 日常case记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>系统设计 -- 如何管理配置信息</title>
    <link href="/2024/04/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%20--%20%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/"/>
    <url>/2024/04/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%20--%20%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="配置信息包含哪些"><a href="#配置信息包含哪些" class="headerlink" title="配置信息包含哪些"></a>配置信息包含哪些</h1><blockquote><ul><li>所有服务的地址(Uri)</li><li>每个环境的Token</li><li>数据库,消息队列等的用户名和密码</li><li>……</li></ul></blockquote><h1 id="如何储存"><a href="#如何储存" class="headerlink" title="如何储存"></a>如何储存</h1><blockquote><ul><li>从安全性和运维的角度出发, 不能写在code里, 而需要统一管理</li><li>所有的非密码性配置, 存在consul注册中心的KeyValue Storage里</li><li>密码性信息, 存在Azure KeyValut里</li></ul></blockquote><h1 id="如何调用"><a href="#如何调用" class="headerlink" title="如何调用"></a>如何调用</h1><p><img src="/2024/04/27/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%20--%20%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E4%BF%A1%E6%81%AF/1.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 日常case记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对数据库的并发操作导致数据重复插入</title>
    <link href="/2024/04/27/%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5/"/>
    <url>/2024/04/27/%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%8F%92%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="对数据库的并发操作导致数据重复插入"><a href="#对数据库的并发操作导致数据重复插入" class="headerlink" title="对数据库的并发操作导致数据重复插入"></a>对数据库的并发操作导致数据重复插入</h1><blockquote><ul><li>日常开发的过程中遇到这样一个问题,  代码需要根据某个字段是否存在来判断是添加数据还是更新数据.</li><li>换个生活中的例子就是, 两个用户同时注册账号, 如果用户名已存在则注册失败, 不存在则注册成功</li><li>这类问题的代码处理逻辑通常是:<blockquote><ul><li><ol><li>查询数据库, 判断用户名是否已经在数据库里</li></ol></li><li><ol start="2"><li>根据查询结果进行判断注册成功还是注册失败</li></ol></li></ul></blockquote></li><li>但是如果两个用户同时进行注册操作, 则两个用户第一步的查询结果都会为不存在, 最后导致数据库出现重复数据</li></ul></blockquote><h2 id="使用唯一索引解决"><a href="#使用唯一索引解决" class="headerlink" title="使用唯一索引解决"></a>使用唯一索引解决</h2><blockquote><ul><li>唯一索引是数据库中一种特殊类型的索引，用于确保索引列中的值是唯一的。</li><li>在唯一索引下，数据库系统会强制要求索引列中的每个值都是唯一的，<strong>这意味着你无法在索引列中插入或更新具有与现有行中相同值的新行</strong> </li><li>这样在插入数据的时候就可以避免重复数据, 还可以提高查询性能</li></ul></blockquote><p><strong>SQL</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 连接到数据库</span><br>USE YourDatabaseName;<br><br><span class="hljs-comment">-- 创建用户表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> Users (<br>    UserID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY <span class="hljs-keyword">IDENTITY</span>(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>),<br>    Username NVARCHAR(<span class="hljs-number">50</span>) <span class="hljs-keyword">UNIQUE</span>,<br>    Phone NVARCHAR(<span class="hljs-number">20</span>),<br>    Email NVARCHAR(<span class="hljs-number">100</span>),<br>    Address NVARCHAR(<span class="hljs-number">255</span>)<br>);<br></code></pre></td></tr></table></figure><p><strong>MongDB</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> MongoDB.Driver;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">MongoDBExample</span><br>&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 连接到MongoDB数据库</span><br>            MongoClient client = <span class="hljs-keyword">new</span> MongoClient(<span class="hljs-string">&quot;mongodb://localhost:27017&quot;</span>);<br>            IMongoDatabase database = client.GetDatabase(<span class="hljs-string">&quot;mydatabase&quot;</span>);<br>            Console.WriteLine(<span class="hljs-string">&quot;Database connected successfully&quot;</span>);<br><br>            <span class="hljs-comment">// 获取或创建用户表（集合）</span><br>            IMongoCollection&lt;User&gt; usersCollection = database.GetCollection&lt;User&gt;(<span class="hljs-string">&quot;users&quot;</span>);<br><br>            <span class="hljs-comment">// 创建用户名字段的唯一索引</span><br>            <span class="hljs-comment">// indexKeysDefinition 是一个索引对象, mongdb中需要指明是升序索引还是降序索引</span><br>            <span class="hljs-keyword">var</span> indexKeysDefinition = Builders&lt;User&gt;.IndexKeys.Ascending(u =&gt; u.Username);<br>            <span class="hljs-keyword">var</span> indexOptions = <span class="hljs-keyword">new</span> CreateIndexOptions &#123; Unique = <span class="hljs-literal">true</span> &#125;;<br>            <span class="hljs-keyword">var</span> indexModel = <span class="hljs-keyword">new</span> CreateIndexModel&lt;User&gt;(indexKeysDefinition, indexOptions);<br>            usersCollection.Indexes.CreateOne(indexModel);<br><br>            <span class="hljs-comment">// 插入示例数据</span><br>            <span class="hljs-keyword">var</span> user = <span class="hljs-keyword">new</span> User<br>            &#123;<br>                Username = <span class="hljs-string">&quot;john_doe&quot;</span>,<br>                Phone = <span class="hljs-string">&quot;1234567890&quot;</span>,<br>                Email = <span class="hljs-string">&quot;john@example.com&quot;</span>,<br>                Address = <span class="hljs-string">&quot;123 Main St, City, Country&quot;</span><br>            &#125;;<br>            usersCollection.InsertOne(user);<br><br>            Console.WriteLine(<span class="hljs-string">&quot;Inserted user: &#123;0&#125;&quot;</span>, user.Username);<br><br>            <span class="hljs-comment">// 关闭连接</span><br>            client.Close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">User</span><br>    &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Username &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Phone &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Email &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Address &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="延申-订票系统会遇到的并发问题"><a href="#延申-订票系统会遇到的并发问题" class="headerlink" title="延申: 订票系统会遇到的并发问题"></a>延申: 订票系统会遇到的并发问题</h1><p>To be continued</p>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 日常case记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- 使用信号量控制查询并发数量</title>
    <link href="/2024/04/27/C#%20---%20%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9F%A5%E8%AF%A2%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F/"/>
    <url>/2024/04/27/C#%20---%20%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9F%A5%E8%AF%A2%E5%B9%B6%E5%8F%91%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="背景简介"><a href="#背景简介" class="headerlink" title="背景简介"></a>背景简介</h1><blockquote><ul><li>当同时对数据库进行并发查询时, 如果查询数量过多, 会导致数据库压力大, 触发性能问题</li><li>可以使用信号量控制查询的并发数量</li></ul></blockquote><p><strong>什么信号量 — Semaphore</strong></p><blockquote><ul><li>semaphore的本质是一个计数器</li><li>semaphore主要用于调度进程, 维护对共享资源的顺序</li><li>所以利用semaphore可以解决很多进程同步的问题，如mutex，生产者消费者问题，read&#x2F;writer问题等</li></ul></blockquote><p><strong>信号量的实现</strong></p><blockquote><ul><li>数据结构semaphore包括一个 counter用来表示目前的资源数量，和一个queue用于存放等待中的线程</li><li>semaphore的实现包括两个函数: post(signal or release), wait<blockquote><ul><li>wait对counter进行递减操作，表示消费掉资源一个, 如果递减完counter为负说明目前没有资源可供消费，则需要将目前进程放进等待队列, 然后block掉</li><li>post对counter进行递增操作，表示资源增加一个，如果递增完counter小于等于0则说明有线程在排队等待消费资源，所以需要队列中的资源移出,然后唤醒</li></ul></blockquote></li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//pseudo code</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> counter;<span class="hljs-comment">//表示目前的资源数量</span><br><span class="hljs-built_in">queue</span> q;<span class="hljs-comment">//用于存放等待中的线程</span><br>&#125; <span class="hljs-type">sem_t</span> <br><br><span class="hljs-comment">//v operation</span><br>release(<span class="hljs-type">sem_t</span> *s) &#123;<br>s.counter++;<br><span class="hljs-comment">//counter小于等于0则说明有线程在排队等待消费资源，所以需要队列中的资源移出,然后唤醒线程</span><br><span class="hljs-keyword">if</span> (s.counter &lt;= <span class="hljs-number">0</span>) &#123;<br>remove(s.q, p);<br>wakeup(q);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//p operation</span><br>wait(<span class="hljs-type">sem_t</span> *s) &#123;<br>s.counter--;<br><span class="hljs-comment">//counter为负说明目前没有资源可供消费，则需要将目前进程放进等待队列, 然后block掉</span><br><span class="hljs-keyword">if</span> (s.counter &lt; <span class="hljs-number">0</span>) &#123;<br>add this thread to s.q;<br>block();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">Query</span>()</span> <br>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-built_in">int</span> MaxQueriesCanHandle = <span class="hljs-number">10</span>;<br>List&lt;Query&gt; queries =  GetAllQueries();<br>SemaphoreSlim semaphoreSlim = <span class="hljs-literal">null</span><br><span class="hljs-keyword">try</span><br>&#123;<br><span class="hljs-comment">//如果需要查询的数量大于最大值, 则申请一个counter为MaxQueriesCanHandle的信号量</span><br><span class="hljs-keyword">if</span> (queries.Count &gt; MaxQueriesCanHandle) <br>&#123;<br>semaphoreSlim = <span class="hljs-keyword">new</span> SemphoreSlim(MaxQueriesCanHandle);<br>&#125;<br><span class="hljs-comment">//使用Select遍历queries, 发出所有查询, 同时传入信号量</span><br><span class="hljs-keyword">var</span> tasks = queries.Select(query =&gt; QueryData(query, semaphoreSlim)<br><span class="hljs-comment">//等待所有查询完成, 聚合结果</span><br><span class="hljs-keyword">var</span> results = <span class="hljs-keyword">await</span> Task.WhenAll(tasks).ConfiqureAwait(<span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-keyword">finally</span> <br>&#123;<br>    <span class="hljs-comment">//注意最后要销毁信号量</span><br>semaphoreSlim.Dispose();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task&lt;DataResult&gt; <span class="hljs-title">QueryData</span>(<span class="hljs-params">Query query, SemaphoreSlim semaphoreSlim</span>)</span><br>&#123;<br><span class="hljs-keyword">if</span> (semaphoreSlim == <span class="hljs-literal">null</span>)<br>&#123;<br>    <span class="hljs-comment">//如果信号量为空, 则说明需要查询的数量小于最大值, 不用控制</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> QueryDatabase(query)<br>&#125;<br><br><span class="hljs-keyword">try</span><br>&#123;<br>    <span class="hljs-comment">//信号量进行Wait操作,也就是counter--, 如果小于0, 则此线程被block, 进入等待状态</span><br><span class="hljs-keyword">await</span> semaphoreSlim.WaitAsync.ConfigureAwait(fasle);<br><span class="hljs-comment">//查询数据库</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> QueryDatabase(query)<br>&#125;<br><span class="hljs-keyword">finally</span> <br>&#123;<br><span class="hljs-comment">//查询完毕, counter++, 唤醒在等待的线程</span><br>semaphoreSlim.ReLease();<br>&#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="SemaphoreSlim-vs-Semaphore"><a href="#SemaphoreSlim-vs-Semaphore" class="headerlink" title="SemaphoreSlim vs Semaphore"></a>SemaphoreSlim vs Semaphore</h1><blockquote><ul><li>SemaphoreSlim represents a lightweight alternative to Semaphore that limits the number of threads that can access a resource or pool of resources concurrently.</li></ul></blockquote><blockquote><ul><li>Semaphores are of two types: local semaphores and named system semaphores. <blockquote><ul><li>Local semaphores are local to an application</li><li>system semaphores are visible throughout the operating system and are suitable for inter-process synchronization.</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>The SemaphoreSlim is a lightweight alternative to the Semaphore class that doesn’t use Windows kernel semaphores. </li><li>Unlike the Semaphore class, the SemaphoreSlim class doesn’t support named system semaphores. You can use it as a local semaphore only. </li><li>The SemaphoreSlim class is the recommended semaphore for synchronization within a single app.</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 日常case记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- 使用 IValidatableObject + [Required] 接口进行数据校验</title>
    <link href="/2024/04/27/C#%20---%20%E4%BD%BF%E7%94%A8%20IValidatableObject%20+%20%5BRequired%5D%20%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/"/>
    <url>/2024/04/27/C#%20---%20%E4%BD%BF%E7%94%A8%20IValidatableObject%20+%20%5BRequired%5D%20%E6%8E%A5%E5%8F%A3%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><blockquote><ul><li>在Web Api的开发中,  一般都需要对传进来的参数也就是Data Model 进行校验<blockquote><ul><li>比如用户在前端上传csv文件，然后前端将csv文件内容转换为Dto传给后端，而此时所有数据都需要校验.</li></ul></blockquote></li><li>当[Required]不能满足验证逻辑时, 可以使用 IValidatableObject 进行校验，到达切面编程的效果</li></ul></blockquote><h1 id="IValiatableObject"><a href="#IValiatableObject" class="headerlink" title="IValiatableObject"></a>IValiatableObject</h1><p><strong>实现校验逻辑</strong></p><blockquote><ul><li>使用 IValiatableObject 的类需要实现 <code>public IEnumerable&lt;ValidationResult&gt; Validate(ValidationContext validationContext)</code> 这个方法</li><li>将验证逻辑写入Validate方法, 并将结果加入 ValidationResult 返回</li><li>注意如果不想验证全部属性 则将需要验证的属性用 [Required] Attribute 进行修饰<blockquote><ul><li>被 [Required]  修饰的属性不能为空, 否则会报 “x property is required”</li></ul></blockquote></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">RequestModel</span> : <span class="hljs-title">ParentModel</span>, <span class="hljs-title">IValidatableObject</span><br>   &#123;<br>   <span class="hljs-comment">//使用static 属性将外部数据注入进来用于校验</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IReadOnlyCollection&lt;<span class="hljs-built_in">string</span>&gt; ValidNamesCache;<br>       <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> DataId;<br>       <br>       [<span class="hljs-meta">Required</span>] <span class="hljs-keyword">public</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span> name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>       [<span class="hljs-meta">Required</span>]<br>       <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> DataId &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>       <span class="hljs-function"><span class="hljs-keyword">public</span> IEnumerable&lt;ValidationResult&gt; <span class="hljs-title">Validate</span>(<span class="hljs-params">ValidationContext validationContext</span>)</span><br>       &#123;<br>           <span class="hljs-comment">//以下参数部分来自于ParentModel</span><br>           <span class="hljs-keyword">var</span> validationResults = <span class="hljs-keyword">new</span> List&lt;ValidationResult&gt;();<br><br>           <span class="hljs-keyword">if</span> (!System.Enum.IsDefined(<span class="hljs-keyword">typeof</span>(Shape), <span class="hljs-keyword">this</span>.Shape))<br>           &#123;<br>               validationResults.Add(<span class="hljs-keyword">new</span> ValidationResult(<span class="hljs-string">$&quot;Shape &#x27;<span class="hljs-subst">&#123;<span class="hljs-keyword">this</span>.Shape&#125;</span>&#x27; is invalid.&quot;</span>));<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.Availability.Equals(Consts.Customer) &amp;&amp;<br>               !<span class="hljs-keyword">this</span>.Availability.Equals(Consts.Producer))<br>           &#123;<br>               validationResults.Add(<span class="hljs-keyword">new</span> ValidationResult(<span class="hljs-string">$&quot;Availability &#x27;<span class="hljs-subst">&#123;<span class="hljs-keyword">this</span>.Availability&#125;</span>&#x27; is invalid.&quot;</span>));<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (!Consts.Classification.Contains(<span class="hljs-keyword">this</span>.Classification))<br>           &#123;<br>               validationResults.Add(<span class="hljs-keyword">new</span> ValidationResult(<span class="hljs-string">$&quot;Classification &#x27;<span class="hljs-subst">&#123;<span class="hljs-keyword">this</span>.LegalClassification&#125;</span>&#x27; is invalid.&quot;</span>));<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (!ValueTypeMatch.Validate(<span class="hljs-keyword">this</span>.ValueType))<br>           &#123;<br>               validationResults.Add(<span class="hljs-keyword">new</span> ValidationResult(<span class="hljs-string">$&quot;ValueType &#x27;<span class="hljs-subst">&#123;<span class="hljs-keyword">this</span>.ValueType&#125;</span>&#x27; is invalid.&quot;</span>));<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (!ValidNamesCache.Contains(<span class="hljs-keyword">this</span>.Quantity))<br>           &#123;<br>               <span class="hljs-keyword">var</span> errorMessage = <span class="hljs-string">$&quot;Quantity &#x27;<span class="hljs-subst">&#123;<span class="hljs-keyword">this</span>.Quantity&#125;</span>&#x27; is invalid.&quot;</span>;<br>               validationResults.Add(<span class="hljs-keyword">new</span> ValidationResult(errorMessage));<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (DataId != <span class="hljs-literal">null</span> &amp;&amp; ! <span class="hljs-keyword">this</span>.DataId.Equals(DataId))<br>           &#123;<br>               <span class="hljs-keyword">var</span> errorMessage = <span class="hljs-string">$&quot;DataId &#x27;<span class="hljs-subst">&#123;<span class="hljs-keyword">this</span>.DataId&#125;</span>&#x27; is invalid.&quot;</span>;<br>               validationResults.Add(<span class="hljs-keyword">new</span> ValidationResult(errorMessage));<br>           &#125;<br><br>           <span class="hljs-keyword">return</span> validationResults;<br>       &#125;<br></code></pre></td></tr></table></figure><p><strong>进行参数校验</strong></p><blockquote><ul><li>使用 <code>Validator.TryValidateObject</code> 进行参数校验, 可以在任何地方调用Validator</li><li>当调用 Validator.TryValidateObject 方法时, 框架自动调用之前定义的校验逻辑<blockquote><ul><li>如果使用了IValidatableObject的接口, 则[Required]注解会在调用Validator时执行</li><li>如果只是用[Required]修饰属性, 没有使用IValidatableObject接口, 则在反序列化Dto时执行 [Required]</li></ul></blockquote></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> validationResults = <span class="hljs-keyword">new</span> List&lt;ValidationResult&gt;();<br> <br>Validator.TryValidateObject(<br>     requestModel, <span class="hljs-comment">//需要被校验的数据</span><br>     <span class="hljs-keyword">new</span> ValidationContext(requestModel, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>), <br>     validationResults, <span class="hljs-comment">//储存验证结果的数据结构</span><br>     <span class="hljs-literal">false</span> <span class="hljs-comment">//是否校验全部Property, false的话只会校验被[Required]修饰的属性</span><br>);<br><br><span class="hljs-keyword">if</span> (validationResults.Count &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">//logic to handle invalid properties</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 日常case记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# ---netcore MVC项目框架结构 with MongoDB</title>
    <link href="/2024/04/27/C#%20---netcore%20MVC%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%20with%20MongoDB/"/>
    <url>/2024/04/27/C#%20---netcore%20MVC%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%20with%20MongoDB/</url>
    
    <content type="html"><![CDATA[<h1 id="Overall-Structure"><a href="#Overall-Structure" class="headerlink" title="Overall Structure"></a>Overall Structure</h1><p><img src="/2024/04/27/C#%20---netcore%20MVC%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%20with%20MongoDB/1.png"></p><blockquote><ul><li>Netcore中一个项目对应一个solution, 一个solution包含多个project</li><li>一个最基本的微服务通常包含四个project: <code>WebAPI</code>, <code>Common</code>, <code>UnitTests</code>, <code>IntegrationTests</code><blockquote><ul><li>其中WebAPI project类型为Web project, 其他为class library project</li></ul></blockquote></li><li>WebAPI会定义<blockquote><ul><li><code>controllers</code></li><li><code>service implementation</code>  (也可以放在Common里, 防止circular reference)</li><li><code>service Interface</code></li></ul></blockquote></li><li>Common则定义所有的基础组件, 包括<blockquote><ul><li><code>Dtos</code> (Data Transfer Object) , 也就是Response 和 Request</li><li><code>Models</code> 服务中需要的实体类</li><li><code>Persistence</code>: 和数据库交互的类(这里使用MongoDB)</li><li><code>ExternalApiCall:</code> 和其他服务交互的类</li></ul></blockquote></li></ul></blockquote><h1 id="WebAPI-—-Controller"><a href="#WebAPI-—-Controller" class="headerlink" title="WebAPI — Controller"></a>WebAPI — Controller</h1><blockquote><ul><li>Controller 负责<blockquote><ul><li>将HTTP request映射成所定义的request Dto</li><li>调用相对应的功能代码, 也就是service</li><li>将处理结果映射成所定义的response Dto</li><li>controller要尽可能的简短, 一个controller只包含最简单的service调用</li></ul></blockquote></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FeatureSettingsController</span> : <span class="hljs-title">ControllerBase</span><br>&#123;<br><span class="hljs-comment">//声明需要的其他service</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IFeatureSettingRequestHandler _requestHandler;<br><br><span class="hljs-comment">//构造函数初始化其他service, DI机制自动通过构造函数注入将对应的实例注入</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FeatureSettingsController</span>(<span class="hljs-params">IFeatureSettingRequestHandler requestHandler</span>)</span><br>&#123;<br>requestHandler = reguestHandler;<br>&#125;<br><br><span class="hljs-comment">//Example:</span><br>[<span class="hljs-meta">HttpPost(<span class="hljs-string">&quot;featureSettings/query&quot;</span>)</span><br><span class="hljs-meta">[ProducesResponseType(typeof(SettingsResponseDto), StatusCodes.Status200OK)</span><br><span class="hljs-meta">[ProducesResponseType(StatusCodes.Status400BadRequest)</span>] <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;SettingsResponseDto&gt; <span class="hljs-title">GetFeatureSettings</span>(<span class="hljs-params">[FromBody ，Required] GetSettingsRequestDto request</span>)</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> _requestHandler.GetFeatureSettingsAsync(request);<br>&#125;<br><br>[<span class="hljs-meta">ProducesResponseType(typeof(SettingValuesResponseDto)</span>]<br>[<span class="hljs-meta">ProducesResponseType(StatusCodes.status400BadRequest)</span><br><span class="hljs-meta">public async Task&lt;SettingValuesResponseDto&gt; GetFeatureSettingValues([FromBody.Required</span>] GetsettingsRequestpto request)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> requestHandler.GetFeatureSettingValuesAsync(request);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="WebAPI-—-Service-and-Service-Implementation"><a href="#WebAPI-—-Service-and-Service-Implementation" class="headerlink" title="WebAPI — Service and Service Implementation"></a>WebAPI — Service and Service Implementation</h1><blockquote><ul><li>一般把处理请求的功能模块设计成多个接口, 每个接口就是一个service, 而每个service有相对应的implementation</li><li>一般结构为:<blockquote><ul><li><code>controller</code> —调用—  <code>requestHandler service</code> — 调用 —<br><code>functional service</code> —调用— <code>repository service</code></li></ul></blockquote></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">FeatureSettingRequestHandler</span> :<span class="hljs-title">IFeatureSettingRequestHandler</span><br>&#123;<br><span class="hljs-comment">//声明需要的其他service</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ISettingDefinitionRepository _settingDefinitionRepository;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> ISettingValueRepository _settingValueRepository;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> SettingscopeManager _settingScopeManager;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> SettingValueValidatorFactory _settingValueValidatorFactory;<br><br><span class="hljs-comment">//构造函数初始化其他service, DI机制自动通过构造函数注入将对应的实例注入</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FeaturesettingRequestHandler</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">ISettingDefinitionRepository settingDefinitionRepository,</span></span><br><span class="hljs-params"><span class="hljs-function">ISettingValueRepository settingValueRepository,</span></span><br><span class="hljs-params"><span class="hljs-function">SettinaScopeManager settinascopeManager</span></span><br><span class="hljs-params"><span class="hljs-function">SettingValueValidatorFactory settingValueValidatorFactory</span>)</span><br>&#123;<br>_settingDefinitionRepository = settingDefinitionRepository;<br>_settingValueRepository = settingValueRepository;<br>_settingScopeManager = settingscopeManager;<br>_settingValueValidatorFactory = settingValueValidatorFactory;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//实现service需要的方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;settingsResponseDto&gt; <span class="hljs-title">GetFeatureSettingsAsync</span>(<span class="hljs-params">GetSettingsRequestDto request</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Taske&lt;SettingValuesResponseDto&gt; <span class="hljs-title">GetFeatureSettingValuesAsync</span>(<span class="hljs-params">GetsettingsRequestDto request</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task&lt;IReadonlyList&lt;SettingValueWithQueriedscope&gt;&gt; <span class="hljs-title">FindAndResolveValueswithHighestPriority</span>(<span class="hljs-params">IReadonlyList&lt;SettingId&gt; settingIds, IReadonlyList&lt;SettingScopeChain&gt;</span></span><br><span class="hljs-params"><span class="hljs-function">.....</span></span><br></code></pre></td></tr></table></figure><h1 id="Common-—-Repository-Dtos-Models"><a href="#Common-—-Repository-Dtos-Models" class="headerlink" title="Common — Repository, Dtos, Models"></a>Common — Repository, Dtos, Models</h1><p> <strong>Repository Service</strong></p><blockquote><ul><li>Repository service的功能是和数据库交互</li><li>一般每个service对应MongoDB一个collection, 定义所对应的增删改查的操作</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SettingValueRepository</span> : <span class="hljs-title">ISettingValueRepository</span><br>&#123;<br><span class="hljs-comment">//声明需要的 database client service</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> IDatabaseClient _databaseClient;<br><span class="hljs-comment">//构造函数初始化其他service, DI机制自动通过构造函数注入将对应的实例注入</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">settingValueRepository</span>(<span class="hljs-params">IDatabaseClient databaseclient</span>)</span><br>&#123;<br>databaseClient = databaseclient;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;IReadonlyList&lt;SettingValue&gt;&gt; GetValuesAsync(IEnumerable&lt;SettingId&gt; settingIds, IEnumerable&lt;SettingScopeChain&gt; scopeChains)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;IReadonlyList&lt;settingValueChange&gt;&gt; SetValuesAsync(<span class="hljs-function">IEnumerable&lt;SettingValueChange&gt; settingValueChangeValues</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">long</span>&gt; <span class="hljs-title">DeleteValuesAsync</span>(<span class="hljs-params">settingscope settingscope</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">long</span>&gt; <span class="hljs-title">PurgeExpiredValuesAsync</span>()</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>Dtos  and  Models</strong></p><blockquote><ul><li>一般将所有需要的实体类都放进 Models,  实体类一般只有field, 用来描述一个object.包括定义数据库模型</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//定义数据库模型, 每个field表示一个document中的一个字段</span><br><span class="hljs-comment">//需要加 注解 和继承DatabaseDocument接口</span><br>[<span class="hljs-meta">DatabaseCollection(<span class="hljs-string">&quot;SettingDefinition&quot;</span>)</span>] <span class="hljs-comment">//字符串表示collection名字</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SettingDefinition</span> : <span class="hljs-title">DatabaseDocument</span> <br>&#123;<br>[<span class="hljs-meta">BsonRequired</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Code &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><br>[<span class="hljs-meta">BsonRequired</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Namespace f <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><br>[<span class="hljs-meta">BsonRequired</span>]<br><span class="hljs-built_in">string</span> DisplayName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; )<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Description &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>: &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>? DisplayOrder &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><br>[<span class="hljs-meta">BsonRequired，BsonRepresentation(BsonType.string)</span><br><span class="hljs-meta">public settingValueType Type &#123; get; init; &#125;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">public string sectionCode &#123; get; init; &#125;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">public ValidationRules ValidationRules &#123; get; init;&#125;</span><br><span class="hljs-meta">&#125;</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>Dtos全称为 Data Transfer Object, 通常定义request和reponse和相关的实体类</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//下面定义了一个 response</span><br><span class="hljs-comment">//settingResponseDto, 会被框架映射成json string放入HTTP response</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">settingsResponseDto</span><br>&#123;<br>[<span class="hljs-meta">Required</span>]  <br><span class="hljs-function"><span class="hljs-keyword">public</span> IReadonlylist&lt;SettingItemDtoWithdisplayPropertie&gt; <span class="hljs-title">Settings</span> (<span class="hljs-params"> <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; </span>)</span> = Array.Empty&lt;settingItemDtowithDisplayproperties&gt;();<br><br>[<span class="hljs-meta">Required</span>]<br><span class="hljs-keyword">public</span> TReadonlyList&lt;settingSectionDto&gt; Sections &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125; = Array.EmptyesettingsectionDto&gt;<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">SettingSectionDto</span><br>&#123;<br>[<span class="hljs-meta">Required</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Code &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; ]<br>[<span class="hljs-meta">Required</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Namespace &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>[<span class="hljs-meta">Required</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> DisplayName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Description &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Displayorder &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">SettingItemDtcWithDisplayProperties</span><br>&#123;<br>[<span class="hljs-meta">Required</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> DisplayName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Description &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125; <br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> sectionCode &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; ]<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span>? DisplayOrder &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-keyword">public</span> VaLidationRules ValidationRules &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-keyword">public</span> SettingscopeDto InheritedFrom &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Program-cs"><a href="#Program-cs" class="headerlink" title="Program.cs"></a>Program.cs</h1><blockquote><ul><li>netcore的web application 会从Program.cs文件开始运行</li><li>Program.cs文件的主要功能是进行一些初始化配置和依赖注入</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> Microsoft.Extensions.Hosting;<br><span class="hljs-keyword">using</span> Common;<br><br><span class="hljs-keyword">var</span> builder = WebApplication.CreateBuilder(args);<br><br><span class="hljs-keyword">var</span> app = builder.BuildApplication();<br><br><span class="hljs-keyword">var</span> startupTasks = app.Services.GetServices&lt;IStartupTask&gt;();<br><br><span class="hljs-keyword">foreach</span>(<span class="hljs-keyword">var</span> startupTask <span class="hljs-keyword">in</span> startupTasks)<br>&#123;<br>    <span class="hljs-keyword">await</span> startupTask.ExecuteAsync();<br>&#125;<br><br>app.Run();<br><br><span class="hljs-comment">//Needed for  unit tests</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>配置所需要的组件, 包括数据库, MQ, Logging, Swagger等</li><li>配置的核心就是进行依赖注入</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WebApplicationBuilderExtensions</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> WebApplication <span class="hljs-title">BuildApplication</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> webApplicationBuilder builder</span>)</span><br>&#123;<br><span class="hljs-keyword">var</span> services = builder.Services:<br><span class="hljs-keyword">var</span> configuration = builder.Configuration;<br>services.ConfigureLogging(configuration)<br>.ConfiqureConfiguration(configuration)<br>.ConfigureSwagger()<br>.ConfigureAspNetCore()<br>.ConfigureMongo()<br>.ConfigureRabbitMg()<br>.Configuresecurity()<br>.ConfigureBusinessCode()<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><ul><li>下面是对service中自己定义的service进行依赖注入, 需要说明注入的service接口和所对应的Implementation.</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> IServiceCollection <span class="hljs-title">ConfigureBusinessCode</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> IServiceCollection services</span>)</span><br>&#123;<br>services.AddSingleton&lt;IstartupTask, SettingDefinitionInitializationTask&gt;();<br>services.AddSingleton&lt;IFeatureSettingRequestHandler,FeatureSettingRequestHandler&gt;();<br>services.AddSingleton&lt;SettingscopeManager&gt;();<br>services.AddSingleton&lt;settingValueValidatorFactory&gt;();<br>services.AddSingleton&lt;ISettingValueRepository，SettingValueRepository&gt;();<br>services.AddSingleton&lt;ISettingDefinitionRepository, SettingDefinitionRepository&gt;();<br>services,AddSingleton&lt;ISettingDefinitionSource,EmbeddedFilesettingDefinitionSource&gt;();<br>services.AddSingleton&lt;IAssemblyResource，AssemblyResource&gt;();<br>services.AddSingleton&lt;MemoryCacheFactory&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>依赖注入的本质是在服务运行前, 用一个容器(比如List), 将服务所需要的service创建出来并放进容器中, 这样在服务运行的时候需要用到service的时候, 直接从容器中取出 而不需要我们手动的new一个service</li></ul></blockquote><h1 id="csproject-配置文件"><a href="#csproject-配置文件" class="headerlink" title=".csproject 配置文件"></a>.csproject 配置文件</h1><blockquote><ul><li>点击project名字, 会出现一个.csproject文件, 这就是这个project的配置文件, 包括所有引用的外部库的名字和版本信息<br><img src="/2024/04/27/C#%20---netcore%20MVC%E9%A1%B9%E7%9B%AE%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84%20with%20MongoDB/2.png"></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 日常case记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- MongoDB如何安全的替换Collection</title>
    <link href="/2024/04/27/C#%20---%20MongoDB%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84%E6%9B%BF%E6%8D%A2Collection/"/>
    <url>/2024/04/27/C#%20---%20MongoDB%E5%A6%82%E4%BD%95%E5%AE%89%E5%85%A8%E7%9A%84%E6%9B%BF%E6%8D%A2Collection/</url>
    
    <content type="html"><![CDATA[<p>@[TOC](C# — MongoDB如何安全的替换Collection)</p><h1 id="应用背景"><a href="#应用背景" class="headerlink" title="应用背景"></a>应用背景</h1><blockquote><ul><li>应用背景: 需要注入新的数据, 整体替换掉之前的数据</li></ul></blockquote><blockquote><ul><li>替换思路<blockquote><ul><li>第一步: 备份原来的数据</li><li>第二步: 创建新的tempCollection将新的数据注入进tempCollection</li><li>第三步: 将tempCollection改名为old collection name并删除掉old collection, 更新版本数据. </li><li>第四步: 删除备份数据</li></ul></blockquote></li></ul></blockquote><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ReplaceAllDefinitionsAsvnc</span>(<span class="hljs-params">IEnumerablesSettingDefinition&gt; settingDefinitions, IEnumerable&lt;SectionDefinition&gt; sectionDefinitions, IEnumerable&lt;SettingValue&gt; settingValues, <span class="hljs-built_in">string</span> newVersion</span>)</span><br>&#123;<br>ArgumentNulException.ThrowIfNull(settingDefinitions);<br>ArgumentNullException.ThrowIfNull(sectionDefinitions);<br>ArgumentNullException.ThrowIfNull(settingValues);<br><br><span class="hljs-keyword">await</span> BackupExistingDefinitionsAndValuesAsync();<br><span class="hljs-keyword">await</span> PopulateNewDefinitionsAndValuesAsTempCollectionAsync(settingDefinitions, sectionDefinitions, settingValues);<br><span class="hljs-keyword">await</span> RenameTempAndDropBackupCollectionAsync(newVersion);<br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">BackupExistingDefinitionsAndValuesAsync</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-keyword">await</span> dbClient.DropCollectionIfExistAsync(SettingDefinitionBackupCollectionName</span>)</span>;<br> <span class="hljs-keyword">await</span> dbClient.CloneCollectionIfExistAsync(SettinqDefinitionCollectionName, SettingDefinitionBackupCollectionName);<br><br> <span class="hljs-keyword">await</span> dbClient.DropCollectionIfExistAsync(SectionDefinitionBackupCollectionName);<br> <span class="hljs-keyword">await</span> dbclient.CloneCollectionIfExistAsync(SectionDefinitionCollectionName, SectionDefinitionBackupCollectionName);<br> <br> <span class="hljs-keyword">await</span>  dbClient.DropCollectionIfExistAsync(SettingValueBackupCollectionName);<br> <span class="hljs-keyword">await</span>  dbclient,CloneCollectionIfExistAsync(SettingValueCollectionName, SettingValueBackupCollectionName);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">PopulateNewDefinitionsAndValuesAsTempCollectionAsync</span>(<span class="hljs-params">IEnumerables&lt;SettingDefinition&gt; settingDefinitions, IEnumerable&lt;SectionDefinition&gt; sectionDefinitions, IEnumerables&lt;SettingValue&gt; settingValues</span>)</span><br>&#123;<br><span class="hljs-keyword">await</span> _dbClient.DropCollectionIfExistAsync(SettingDefinitionTempCollectionName);<br><span class="hljs-keyword">var</span> settingDefinitionTempCollection = <span class="hljs-keyword">await</span> dbClient.GetCollectionAsync&lt;SettingDefinition(SettingDefinitionTempCollectionName);<br><br><span class="hljs-keyword">await</span> <span class="hljs-function">dbclient <span class="hljs-title">DropCollectionTfExistvnc</span>(<span class="hljs-params">SectionDefinitionTemoCollectionName</span>)</span>;<br><span class="hljs-keyword">var</span> sectionDefinitionTempCollection = <span class="hljs-keyword">await</span> dbClient.GetCollectionAsync&lt;SectionDefinition&gt;(SectionDefinitionTempCollectionName)<br><br>    <span class="hljs-keyword">await</span> _dbClient.DropCollectionIfExistAsync(SettingValueTempCollectionName);<br>    <span class="hljs-keyword">var</span> settingValueTempCollection = <span class="hljs-keyword">await</span> dbClient.GetcollectionAsvncsSettingValu(SettingValueCollectionName);<br><br><span class="hljs-comment">//这里使用transaction实现三个collection数据的注入操作</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">var</span> session = <span class="hljs-keyword">await</span>  _dbClient.MongoClient.StartSessionAsync()<br>&#123;<br><span class="hljs-keyword">try</span> <br>&#123;<br>session.StartTransaction();<br><span class="hljs-keyword">var</span> settingDefinitionTask = settingDefinitionTempCollection,InsertManyAsync(session, settingDefinitions);<br><span class="hljs-keyword">var</span> sectionDefinitionTask = sectionDefinitionTempCollection.InsertManyAsync(session, sectionDefinitions);<br><span class="hljs-keyword">var</span> settingValueTask = settingValueTempCollection.InsertManyAsync(session, settingValues);<br><br><span class="hljs-keyword">await</span> sectionDefinitionTask;<br><span class="hljs-keyword">await</span> settinaValueTask;<br><span class="hljs-keyword">await</span> settingDefinitionTask;<br><br><span class="hljs-keyword">await</span> session.CommitTransactionAsync();<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex) <br>&#123;<br>logger.LogError(ex.Message);<br><span class="hljs-keyword">await</span> session .AbortTransactionAsvneOthrow;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">RenameTempAndDropBackupCollectionAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> newVersion</span>)</span><br>&#123;<br><span class="hljs-keyword">try</span> <br>&#123;<br><span class="hljs-comment">//最后一个参数true表示IfDropTarget, 也就是drop掉原来的Collection (第二个参数)</span><br><span class="hljs-keyword">await</span> dbClient.RenameCollectionIfExistAsync(SettingDefinitionTempCollectionName, SettinaDefinitionCollectionName, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">await</span> dbClient.RenameCollectionIfExistAsync(SectionDefinitionTempCollectionName, SectionDefinitionCollectionName, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">await</span> dbClient.RenameCollectionIfExistAsync(SettingvalueTempCollectionName, SettingValueCollectionName, <span class="hljs-literal">true</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex)<br>&#123;<br>Logger.LogError(ex.Message)<br><span class="hljs-comment">//如果rename失败, 则需要恢复备份数据</span><br><span class="hljs-keyword">await</span> RecoverBackupCollectionsAsync();<br> &#125;<br> <br> <span class="hljs-comment">//rename成功, 才能更新版本数据. 版本数据存在单独的Collection里, 只有一条数据, 就是当前版本</span><br> <span class="hljs-keyword">await</span> UpdateVersionAsync(newVersion);<br> <span class="hljs-comment">//删除之前的备份数据</span><br> <span class="hljs-keyword">await</span> DropBackupCollectionsAsync()<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//recover的方法就是把备份数据重写命名</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">async</span> Task RecoverBackupCollectionsAsync<br>&#123;<br><span class="hljs-keyword">await</span> dbClient.RenameCollectionIfExistAsync(SettingDefinitionBackupCollectionName, SettinaDefinitioncollectionName, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">await</span> dbClient.RenameCollectionIfExistAsync(SectionDefinitionBackupCollectionName, SectionDefinitionCollectionName, <span class="hljs-literal">true</span>);<br><span class="hljs-keyword">await</span> dbClient,RenameCollectionIfExistAsvnc(SettingValueBackupCollectionNameme, SettingValueCollectionName. <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 日常case记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- Mongo数据库事务的应用</title>
    <link href="/2024/04/27/C#%20---%20Mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BA%94%E7%94%A8/"/>
    <url>/2024/04/27/C#%20---%20Mongo%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>应用背景<blockquote><ul><li>输入是 <code>SettingValueChange [ ]</code> , 其中<code>unset</code> 为 <code>true</code>表示需要删除的数据, 为 <code>false</code> 表示需要新增或者修改的数据</li><li>也就是说会有两组数据库操作: 删除 和 upsert (update or insert)</li><li>两组操作保证原子性也就是要么全部成功要么全部不成功</li><li>使用事务实现</li></ul></blockquote></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SettingValueChange</span><br>&#123;<br>SettingId Identifier &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>SettingScope Scope &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><br>JsonElement JsonValue <br>&#123;<br><span class="hljs-keyword">get</span> =&gt; BsonValue .ToJsonElement();<br><span class="hljs-keyword">init</span> =&gt; BsonValue = <span class="hljs-keyword">value</span> .ToBsonValue():<br>&#125;<br><span class="hljs-keyword">public</span> BsonValue BsonValue  &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>DateTime0ffset? ExpiryTime &#123; <span class="hljs-keyword">get</span>;<span class="hljs-keyword">init</span>;&#125;<br><span class="hljs-built_in">bool</span> Unset &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;IReadOnlyList&lt;SettingvalueChange&gt;&gt; SetValuesAsync(IEnumerablesSettingValueChange&gt;settingValueChangeValues&gt;<br>&#123;<br>ArgumentNullException .ThrowIfNull(settingValueChangeValues);<br><span class="hljs-keyword">var</span> lookup = settingValueChangeValues.ToLookup(<span class="hljs-keyword">value</span> =&gt; <span class="hljs-keyword">value</span>.Unset);<br><span class="hljs-comment">//将数据分为需要删除的和需要新增或者修改的</span><br><span class="hljs-keyword">var</span> unsetChanges = lookup[truel.ToList();<br><span class="hljs-keyword">var</span> upsertChanges = Lookup[falsel.ToList();<br><br><span class="hljs-comment">//创建数据库筛查条件, 满足此条件的数据都是需要删除的数据</span><br><span class="hljs-keyword">var</span> unsetFilter = Builders&lt;SettingValue&gt;.Filter<br>    .Where(<span class="hljs-keyword">value</span> =&gt; unsetChanges <span class="hljs-comment">//这里的value表示数据库里的数据</span><br>    .Any(unsetChange =&gt; unsetChange.Identifier == <span class="hljs-keyword">value</span>.Identifier &amp;&amp; unsetChange.Scope == <span class="hljs-keyword">value</span>.Scope)):<br><br><span class="hljs-comment">//筛选需要新增或者修改的数据</span><br>updateOneModels = upsertChanges.Select(x =&gt;<br>&#123;<br><span class="hljs-keyword">var</span> builder = Builders&lt;SettingValue&gt;.Filter;<br><span class="hljs-keyword">var</span> upsertFilter = builder.Eq(v =&gt; v.Identifier, x.Identifier) &amp; builder.Eq(v =&gt; v.Scope, x.Scope);<br><span class="hljs-keyword">var</span> update = Builders&lt;SettingValue&gt;.Update<br>.Set(v =&gt; v.Identifier.x.Identifier)<br>.Set(v =&gt; v.Scope, x.Scope)<br>.Set(v =&gt; v.BsonValue, x.BsonValue)<br>.Set(v =&gt; v.ExpiryTime, x.ExpiryValue)<br>.SetOnInsert(v =&gt; v.Id, Guid.NewGuid().ToString());<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UpdateOneModel&lt;SettingValue&gt;(upsertFilter, update) &#123; IsUpsert = <span class="hljs-literal">true</span> ):<br>&#125;).ToList();<br><br><br><span class="hljs-keyword">var</span> settingValueCollection = <span class="hljs-keyword">await</span> _databaseClient.GetCollectionAsync&lt;SettingValue&gt;();<br><span class="hljs-keyword">using</span> (<span class="hljs-keyword">var</span> session = <span class="hljs-keyword">await</span> _databaseClient.MongoClient.StartSessionAsync()) <br>&#123;<br><span class="hljs-keyword">try</span> <br>&#123;<br><span class="hljs-comment">//开始事务</span><br>session.StartTransaction();<br><br><span class="hljs-comment">//创建操作数据库的Task</span><br><span class="hljs-keyword">var</span> deleteManyTask = settingValueCollection.DeleteManyAsync(session, unsetFilter);<br><span class="hljs-keyword">var</span> bulkwriteTask = update0neodels.Any() ? settingValueCollection.BulkWriteAsync(session, update0neModels) : <span class="hljs-literal">null</span><br><br><span class="hljs-comment">//等待执行结果</span><br><span class="hljs-keyword">await</span> deleteManyTask;<br><span class="hljs-keyword">if</span> (bulkwriteTask != <span class="hljs-literal">null</span>) <span class="hljs-keyword">await</span> bulkwriteTask;<br><br><span class="hljs-keyword">await</span> session.CommitTransactionAsync();<br><span class="hljs-keyword">return</span> settingValueChangeValues.ToList()<br>&#125;<br><span class="hljs-keyword">catch</span> (Exception ex) <br>&#123;<br><span class="hljs-keyword">await</span> session.AbortTransactionAsync();<br><span class="hljs-keyword">throw</span>;<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 日常case记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- 如何反序列化Json文件</title>
    <link href="/2024/04/26/C#%20---%20%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E8%BD%AC%E6%8D%A2Json%E6%96%87%E4%BB%B6/"/>
    <url>/2024/04/26/C#%20---%20%E5%A6%82%E4%BD%95%E8%AF%BB%E5%8F%96%E8%BD%AC%E6%8D%A2Json%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>@[TOC](C# — 如何反序列化Json文件)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br><span class="hljs-string">&quot;namespace&quot;</span> : &#123;<br><span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-string">&quot;Test&quot;</span>,<br><span class="hljs-string">&quot;sections&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-string">&quot;section-test1&quot;</span>,<br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;section-test&quot;</span><br><span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-string">&quot;displayOrder&quot;</span>: <span class="hljs-number">10</span><br><span class="hljs-string">&quot;settings&quot;</span>: [<br><span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-string">&quot;setting-test&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;setting test&quot;</span><br><span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-string">&quot;displayOrder&quot;</span>: <span class="hljs-number">11</span><br><span class="hljs-string">&quot;isReadOnly&quot;</span> : <span class="hljs-literal">true</span><br><span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;arrayOfString&quot;</span><br><span class="hljs-string">&quot;defaultValue&quot;</span>: [<span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>]<br><span class="hljs-string">&quot;defaultValueByEnvironement&quot;</span> : &#123;<br><span class="hljs-string">&quot;eur&quot;</span> : [<span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>]<br>&#125;<br><span class="hljs-string">&quot;validationRules&quot;</span> : &#123;<br><span class="hljs-string">&quot;enums&quot;</span> : [<br>&#123;<br><span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;value1&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;1&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;value2&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;2&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;value3&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;3&quot;</span><br>&#125;<br>]<br>&#125;<br>]<br>&#125;<br>],<br><span class="hljs-string">&quot;settings&quot;</span>: [<br>&#123;<br><span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-string">&quot;setting-test2&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;setting test&quot;</span><br><span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-string">&quot;displayOrder&quot;</span>: <span class="hljs-number">11</span><br><span class="hljs-string">&quot;isReadOnly&quot;</span> : <span class="hljs-literal">true</span><br><span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;arrayOfString&quot;</span><br><span class="hljs-string">&quot;defaultValue&quot;</span>: [<span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>]<br><span class="hljs-string">&quot;defaultValueByEnvironement&quot;</span> : &#123;<br><span class="hljs-string">&quot;eur&quot;</span> : [<span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>]<br>&#125;<br><span class="hljs-string">&quot;validationRules&quot;</span> : &#123;<br><span class="hljs-string">&quot;enums&quot;</span> : [<br>&#123;<br><span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;value1&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;1&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;value2&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;2&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;value3&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;3&quot;</span><br>&#125;<br>]<br>&#125;<br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;code&quot;</span>: <span class="hljs-string">&quot;setting-test3&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;setting test&quot;</span><br><span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;test&quot;</span><br><span class="hljs-string">&quot;displayOrder&quot;</span>: <span class="hljs-number">11</span><br><span class="hljs-string">&quot;isReadOnly&quot;</span> : <span class="hljs-literal">true</span><br><span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;arrayOfString&quot;</span><br><span class="hljs-string">&quot;defaultValue&quot;</span>: [<span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>]<br><span class="hljs-string">&quot;defaultValueByEnvironement&quot;</span> : &#123;<br><span class="hljs-string">&quot;eur&quot;</span> : [<span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>]<br>&#125;<br><span class="hljs-string">&quot;validationRules&quot;</span> : &#123;<br><span class="hljs-string">&quot;enums&quot;</span> : [<br>&#123;<br><span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;value1&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;1&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;value2&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;2&quot;</span><br>&#125;,<br>&#123;<br><span class="hljs-string">&quot;value&quot;</span>: <span class="hljs-string">&quot;value3&quot;</span><br><span class="hljs-string">&quot;displayName&quot;</span>: <span class="hljs-string">&quot;3&quot;</span><br>&#125;<br>]<br>&#125;<br>&#125;<br>]<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><ul><li>第一步: 选择json parser库, <code>System.Text.Json</code> </li><li>第二步: 对文件中的json object进行拆分, 判断出包含关系, 构建相对应的Model类</li></ul></blockquote><blockquote><blockquote><ul><li><code>namespace : code, sections[], settings[]</code></li><li><code>section : code, displayName, description, displayOrder, settings[]</code></li><li><code>setting : code, displayName, description, displayOrder, isReadOnly, type, defaultValue, defaultValueByEnvironment, validationRules</code></li></ul></blockquote></blockquote><blockquote><ul><li>第三步: 根据json结构构建对应的类</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ConfigurationFileModel</span><br>&#123;<br><span class="hljs-keyword">public</span> ConfigurationModel Namespace &#123; <span class="hljs-keyword">get</span>: <span class="hljs-keyword">init</span>: &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ConfigurationModel</span> <br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Code &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-keyword">public</span> IReadOnlyList&lt;SectionDefinitionModel&gt; Sections  &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125; = Array.Empty&lt;SectionDefinitionModel&gt;();<br><span class="hljs-keyword">public</span> IReadOnlyList&lt;SettingDefinitionModel&gt; Settings  &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125; = Array.Empty&lt;SettingDefinitionModel&gt;();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">SectionDefinitionModel</span><br>&#123;<br><span class="hljs-built_in">string</span> Code &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><span class="hljs-built_in">string</span> DisplayName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>: &#125;<br><span class="hljs-built_in">string</span> Description &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-built_in">int</span>? DisplayOrder &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>: &#125;<br>List&lt;SettingDefinitionModel&gt; Settings &#123; <span class="hljs-keyword">get</span>: <span class="hljs-keyword">init</span>;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SettingDefinitionModel</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Code &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-built_in">string</span> DisplayName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-built_in">string</span> Description &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>;&#125;<br><span class="hljs-built_in">int</span>? DisplayOrder &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>SettingValueType Type &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>JsonElement DefaultValue &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>Dictionary&lt;<span class="hljs-built_in">string</span>, JsonElement&gt; DefaultValueByEnvironment &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>ValidationRules ValidationRules &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>&#125;<br><br><span class="hljs-comment">//因为setting的信息里没有namspace和sectionCode, 所以定义 SettingDefinitionModelWithContext (继承自SettingDefinitionModel)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">SettingDefinitionModelWithContext</span> : <span class="hljs-title">SettingDefinitionModel</span><br>&#123;<br><span class="hljs-comment">//使用构造函数初始化, 而不是用setter</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SettingDefinitionlodelwithContext</span>(<span class="hljs-params">SettingDefinitionHodel setting, <span class="hljs-built_in">string</span> @<span class="hljs-keyword">namespace</span>, <span class="hljs-built_in">string</span> sectionCode</span>)</span> <br>&#123;<br>Namespace = @namespace;<br>SectionCode = sectionCode:<br>&#125;<br><br><span class="hljs-built_in">string</span> Namespace &#123; <span class="hljs-keyword">get</span>;&#125;<br><span class="hljs-built_in">string</span> SectionCode &#123; <span class="hljs-keyword">get</span>;&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">enum</span> SettingValueType <br>&#123;<br>Boolean, <br>String, <br>ArrayOfString<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ValidationRules</span> <br>&#123;<br><span class="hljs-keyword">public</span> IReadOnlyList&lt;EnumerationOption&gt; Enums &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EnumerationOption</span> <br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Value &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> DisplayName &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>第四步: 读取文件, 将json数据转换成对应的类</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//定义一个输出结果类, </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">InitialConfigurations</span> <br>&#123;<br>IReadOnlyList&lt;SectionDefinition&gt;SectionDefinitions &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = Array.Empty&lt;SectionDefinition&gt;();<br> IReadOnlyList&lt;SettingDefinition&gt;SettingDefinitions &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = Array.Empty &lt;SettingDefinition&gt;();<br>IReadOnlyList&lt;SettingValue&gt; Settingvalues &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>;  = Array.Empty&lt;SettingValue&gt;()<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">public</span> InitialConfigurations <span class="hljs-title">Merge</span>(<span class="hljs-params">InitialConfigurations initialInfo</span>)</span><br> &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InitialConfigurations() <br> &#123;<br> SectionDefinitions = SectionDefinitions.Concat(initialInfo.SectionDefinitions).ToList()<br> SettingDefinitions = SettingDefinitions.Concat(initialInfo.SettingDefinitions).ToList()<br> SettingValues = SettingValues.Concat(initialInfo.SettingValues).ToList()<br> &#125;<br> &#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;InitialConfigurations&gt; <span class="hljs-title">GetSettingDefinitionsAsync</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> environmentName</span>)</span> <br>&#123;<br><span class="hljs-comment">//读取文件夹中的json文件</span><br><span class="hljs-keyword">var</span> fileNames = Assembly.GetExecutingAssembly().GetManifestResourceNames()<br><span class="hljs-keyword">var</span> configurationFiles = fileNames.Where(fileName =&gt; IsJsonFile(fileName) &amp;&amp; ValidateFileNamePrefix(fileName)<br>List&lt;<span class="hljs-built_in">string</span>&gt; confiqurationJsonStrings = <span class="hljs-keyword">await</span> ConvertJosnFileJsonStringAsync(configurationFiles);<br><br><span class="hljs-comment">//将每个json文件转换成string, 开始解析</span><br><span class="hljs-keyword">var</span> initialCOnfigurations = GetInitialConfigurations(configurationJsonStrings, environmentName);<br><br><span class="hljs-keyword">return</span> initialConfigurations;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> InitialConfigurations <span class="hljs-title">GetInitialConfigurations</span>(<span class="hljs-params">IEnumerable&lt;<span class="hljs-built_in">string</span>&gt; configurationJsonStrings, <span class="hljs-built_in">string</span> environemntName</span>)</span> <br>&#123;<br>InitialConfiqurations initialConfigurations = <span class="hljs-keyword">new</span> InitialConfiqurations():<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> configurationJsonString <span class="hljs-keyword">in</span> configurationJsonStrings) <br>&#123;<br><span class="hljs-comment">//将一个文件对应的json string转换成之前定义的 ConfigurationFileModel</span><br>ConfigurationFilelodel configurationFileModel = JsonSerializer.<span class="hljs-function">Deserialize&lt;ConfigurationFilelodel&gt;</span><br><span class="hljs-function"><span class="hljs-title">if</span> (<span class="hljs-params">configurationFileModel == <span class="hljs-literal">null</span></span>)</span> &#123; <span class="hljs-keyword">continue</span>; &#125;                           <br>logger.LogInformation(<span class="hljs-string">$&quot;Processing namespace <span class="hljs-subst">&#123;configurationFileModel.Namespace.Code&#125;</span>&quot;</span>);<br><br><span class="hljs-comment">//对configurationFileModel进行解析</span><br><span class="hljs-keyword">var</span> initialConfiguration = ExtractDefinitionsAndValues(configurationFileModel, environmentlame);<br>initialConfigurations = initialConfigurations.Merge(initialConfiquration);<br>&#125;<br><br><span class="hljs-keyword">return</span> initialConfigurations<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> InitialConfigurations <span class="hljs-title">ExtractDefinitionsAndValues</span>(<span class="hljs-params">ConfigurationFilellodel configurationFilellodel, <span class="hljs-built_in">string</span> enviornmentName</span>)</span><br>&#123;<br><span class="hljs-comment">// 从 configurationFileModel 中拿到之前定义的 configurationModel</span><br><span class="hljs-comment">// configurationModel 包括 settings, sections, Namespace Code</span><br>ConfigurationModel configurationModel = configurationFileModel.Namespace;<br><br><span class="hljs-built_in">string</span> @namespace = confiqurationModel.Code;<br><span class="hljs-comment">//从 configurationModel 拿到 sections</span><br><span class="hljs-keyword">var</span> sections = configurationModel.Sections;<br><span class="hljs-comment">// 从 configurationModel 拿到 settings</span><br><span class="hljs-comment">// 读取setting的方法: 将 configurationModel 底下的settings 和 sections 底下的settings 合起来一起拿出</span><br><span class="hljs-comment">// sections是一个数组, sections底下的settings也是一个数组</span><br><span class="hljs-comment">// SelectMany的作用是把sections数组中每个section底下的settings抓取出来, 转换成一个一维的setting数组</span><br><span class="hljs-keyword">var</span> settings = sections<br>?.SelectMany(section =&gt; section.Settings, (section, setting) =&gt; <span class="hljs-keyword">new</span> SettingDefinitionMlodelithContext(setting,@namespace, Section.Code)<br> <span class="hljs-comment">//读取 configurationModel 底下的settings 并和sections底下的settings拼接起来</span><br>.Concat(configurationModel.Settings<br>.Where(setting =&gt; setting.Code != <span class="hljs-literal">null</span>)<br>.Select(setting =&gt; <span class="hljs-keyword">new</span> SettingDefinitionModelWithContext(setting, @namespace, <span class="hljs-literal">null</span>)))<br>.ToList() ?? <span class="hljs-keyword">new</span> List&lt;SettingDefinitionModelWithContext&gt;();<br><br><span class="hljs-comment">//根据sectionDefinitionModel提取sectionDefinition</span><br><span class="hljs-keyword">var</span> sectionDefinitions = GetSectionDefinitions(sections, @namespace);<br><span class="hljs-comment">//根据settingDefinitionModel提取setting definition和 setting value</span><br><span class="hljs-keyword">var</span> settingDefinitions = GetSettingDefinitionsAndValues(settings, environmentName);<br><br><span class="hljs-keyword">return</span> sectionDefinitions.Merge(settingDefinitions);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> InitialConfiqurations <span class="hljs-title">GetSectionDefinitions</span>(<span class="hljs-params">IRead0nlyListsSectionDefinitionModel&gt; sectionDefinitionModels</span>)</span><br>&#123;<br>    <span class="hljs-comment">//将sectionDefinitionModel 转化为 sectionDefinition</span><br>List&lt;SectionDefinition&gt; sectionDefinitions = sectionDefinitionModels.MapToSectionDefinitions(@namespace).ToList();<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InitialConfiqurations &#123; SectionDefinitions = sectionDefinitions &#125;;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> InitialConfigurations <span class="hljs-title">GetSettingDefinitionsAndValues</span>(<span class="hljs-params">IReadOnlyList&lt;SettinaDefinitionModelWithContext&gt; settingDefinitionModels</span>)</span><br>&#123;<br>    <span class="hljs-comment">//根据settingDefinitionModel提取setting definition和 setting value</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> InitialConfiqurations <br>&#123;<br>   SettingDefinitions = settingDefinitionModels.MapToSettingDefinitions().ToList(), <br>   SettingValues = settingDefinitionModels.MapToSettingValues(environmentName).ToList()<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 日常case记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- Extension Method</title>
    <link href="/2024/04/26/C#%20---Extension%20Method/"/>
    <url>/2024/04/26/C#%20---Extension%20Method/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>C# 扩展方法（Extension Methods）是一种语言特性，允许开发人员向现有的类或接口添加新的方法，而无需修改原始类的定义。扩展方法可以为已存在的类型添加功能，提供一种简洁的方式来扩展类的行为，而无需继承该类或修改其源代码。</li></ul></blockquote><p>下面是一个示例，展示如何定义和使用 C# 扩展方法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-keyword">namespace</span> <span class="hljs-title">ExtensionMethodsExample</span><br>&#123;<br>    <span class="hljs-comment">// 定义扩展方法的静态类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringExtensions</span><br>    &#123;<br>        <span class="hljs-comment">// 扩展方法示例：将字符串反转</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">string</span> <span class="hljs-title">Reverse</span>(<span class="hljs-params"><span class="hljs-keyword">this</span> <span class="hljs-built_in">string</span> input</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">char</span>[] charArray = input.ToCharArray();<br>            Array.Reverse(charArray);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(charArray);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>        &#123;<br>            <span class="hljs-built_in">string</span> originalString = <span class="hljs-string">&quot;Hello, world!&quot;</span>;<br><br>            <span class="hljs-comment">// 调用扩展方法</span><br>            <span class="hljs-built_in">string</span> reversedString = originalString.Reverse();<br><br>            Console.WriteLine(<span class="hljs-string">&quot;Original string: &quot;</span> + originalString);<br>            Console.WriteLine(<span class="hljs-string">&quot;Reversed string: &quot;</span> + reversedString);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>在上述示例中，我们创建了一个名为 StringExtensions 的静态类，并在其中定义了一个扩展方法 Reverse。该扩展方法接受一个字符串作为参数，并将其字符顺序反转。注意扩展方法的定义中使用了 this 关键字，它表示该方法是一个扩展方法，可以在目标类型的实例上直接调用。</li></ul></blockquote><blockquote><ul><li>在 Main 方法中，我们创建了一个字符串 originalString，然后通过调用扩展方法 Reverse() 将其反转。最后，我们输出原始字符串和反转后的字符串。</li></ul></blockquote><blockquote><ul><li>扩展方法使得我们可以像调用实例方法一样调用它们，即使它们实际上是定义在其他类中的静态方法。这样，我们可以方便地扩展现有类型的功能，而无需修改原始类的定义。</li></ul></blockquote><blockquote><ul><li>请注意，扩展方法必须定义在静态类中，并且该静态类必须在使用扩展方法的代码所在的命名空间中。此外，引用扩展方法所在的命名空间也是必需的，以便在代码中使用扩展方法。</li></ul></blockquote><p>使用扩展方法有以下几个好处：</p><ol><li>不需要修改原始类：扩展方法允许我们为现有的类添加新的方法，而无需修改原始类的定义。这对于无法修改源代码的第三方库或框架非常有用，我们可以通过扩展方法来扩展其功能，而无需直接修改库或框架代码。</li><li>提供清晰的语义：扩展方法可以使代码更具可读性和表达性。通过将相关的功能方法打包为扩展方法，我们可以通过直观的方式调用这些方法，使代码更加清晰和易于理解。</li><li>链式调用：扩展方法可以实现链式调用的编程风格。通过返回目标类型的实例，我们可以在一行代码中连续调用多个扩展方法，从而实现更简洁的代码编写和方法调用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 语法糖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- Struct and Record</title>
    <link href="/2024/04/26/C#%20---%20Struct%20and%20Record/"/>
    <url>/2024/04/26/C#%20---%20Struct%20and%20Record/</url>
    
    <content type="html"><![CDATA[<h1 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h1><blockquote><ul><li>struct是一种数据类型, 和class非常类似, 主要有以下的不同<blockquote><ul><li>struct是value type, class是reference type<blockquote><ul><li>因为是value type所以strcut不是必须储存在heap上</li><li>struct不能等于null, The default value for a struct is an empty instance, with all fields empty (set to their default values).</li><li>struct 支持值比对, 也就是可以直接用等于号比较</li></ul></blockquote></li><li>struct 不支持继承</li></ul></blockquote></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> Point<br>&#123;<br> <span class="hljs-built_in">int</span> x, y;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span> (<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span> &#123; <span class="hljs-keyword">this</span>.x = x; <span class="hljs-keyword">this</span>.y = y; &#125; <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>struct 的 default constructor</strong></p><blockquote><ul><li>a struct always has an implicit parameterless constructor.</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Point p = <span class="hljs-keyword">new</span> Point(); <span class="hljs-comment">// p.x and p.y will be 0</span><br><span class="hljs-keyword">struct</span> Point &#123; <span class="hljs-built_in">int</span> x, y; &#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>Even when you define a parameterless constructor of your own, the implicit parameterless constructor still exists and can be accessed via the default keyword:</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Point p1 = <span class="hljs-keyword">new</span> Point(); <span class="hljs-comment">// p1.x and p1.y will be 1</span><br>Point p2 = <span class="hljs-literal">default</span>; <span class="hljs-comment">// p2.x and p2.y will be 0</span><br><span class="hljs-keyword">struct</span> Point<br>&#123;<br><span class="hljs-built_in">int</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">int</span> y;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span>()</span> =&gt; y = <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Record"><a href="#Record" class="headerlink" title="Record"></a>Record</h1><blockquote><ul><li><code>record</code> 是基于class和struct的数据类型, 也就是分为 class based record 和 struct based record, struct可以包含fields, properties, method等</li><li><code>record</code> 可以实现interface, 也可以拥有继承关系 (class-based record)</li><li>record默认是class based record:  <code>record Point &#123; &#125; // Point is a class</code></li><li>struct based record: <code>record struct Point &#123; &#125; // Point is a struct</code></li></ul></blockquote><p><strong>一个简单的record</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span><br>&#123;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span> (<span class="hljs-params"><span class="hljs-built_in">double</span> x, <span class="hljs-built_in">double</span> y</span>)</span> =&gt; (X, Y) = (x, y); <span class="hljs-comment">//(X, Y) = (x, y); 等于 &#123; this.X = x; this.Y = y; &#125;</span><br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> X &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Y &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125; <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>在编译阶段, 以上的代码会被加入, 如下代码所示<blockquote><ul><li>编译器加入 protected copy constructor 和 hidden clone method 帮助实现 nondestructive mutation</li><li>重写比较方法(equal, hashcode等方法) 帮助实现值对比</li><li>重写toString() 方法</li></ul></blockquote></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span><br>&#123; <br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span> (<span class="hljs-params"><span class="hljs-built_in">double</span> x, <span class="hljs-built_in">double</span> y</span>)</span> =&gt; (X, Y) = (x, y);<br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> X &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Y &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125; <br> <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Point</span> (<span class="hljs-params">Point original</span>) <span class="hljs-comment">// “Copy constructor”</span></span><br> &#123;<br> <span class="hljs-keyword">this</span>.X = original.X; <span class="hljs-keyword">this</span>.Y = original.Y<br>  &#125;<br>  <span class="hljs-comment">// This method has a strange compiler-generated name:</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> Point &lt;Clone&gt;$() =&gt; <span class="hljs-keyword">new</span> Point (<span class="hljs-keyword">this</span>); <span class="hljs-comment">// Clone method</span><br> <span class="hljs-comment">// Additional code to override Equals, ==, !=, GetHashCode, ToString()</span><br> <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>record的parameter list</strong></p><blockquote><ul><li>record的后面可以用括号包括parameter list, 在初始化时可以直接 <code>var = new Point(12, 4)</code></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span> (<span class="hljs-title">double</span> <span class="hljs-title">X</span>, <span class="hljs-title">double</span> <span class="hljs-title">Y</span>)<br>&#123;<br> <span class="hljs-comment">// You can optionally define additional class members here...</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>编译器会对parameter list进行如下操作<blockquote><ul><li>给每个parameter构建 init-only property</li><li>构建primary constructor</li><li>构建deconstructor</li></ul></blockquote></li></ul></blockquote><p><strong>Nondestructive Mutation</strong></p><blockquote><ul><li>当我们需要对一个immutable object进行修改的时候, 我们需要创建一个新的object然后对原来的object进行copy以及修改, 这就是<code>Nondestructive Mutation</code>. 但是当property很多的时候, 就会很麻烦</li><li>record提供了更便捷的方法实现 Nondestructive Mutation, 使用<code>with</code> keyword</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Point p1 = <span class="hljs-keyword">new</span> Point (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>Point p2 = p1 <span class="hljs-keyword">with</span> &#123; Y = <span class="hljs-number">4</span> &#125;;<br>Console.WriteLine (p2); <span class="hljs-comment">// Point &#123; X = 3, Y = 4 &#125;</span><br><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span> (<span class="hljs-title">double</span> <span class="hljs-title">X</span>, <span class="hljs-title">double</span> <span class="hljs-title">Y</span>);<br></code></pre></td></tr></table></figure><blockquote><ul><li>In this example, p2 is a copy of p1, but with its Y property set to 4. The benefit is<br>more apparent when there are more properties:</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Test t1 = <span class="hljs-keyword">new</span> Test (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);<br>Test t2 = t1 <span class="hljs-keyword">with</span> &#123; A = <span class="hljs-number">10</span>, C = <span class="hljs-number">30</span> &#125;;<br>Console.WriteLine (t2);<br><span class="hljs-keyword">record</span> <span class="hljs-title">Test</span> (<span class="hljs-title">int</span> <span class="hljs-title">A</span>, <span class="hljs-title">int</span> <span class="hljs-title">B</span>, <span class="hljs-title">int</span> <span class="hljs-title">C</span>, <span class="hljs-title">int</span> <span class="hljs-title">D</span>, <span class="hljs-title">int</span> <span class="hljs-title">E</span>, <span class="hljs-title">int</span> <span class="hljs-title">F</span>, <span class="hljs-title">int</span> <span class="hljs-title">G</span>, <span class="hljs-title">int</span> <span class="hljs-title">H</span>);<br><span class="hljs-comment">//Here’s the output:</span><br>Test &#123; A = <span class="hljs-number">10</span>, B = <span class="hljs-number">2</span>, C = <span class="hljs-number">30</span>, D = <span class="hljs-number">4</span>, E = <span class="hljs-number">5</span>, F = <span class="hljs-number">6</span>, G = <span class="hljs-number">7</span>, H = <span class="hljs-number">8</span> &#125;<br></code></pre></td></tr></table></figure><p><strong>Record and Equality Comparsion</strong></p><blockquote><ul><li>record在编译时, 编译器会重写equal, hashcode等比较方法, 所以可以直接比较, 不需要像reference type一样重写equal和hashcode.</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> Point (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> Point (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>Console.WriteLine (p1.Equals (p2)); <span class="hljs-comment">// True</span><br><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span> (<span class="hljs-title">double</span> <span class="hljs-title">X</span>, <span class="hljs-title">double</span> <span class="hljs-title">Y</span>);<br></code></pre></td></tr></table></figure><blockquote><ul><li>The equality operator also works with records (as it does with tuples):</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Console.WriteLine (p1 == p2);  <span class="hljs-comment">// True</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>如果record包含 lazy values, transient’ value, arrays, 或者 collection type 或者 自定义的等于比较时, 需要重写equals 当然也需要重写GetHashCode()</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">record</span> <span class="hljs-title">Point</span> (<span class="hljs-title">double</span> <span class="hljs-title">X</span>, <span class="hljs-title">double</span> <span class="hljs-title">Y</span>)<br>&#123;<br><span class="hljs-built_in">double</span> _someOtherField;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">virtual</span> <span class="hljs-built_in">bool</span> <span class="hljs-title">Equals</span> (<span class="hljs-params">Point other</span>)</span> =&gt;<br>other != <span class="hljs-literal">null</span> &amp;&amp; X == other.X &amp;&amp; Y == other.Y;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Use case</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">settingscope</span>(<span class="hljs-params"> [property: BsonIgnoreIfNull] <span class="hljs-built_in">string</span> IdSettingscopeType Type</span>)</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Settingscope Global &#123; <span class="hljs-keyword">get</span>; &#125; = <span class="hljs-keyword">new</span>(<span class="hljs-literal">null</span>, SettingScopeType.Global);<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 语法糖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- Null Operator</title>
    <link href="/2024/04/26/C#%20---%20Null%20Operator/"/>
    <url>/2024/04/26/C#%20---%20Null%20Operator/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>C#提供了三种操作符用来更方便的处理 null value</li></ul></blockquote><h1 id="Null-Coalescing-Operator"><a href="#Null-Coalescing-Operator" class="headerlink" title="Null-Coalescing Operator  ??"></a>Null-Coalescing Operator  ??</h1><blockquote><ul><li><code>??</code> 操作符叫做null-coalescing operator.  </li><li>表示如果左侧的操作数非空, 则返回它; 否则, 返回另一个值</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> s1 = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">//如果s1不是null则返回s1，如果s1是null则返回 &quot;nothing&quot;</span><br><span class="hljs-built_in">string</span> s2 = s1 ?? <span class="hljs-string">&quot;nothing&quot;</span>; <span class="hljs-comment">// s2 evaluates to &quot;nothing&quot;</span><br></code></pre></td></tr></table></figure><h1 id="Null-Coalescing-Assignment-Operator"><a href="#Null-Coalescing-Assignment-Operator" class="headerlink" title="Null-Coalescing Assignment Operator ??&#x3D;"></a>Null-Coalescing Assignment Operator ??&#x3D;</h1><blockquote><ul><li>??&#x3D; 操作符是null-coalescing assignment operator. </li><li>表示如果左侧的操作数是null,  则将右边的操作数赋值给左边</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">myVariable ??= someDefault;<br><span class="hljs-comment">//等于</span><br><span class="hljs-keyword">if</span> (myVariable == <span class="hljs-literal">null</span>) myVariable = someDefault;<br></code></pre></td></tr></table></figure><h1 id="Null-Conditional-Operator"><a href="#Null-Conditional-Operator" class="headerlink" title="Null-Conditional Operator  ?."></a>Null-Conditional Operator  ?.</h1><blockquote><ul><li>?.  operator表示如果左侧的操作数为null, 则表达式的值为null, 而不会抛出<code>NullReferenceException</code></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">System.Text.StringBuilder sb = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// No error; s instead evaluates to null</span><br><span class="hljs-built_in">string</span> s = sb?.ToString(); <br><span class="hljs-comment">//等于 string s = (sb == null ? null : sb.ToString());</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> foo = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">char</span>? c = foo?[<span class="hljs-number">1</span>]; <br><span class="hljs-comment">// c is null, char? 表示让char可以为null的意思</span><br><span class="hljs-comment">//具体见 Nullale Value Types</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">System.Text.StringBuilder sb = <span class="hljs-literal">null</span>;<br><span class="hljs-comment">// s evaluates to null without error</span><br><span class="hljs-built_in">string</span> s = sb?.ToString().ToUpper(); <br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//If someObject is null, this becomes a “no-operation” </span><br><span class="hljs-comment">//rather than throwing a NullReferenceException.</span><br>someObject?.SomeVoidMethod();<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//可以混合使用</span><br>System.Text.StringBuilder sb = <span class="hljs-literal">null</span>;<br><span class="hljs-built_in">string</span> s = sb?.ToString() ?? <span class="hljs-string">&quot;nothing&quot;</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 语法糖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- Constructor, Object Initializer, Property, Constant, and readonly</title>
    <link href="/2024/04/26/C#%20---Constructor,%20Object%20Initializer,%20Property,%20Constant,%20and%20readonly/"/>
    <url>/2024/04/26/C#%20---Constructor,%20Object%20Initializer,%20Property,%20Constant,%20and%20readonly/</url>
    
    <content type="html"><![CDATA[<h1 id="Constructor-and-Object-Initializer"><a href="#Constructor-and-Object-Initializer" class="headerlink" title="Constructor and Object Initializer"></a>Constructor and Object Initializer</h1><blockquote><ul><li>constructor用来初始化, 可以被overload, 通过input parameter识别调用哪个constructor</li><li>如果没有自定义的constructor,  编译器会自动生成一个无参constructor<blockquote><ul><li>如果有自定义的constructor, 则不会自动生成无参constructor. 如果需要无参constructor，需要显示的写出来</li><li>constructor的权限一般都是public, 但是也可以用private修饰.  这样可以控制实例的生成. (如单例模式用static方法返回唯一的实例)</li><li>使用this关键字可以在一个constructor调用另外一个constructor</li></ul></blockquote></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Wine</span><br>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Price;<br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Year;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wine</span> (<span class="hljs-params"><span class="hljs-built_in">decimal</span> price</span>)</span> &#123; Price = price; &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wine</span> (<span class="hljs-params"><span class="hljs-built_in">decimal</span> price, <span class="hljs-built_in">int</span> year</span>) : <span class="hljs-title">this</span> (<span class="hljs-params">price</span>)</span> &#123; Year = year; &#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Wine</span> (<span class="hljs-params"><span class="hljs-built_in">decimal</span> price, DateTime year</span>) : <span class="hljs-title">this</span> (<span class="hljs-params">price, year.Year</span>)</span> &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Object Initializer</strong></p><blockquote><ul><li>Object Initializer提供了另外一种初始化Object的方法</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Bunny</span><br>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name;<br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> LikesCarrots;<br> <span class="hljs-keyword">public</span> <span class="hljs-built_in">bool</span> LikesHumans;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bunny</span> ()</span> &#123;&#125;<br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bunny</span> (<span class="hljs-params"><span class="hljs-built_in">string</span> n</span>)</span> &#123; Name = n; &#125;<br>&#125;<br><br><span class="hljs-comment">// Note parameterless constructors can omit empty parentheses</span><br>Bunny b1 = <span class="hljs-keyword">new</span> Bunny &#123; Name=<span class="hljs-string">&quot;Bo&quot;</span>, LikesCarrots=<span class="hljs-literal">true</span>, LikesHumans=<span class="hljs-literal">false</span> &#125;;<br>Bunny b2 = <span class="hljs-keyword">new</span> Bunny (<span class="hljs-string">&quot;Bo&quot;</span>) &#123; LikesCarrots=<span class="hljs-literal">true</span>, LikesHumans=<span class="hljs-literal">false</span> &#125;;<br><br><span class="hljs-comment">//The code to construct b1 and b2 is precisely equivalent to the following:</span><br><span class="hljs-comment">//The temporary variables are to ensure that if an exception is thrown during initiali‐</span><br><span class="hljs-comment">//zation, you can’t end up with a half-initialized object.</span><br>Bunny temp1 = <span class="hljs-keyword">new</span> Bunny(); <span class="hljs-comment">// temp1 is a compiler-generated name</span><br>temp1.Name = <span class="hljs-string">&quot;Bo&quot;</span>;<br>temp1.LikesCarrots = <span class="hljs-literal">true</span>;<br>temp1.LikesHumans = <span class="hljs-literal">false</span>;<br>Bunny b1 = temp1;<br><br>Bunny temp2 = <span class="hljs-keyword">new</span> Bunny (<span class="hljs-string">&quot;Bo&quot;</span>);<br>temp2.LikesCarrots = <span class="hljs-literal">true</span>;<br>temp2.LikesHumans = <span class="hljs-literal">false</span>;<br>Bunny b2 = temp2;<br></code></pre></td></tr></table></figure><p><strong>为什么使用 Object Initializer 而不使用构造函数</strong></p><blockquote><ul><li>通常来讲使用构造函数更好，这样可以防止构建的object存在invalid state的情况 (如在多线程的情况下)</li><li>但是有一些成员变量的初始化不是必要的, 而是optional的. 这是就需要将构造函数overload来满足不同的初始化需求. 而大量的构造函数重载降低了代码可读性并且增加了代码的复杂度. 这时候就可以使用Object Initializer.</li><li>可以用在创建Anonymous object: <code>var v = new &#123; Amount = 108, Message = &quot;Hello&quot; &#125;;</code> 并且用在LINQ中, 如下</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> productInfos =<br>    <span class="hljs-keyword">from</span> p <span class="hljs-keyword">in</span> products<br>    <span class="hljs-keyword">select</span> <span class="hljs-keyword">new</span> &#123; p.ProductName, p.UnitPrice &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">MyObject myObjectInstance = <span class="hljs-keyword">new</span> MyObject(param1, param2)<br>&#123;<br>    MyProperty = someUsefulValue<br>&#125;;<br><br><span class="hljs-comment">//This will behave about the same as if you do this:</span><br><br>MyObject myObjectInstance = <span class="hljs-keyword">new</span> MyObject(param1, param2);<br>myObjectInstance.MyProperty = someUsefulValue;<br></code></pre></td></tr></table></figure><h1 id="Fields-and-Property"><a href="#Fields-and-Property" class="headerlink" title="Fields and Property"></a>Fields and Property</h1><p><strong>Fields</strong></p><blockquote><ul><li>一个类或者struct的成员变量被称为 field</li><li>一个filed可以被readonly关键字修饰, readonly可以保证在变量在被创建完成后不会被修改.<blockquote><ul><li>readonly变量只能在声明或者构造函数里被赋值</li><li>注意如果用readonly修饰一个collection, readonly只能保证collection的reference不会被修改, 但是collection里面的内容还是可以被修改的,  推荐使用Immutable library</li></ul></blockquote></li><li>filed可以不用被初始化, 未被初始化的field有default value (0, ‘\0’, null, false)<blockquote><ul><li>field的初始化在构造函数之前执行</li></ul></blockquote></li></ul></blockquote><p><strong>Property</strong></p><blockquote><ul><li>Property 提供对一个private fields的读写操作. (也就是集成了setter 和 getter)</li><li>一个Property包括set 和 get<blockquote><ul><li>get会返回对应private field的值</li><li>set可以对传入的数值进行一些validation或者转换, 然后将值赋给对应的private field</li></ul></blockquote></li></ul></blockquote><p>Example：</p><blockquote><ul><li>In this example, the TimePeriod class represents an interval of time. </li><li>Internally, the class stores the time interval in seconds in a private field named <code>_seconds.</code>  and  a read-write property named <code>Hours</code> allows the customer to specify the time interval in hours. </li><li>Both the get and the set accessors perform the necessary conversion between hours and seconds. </li><li>In addition, the set accessor validates the data and throws an ArgumentOutOfRangeException if the number of hours is invalid.</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TimePeriod</span><br>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">double</span> _seconds;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">double</span> Hours<br>    &#123;<br>        <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> _seconds / <span class="hljs-number">3600</span>; &#125;<br>        <span class="hljs-keyword">set</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">value</span> &gt; <span class="hljs-number">24</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArgumentOutOfRangeException(<span class="hljs-keyword">nameof</span>(<span class="hljs-keyword">value</span>),<br>                      <span class="hljs-string">&quot;The valid range is between 0 and 24.&quot;</span>);<br><br>            _seconds = <span class="hljs-keyword">value</span> * <span class="hljs-number">3600</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br>TimePeriod t = <span class="hljs-keyword">new</span> TimePeriod();<br><span class="hljs-comment">// The property assignment causes the &#x27;set&#x27; accessor to be called.</span><br>t.Hours = <span class="hljs-number">24</span>;<br><br><span class="hljs-comment">// Retrieving the property causes the &#x27;get&#x27; accessor to be called.</span><br>Console.WriteLine(<span class="hljs-string">$&quot;Time in hours: <span class="hljs-subst">&#123;t.Hours&#125;</span>&quot;</span>);<br><span class="hljs-comment">// The example displays the following output:</span><br><span class="hljs-comment">//    Time in hours: 24</span><br></code></pre></td></tr></table></figure><p><strong>Expression body definitions</strong></p><blockquote><ul><li>使用expression定义setter和getter</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SaleItem</span><br>&#123;<br>    <span class="hljs-built_in">string</span> _name;<br>    <span class="hljs-built_in">decimal</span> _cost;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SaleItem</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> name, <span class="hljs-built_in">decimal</span> cost</span>)</span><br>    &#123;<br>        _name = name;<br>        _cost = cost;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123;<br>        <span class="hljs-keyword">get</span> =&gt; _name;<br>        <span class="hljs-keyword">set</span> =&gt; _name = <span class="hljs-keyword">value</span>; <span class="hljs-comment">//value不是自定义的 代表输入的值</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Price<br>    &#123;<br>        <span class="hljs-keyword">get</span> =&gt; _cost;<br>        <span class="hljs-keyword">set</span> =&gt; _cost = <span class="hljs-keyword">value</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SettingValue</span> : <span class="hljs-title">DatabaseDocument</span><br>&#123;<br><span class="hljs-keyword">public</span> Id Identifier &#123; <span class="hljs-keyword">get</span>: <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-keyword">public</span> scope scope &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><br>[<span class="hljs-meta">BsonIgnore</span>]<br><span class="hljs-keyword">public</span> JsonElement JsonValue<br>&#123;<br><span class="hljs-keyword">get</span> =&gt; BsonValue .ToJsonElement(); <span class="hljs-comment">//通过BsonValue拿到</span><br><span class="hljs-keyword">init</span> =&gt; BsonValue = <span class="hljs-keyword">value</span> .ToBsonValue(); <span class="hljs-comment">//设置BasonValue</span><br>&#125;<br><br>[<span class="hljs-meta">BsonELement(<span class="hljs-string">&quot;Value&quot;</span>)</span>] <br><span class="hljs-keyword">public</span> BsonValue BsonValue f <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>: &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Auto-implemented properties</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//编译器可以自动生成对应的field</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SaleItem</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name<br>    &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> Price<br>    &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Property initializers</strong></p><blockquote><ul><li>可以用 property initializer 对 auto properties 进行初始化</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-built_in">decimal</span> CurrentPrice &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125; = <span class="hljs-number">123</span>;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//初始化List</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ConfiqurationModel</span> <br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Code &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125;<br><span class="hljs-keyword">public</span> IReadOnlylist&lt;SectionDefinitionModel&gt; Sections  &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125; = Array.Empty&lt;SectionDefinitionmiodel&gt;()<br><span class="hljs-keyword">public</span> IReadonlylist&lt;SettingDefinitionModel&gt; Settings &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">init</span>; &#125; = Array.Empty&lt;SettingDefinitionMlodel&gt;():<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>readonly property</strong></p><blockquote><ul><li><code>public int Maximum &#123; get; &#125; = 999;</code> 没有set 表示这是readonly property</li><li><code>public Id Identifier &#123; get: init; &#125;</code> init表示只能在初始化的时候赋值, 其他情况只能读取</li><li>下面代码是通过构造函数初始化值, 初始化之后就只能读取数据</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SettingDefinitionModelWithcontext</span>(<span class="hljs-params">SettingDefinitionodel setting, <span class="hljs-built_in">string</span> <span class="hljs-keyword">namespace</span>, <span class="hljs-built_in">string</span> sectionCode</span>) : <span class="hljs-title">base</span>(<span class="hljs-params">setting</span>)</span><br>&#123;<br>Namespace = @namespace;<br>SectionCode = sectionCode:<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Namespace &#123; <span class="hljs-keyword">get</span>; &#125;<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> SectionCode &#123; <span class="hljs-keyword">get</span>;&#125;<br></code></pre></td></tr></table></figure><h1 id="如何设置常量"><a href="#如何设置常量" class="headerlink" title="如何设置常量"></a>如何设置常量</h1><p><strong>constant</strong></p><blockquote><ul><li>用constant修饰的变量, 编译器会在编译时静态的求值. 也就是直接将变量替换成值. constant可以是bool, char, string, 任何内置的数值类型或者枚举类型</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Circumference</span> (<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * System.Math.PI * radius;<br>&#125;<br><br><span class="hljs-comment">//会被编译成</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">double</span> <span class="hljs-title">Circumference</span> (<span class="hljs-params"><span class="hljs-built_in">double</span> radius</span>)</span><br>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-number">6.2831853071795862</span> * radius;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>static readonly</strong></p><blockquote><ul><li>static readonly也可以用来设置常量, 但是不同的是, static readonly变量不会在编译的时候被替换, 所以遇到每次运行都需要新的值的情况，需要用static readonly修饰</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> DateTime StartupTime = DateTime.Now;<br></code></pre></td></tr></table></figure><blockquote><ul><li>另外一个区别是，<code>public const decimal ProgramVersion = 2.3;</code> 如果assembly Y引用了assembly X的常量. 当Y编译时, 会储存常量2.3. 但是如果X重新编译将值改为2.4.  则Y不会更新这个值，直到Y重新编译. 而static readonly会避免这个错误<blockquote><ul><li>其实就是const只有在重新编译的时候才会更新，但是static readonly会在运行时更新</li></ul></blockquote></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 语法糖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- 类型安全 与 var关键字</title>
    <link href="/2024/04/26/C#%20---%20%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%20%E4%B8%8E%20var%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2024/04/26/C#%20---%20%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%20%E4%B8%8E%20var%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是类型安全"><a href="#什么是类型安全" class="headerlink" title="什么是类型安全"></a>什么是类型安全</h1><blockquote><ul><li>类型安全就是编译器在编译阶段会检查变量内容和变量类型是否匹配, 如果不匹配会抛出错误</li><li>类型安全的语言包括Java, C++, C#等</li><li>类型不安全的语言有JavaScript</li></ul></blockquote><blockquote><ul><li>下面这段代码是JavaScript, 编译器不会进行类型检查, 不会进行任何报错或者标红提示, 所以string和int可以相加</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> priceOfApple = <span class="hljs-number">5</span>;<br>priceOfApple = <span class="hljs-string">&quot;is type safe&quot;</span>;<br><span class="hljs-keyword">var</span> priceOfOrange = <span class="hljs-number">7</span>;<br><span class="hljs-keyword">var</span> totalPrice = priceOfApple + priceOfOrange;<br></code></pre></td></tr></table></figure><p><strong>强类型语言和弱类型语言 (strongly typed vs weakly typed)</strong></p><blockquote><ul><li>概念和类型安全类似, 强类型语言会要求所有的变量都要有相对应的类型, 并且会在编译阶段进行类型检查.而弱类型语言则不要求所有变量都有相对于的类型, 也不会对类型进行检查</li></ul></blockquote><p><strong>静态类型检查和动态类型检查 (static typing vs dynamic typing)</strong><br><del>删除线格式</del> <img src="/2024/04/26/C#%20---%20%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8%20%E4%B8%8E%20var%E5%85%B3%E9%94%AE%E5%AD%97/1.png"></p><h1 id="var关键字"><a href="#var关键字" class="headerlink" title="var关键字"></a>var关键字</h1><blockquote><ul><li>局部变量可以在不给出显式类型的情况下声明。var 关键字告诉编译器从初始化语句右侧的表达式中推断变量的类型。推断的类型可以是内置类型、匿名类型、用户定义的类型或 .NET 类库中定义的类型</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// i is compiled as an int</span><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// s is compiled as a string</span><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-comment">// a is compiled as int[]</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span>[] &#123; <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span> &#125;;<br><br><span class="hljs-comment">// expr is compiled as IEnumerable&lt;Customer&gt;</span><br><span class="hljs-comment">// or perhaps IQueryable&lt;Customer&gt;</span><br><span class="hljs-keyword">var</span> expr =<br>    <span class="hljs-keyword">from</span> c <span class="hljs-keyword">in</span> customers<br>    <span class="hljs-keyword">where</span> c.City == <span class="hljs-string">&quot;London&quot;</span><br>    <span class="hljs-keyword">select</span> c;<br><br><span class="hljs-comment">// anon is compiled as an anonymous type</span><br><span class="hljs-keyword">var</span> anon = <span class="hljs-keyword">new</span> &#123; Name = <span class="hljs-string">&quot;Terry&quot;</span>, Age = <span class="hljs-number">34</span> &#125;;<br><br><span class="hljs-comment">// list is compiled as List&lt;int&gt;</span><br><span class="hljs-keyword">var</span> list = <span class="hljs-keyword">new</span> List&lt;<span class="hljs-built_in">int</span>&gt;();<br></code></pre></td></tr></table></figure><blockquote><ul><li>注意即使有var keyword, c#依旧是强类型语言, 因为编译器还是会通过初始化语句右侧的表达式中推断变量的类型, 并且var 只适用于local variable. 方法的成员变量和方法返回值等都必须有显式的类型.</li></ul></blockquote><p><strong>什么时候使用var关键字</strong></p><blockquote><ul><li>var的优点<blockquote><ul><li>var 要求输入更少的字符。相比于 Dictionary&lt;int, IList&gt;，var 更短、更易读。</li><li>如果方法调用的返回类型发生变化，var 需要更少的代码更改。你只需要更改方法声明，而不是每个使用它的地方。</li><li>var 鼓励你为变量使用描述性的名称。这意味着使用实例名称，而不是类型名称。例如：var customer &#x3D; new Customer() 而不是 var c &#x3D; new Customer()</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>var的缺点<blockquote><ul><li>var 隐藏了实际的变量类型。如果初始化器没有返回一个明确定义的类型，那么你可能无法知道变量的类型。</li><li>使用 var 是懒惰的。虽然 var 比 Dictionary&lt;int, IList&gt; 要容易输入，但如果变量没有命名好，你就无法知道它指的是什么。</li><li>使用 var 使得很难知道底层变量的实际类型。同样，一个命名合理的变量会自说明。</li><li>var 无法包含可空类型，例如 int?。这实际上是不正确的，因为你可以将值转换为可空类型。</li></ul></blockquote></li></ul></blockquote><p>建议: 当能看出变量类型的时候用var, 看不出类型的时候用实际类型声明</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> count = <span class="hljs-number">17</span>;<br><span class="hljs-keyword">var</span> primeNumbers = <span class="hljs-keyword">new</span> [] &#123; <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">17</span> &#125;;<br><span class="hljs-keyword">var</span> customer = <span class="hljs-keyword">new</span> Customer();<br><span class="hljs-keyword">var</span> activeOrders = GetAllOrders().Where(o =&gt; o.Active);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> activeOrder <span class="hljs-keyword">in</span> activeOrders) &#123; … &#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">decimal</span> customerBalance = GetCustomerBalance();<br>CustomerStatus customerStatus = GetCustomerStatus();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 语法糖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- Lambda Expression</title>
    <link href="/2024/04/26/C#%20---%20Lambda%20Expression/"/>
    <url>/2024/04/26/C#%20---%20Lambda%20Expression/</url>
    
    <content type="html"><![CDATA[<h1 id="Intro-to-Lambda-Expression"><a href="#Intro-to-Lambda-Expression" class="headerlink" title="Intro to Lambda Expression"></a>Intro to Lambda Expression</h1><blockquote><ul><li>在编程中, lambda表达式是实现匿名函数的一种方法</li><li>lambada表达式可以增强代码的可读性. 当需要定义一些短小内容简单的函数的时候, 专门给这些方法起一个名字就显得麻烦且不必要, 这时就可以用lambda表达式替代</li><li>lambda表达式分为两种: expression lambda 和 statement lambda</li></ul></blockquote><p><strong>expression Lambda</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//(parameters) =&gt; expression</span><br><span class="hljs-comment">//expression lambda 直接返回 expression的结果</span><br><span class="hljs-comment">//Example:</span><br>(<span class="hljs-built_in">int</span> num) =&gt; num * <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p><strong>statement lambda</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//(parameters) =&gt; &#123; statements; &#125;</span><br><span class="hljs-comment">//statement lambda 需要显式的写出return value. 否则没有返回值</span><br><span class="hljs-comment">//Example</span><br>(<span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b) =&gt;<br>&#123;<br>    <span class="hljs-keyword">var</span> sum = a + b;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="lambda表达式的参数"><a href="#lambda表达式的参数" class="headerlink" title="lambda表达式的参数"></a>lambda表达式的参数</h1><blockquote><ul><li>如果没有参数, 则括号里为空: <code>Action line = () =&gt; Console.WriteLine();</code></li><li>如果只有一个参数, 则可以不加括号: <code>Func&lt;double, double&gt; cube = x =&gt; x * x * x;</code></li><li>多个参数用逗号隔开: <code>Func&lt;int, int, bool&gt; testForEquality = (x, y) =&gt; x == y;</code> (Func最后一个参数 bool为返回值)</li></ul></blockquote><p><strong>lambda表达式参数的自动推断</strong></p><blockquote><ul><li>在编写Lambda表达式时，通常不必为输入参数指定类型，因为编译器可以根据Lambda的主体、参数类型和其他因素推断类型</li><li>比如 如果你正在查询一个<code>IEnumerable&lt;Customer&gt;</code>，那么输入变量将被推断为Customer对象，这意味着你可以访问它的方法和属性 <code>customers.Where(c =&gt; c.City == &quot;London&quot;);</code></li><li>Lambda表达式的类型推断一般遵循以下规则：<blockquote><ul><li>Lambda表达式中的参数数量必须与委托类型相同。</li><li>Lambda表达式中的每个输入参数必须可以隐式转换为对应的委托参数。</li><li>Lambda表达式的返回值（如果有）必须可以隐式转换为委托的返回类型。</li></ul></blockquote></li></ul></blockquote><h1 id="lambda表达式的返回值"><a href="#lambda表达式的返回值" class="headerlink" title="lambda表达式的返回值"></a>lambda表达式的返回值</h1><blockquote><ul><li>expression lambda 直接返回 expression的结果</li><li>statement lambda 需要显式的写出return value. 否则没有返回值</li><li>通常情况下，Lambda表达式的返回类型是明显且可推断的。然而，对于某些表达式，这种推断可能不起作用</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> choose = (<span class="hljs-built_in">bool</span> b) =&gt; b ? <span class="hljs-number">1</span> : <span class="hljs-string">&quot;two&quot;</span>; <span class="hljs-comment">// ERROR: Can&#x27;t infer return type</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>从C# 10开始，你可以在输入参数之前指定Lambda表达式的返回类型。当你指定显式的返回类型时，你必须在输入参数周围加上括号</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> choose = <span class="hljs-built_in">object</span> (<span class="hljs-built_in">bool</span> b) =&gt; b ? <span class="hljs-number">1</span> : <span class="hljs-string">&quot;two&quot;</span>; <span class="hljs-comment">// Func&lt;bool, object&gt;</span><br></code></pre></td></tr></table></figure><h1 id="如何使用lambda-Expression"><a href="#如何使用lambda-Expression" class="headerlink" title="如何使用lambda Expression"></a>如何使用lambda Expression</h1><blockquote><ul><li>lambda表达式一般和委托结合使用, 也就是用<strong>lambda定义委托</strong>或者将lambda表达式直接作为方法传参</li></ul></blockquote><p><strong>Example 1: Action委托</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Action&lt;<span class="hljs-built_in">string</span>&gt; greet = name =&gt;<br>&#123;<br>    <span class="hljs-built_in">string</span> greeting = <span class="hljs-string">$&quot;Hello <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span>;<br>    Console.WriteLine(greeting);<br>&#125;;<br>greet(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// Hello World!</span><br></code></pre></td></tr></table></figure><p><strong>Example 2: Func委托</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp">Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; square = x =&gt; x * x;<br>Console.WriteLine(square(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 25</span><br><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>&gt; testForEquality = (x, y) =&gt; x == y;<br>Console.WriteLine(testForEquality(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>));<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// False</span><br><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">bool</span>&gt; isTooLong = (x, s) =&gt; s.Length &gt; x;<br>Console.WriteLine(testForEquality(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;hello&quot;</span>));<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// True</span><br></code></pre></td></tr></table></figure><p><strong>Example 3: Natural type of a lambda expression</strong></p><blockquote><ul><li>从C# 10开始, lambda expression不需要必须定义成一种委托类型, 比如<code>Func</code> 或者 <code>Action</code>.<br>而是可以定义成var类型, 然后由编译器自己推断类型.</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//会自动转换成 Func&lt;string, int&gt; 类型</span><br><span class="hljs-keyword">var</span> parse = (<span class="hljs-built_in">string</span> s) =&gt; <span class="hljs-built_in">int</span>.Parse(s);<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//会自动转换成 Func&lt;int, int, int&gt; 类型</span><br><span class="hljs-keyword">var</span> IncrementBy = (<span class="hljs-built_in">int</span> source, <span class="hljs-built_in">int</span> increment = <span class="hljs-number">1</span>) =&gt; source + increment;<br>Console.WriteLine(IncrementBy(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 6</span><br>Console.WriteLine(IncrementBy(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 7</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//但是必须要有足够的信息才能自动转换</span><br><span class="hljs-keyword">var</span> parse = s =&gt; <span class="hljs-built_in">int</span>.Parse(s); <span class="hljs-comment">// ERROR: Not enough type info in the lambda</span><br></code></pre></td></tr></table></figure><p><strong>Example 4 : 使用lambda作为委托传参  — LINQ</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System;<br><span class="hljs-keyword">using</span> System.Collections.Generic;<br><span class="hljs-keyword">using</span> System.Linq;<br><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> Age &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title">demo</span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>()</span><br>    &#123;<br>        List&lt;Dog&gt; dogs = <span class="hljs-keyword">new</span> List&lt;Dog&gt;() &#123;<br>            <span class="hljs-keyword">new</span> Dog &#123; Name = <span class="hljs-string">&quot;Rex&quot;</span>, Age = <span class="hljs-number">4</span> &#125;,<br>            <span class="hljs-keyword">new</span> Dog &#123; Name = <span class="hljs-string">&quot;Sean&quot;</span>, Age = <span class="hljs-number">0</span> &#125;,<br>            <span class="hljs-keyword">new</span> Dog &#123; Name = <span class="hljs-string">&quot;Stacy&quot;</span>, Age = <span class="hljs-number">3</span> &#125;<br>         &#125;;<br>         <span class="hljs-keyword">var</span> names = dogs.Select(x =&gt; x.Name);<br>         <span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> names)<br>         &#123;<br>             Console.WriteLine(name);<br><br>         &#125;<br>         Console.Read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">var</span> sortedDogs = dogs.OrderByDescending(x =&gt; x.Age);<br><span class="hljs-keyword">foreach</span> (<span class="hljs-keyword">var</span> dog <span class="hljs-keyword">in</span> sortedDogs)<br>&#123;<br>   Console.WriteLine(<span class="hljs-built_in">string</span>.Format(<span class="hljs-string">&quot;Dog &#123;0&#125; is &#123;1&#125; years old.&quot;</span>, dog.Name, dog.Age));<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 语法糖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- 委托机制 delegate 和 回调 callback</title>
    <link href="/2024/04/26/C#%20---%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%20delegate%20%E5%92%8C%20%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95%20callback/"/>
    <url>/2024/04/26/C#%20---%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%20delegate%20%E5%92%8C%20%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95%20callback/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是委托机制"><a href="#什么是委托机制" class="headerlink" title="什么是委托机制"></a>什么是委托机制</h1><blockquote><ul><li>委托机制相当于C语言中的函数指针, 将一个方法的reference传入另外一个方法中</li></ul></blockquote><p><strong>Example</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//创建一个方法 </span><br><span class="hljs-comment">//创建一个委托</span><br><span class="hljs-comment">//这个委托的返回值是void并且有一个参数是string. 也就是这个委托可以指向任何 **返回值为void参数为string的方法**</span><br><span class="hljs-comment">//使用这个委托, 将要指向的方法名传入委托的constructor</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> msg</span>)</span><br>&#123;<br>Console.WriteLine(msg)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintMsgFunctionDelgate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> Message</span>)</span>;<br>PrintMsgFunctionDelegate print = <span class="hljs-keyword">new</span> PrintMsgFunctionDelegate(PrintMessage)<br>print(<span class="hljs-string">&quot;welcome&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>Unicast deligate</strong></p><blockquote><ul><li>This delegate refers to only one method, as shown in the above examples.</li></ul></blockquote><p><strong>Multicast deligate</strong></p><blockquote><ul><li>This delegate can refer to more than one method. This delegate maintains a list of the methods.</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//Example 1</span><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strDele</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> str</span>)</span>; <span class="hljs-comment">//declare  </span><br>strDele delobj += <span class="hljs-keyword">new</span> strDele (uppercasestr); <span class="hljs-comment">//method reference 1  </span><br>delobj += <span class="hljs-keyword">new</span> strDele (Lowercasestr); <span class="hljs-comment">//method reference 2   </span><br>delobj(“Welcome”); <span class="hljs-comment">//invoking the multicast delegate </span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//Example 2</span><br><span class="hljs-keyword">using</span> System;<br><br><span class="hljs-function"><span class="hljs-built_in">delegate</span> <span class="hljs-built_in">int</span> <span class="hljs-title">NumberChanger</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> n</span>)</span>;<br><span class="hljs-keyword">namespace</span> <span class="hljs-title">DelegateAppl</span><br>&#123;<br>   <span class="hljs-keyword">class</span> <span class="hljs-title">TestDelegate</span><br>   &#123;<br>      <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> num = <span class="hljs-number">10</span>;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">AddNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> p</span>)</span><br>      &#123;<br>         num += p;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">MultNum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> q</span>)</span><br>      &#123;<br>         num *= q;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br>      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getNum</span>()</span><br>      &#123;<br>         <span class="hljs-keyword">return</span> num;<br>      &#125;<br><br>      <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>      &#123;<br>         <span class="hljs-comment">// 创建委托实例</span><br>         NumberChanger nc;<br>         NumberChanger nc1 = <span class="hljs-keyword">new</span> NumberChanger(AddNum);<br>         NumberChanger nc2 = <span class="hljs-keyword">new</span> NumberChanger(MultNum);<br>         nc = nc1;<br>         nc += nc2;<br>         <span class="hljs-comment">// 调用多播</span><br>         nc(<span class="hljs-number">5</span>);<br>         Console.WriteLine(<span class="hljs-string">&quot;Value of Num: &#123;0&#125;&quot;</span>, getNum());<br>         Console.ReadKey();<br>      &#125;<br>   &#125;<br>&#125;<br>Output:<br>Value of Num: <span class="hljs-number">75</span><br></code></pre></td></tr></table></figure><h1 id="委托机制的优点"><a href="#委托机制的优点" class="headerlink" title="委托机制的优点"></a>委托机制的优点</h1><blockquote><ul><li>使用委托可以达到解耦, 如下, 创建一个方法, 用来显示可以升职的员工</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span>  <br>&#123;  <br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> ID &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">string</span> Name &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> salary &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">float</span> Experiance &#123; <span class="hljs-keyword">get</span>; <span class="hljs-keyword">set</span>; &#125;  <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PromoteEmp</span>(<span class="hljs-params">List&lt;Employee&gt; EmployeeList</span>)</span>  <br>    &#123;  <br>        <span class="hljs-keyword">foreach</span> (Employee  emp <span class="hljs-keyword">in</span> EmployeeList )  <br>        &#123;  <br>            <span class="hljs-keyword">if</span>(emp.Experiance&gt;=<span class="hljs-number">5</span>)<span class="hljs-comment">//logic condition  </span><br>            &#123;  <br>                Console.WriteLine(emp.Name + <span class="hljs-string">&quot; promoted&quot;</span>);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><blockquote><ul><li>目前的筛选机制是工作经验大于五年的可以升职, 但是如果需要改变计算规则, 比如变成工资大于10000的可以升职, 就需要改动代码. 而使用委托就可以达到解耦</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs clike">//将计算规则封装成不同的方法<br>Public static bool promoteByYOE(Employee emp)  <br>&#123;  <br>     if (emp.Experiance &gt;= 5)  <br>     &#123;  <br>         return true;  <br>     &#125;  <br>     else  <br>     &#123;  <br>         return false;  <br>     &#125;  <br>&#125;  <br><br>Public static bool promoteBySalary(Employee emp)  <br>&#123;  <br>     if (emp.Salary &gt;= 10000)  <br>     &#123;  <br>         return true;  <br>     &#125;  <br>     else  <br>     &#123;  <br>         return false;  <br>     &#125;  <br>&#125;  <br><br>//将计算规则用委托代表, 命名为IsEligible<br>public static void PromoteEmp(List&lt;Employee&gt; EmployeeList,isPromote IsEligible)  <br>&#123;  <br>     foreach (Employee  emp in EmployeeList )  <br>     &#123;  <br>         if(IsEligible(emp))//logic condition  <br>         &#123;  <br>             Console.WriteLine(emp.Name + &quot; Promoted&quot;);  <br>         &#125;  <br>     &#125;  <br>&#125;<br><br>//创建一个委托, 返回类型为bool, 参数为Employee<br>delegate bool isPromote(Employee emp); <br>//让委托指向不同的方法<br>IsPromote proByEOY = new isPromote(promoteByYOE)<br>IsPromote proBySalary = new isPromote(promoteBySalary)<br><br>Employee.PromoteEmp(empl, proByEOY);<br>Employee.PromoteEmp(empl, proBySalary);<br></code></pre></td></tr></table></figure><h1 id="C-中的Action-和-Func"><a href="#C-中的Action-和-Func" class="headerlink" title="C# 中的Action 和 Func"></a>C# 中的Action 和 Func</h1><p><strong>Action</strong></p><blockquote><ul><li>对于正常的委托, 每次都要定义, 比较麻烦, 而使用Action可以省去定义委托的过程</li><li>使用格式为<br><code>Action&lt;parameter type1, parameter type2 ... &gt; delegate_name  = new Action &lt;parameter type1, parameter type2 ... &gt;(method name)</code></li><li><strong>Action只适用于没有返回值的方法</strong></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintMessage</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> msg</span>)</span><br>&#123;<br>Console.WriteLine(msg)<br>&#125;<br><span class="hljs-comment">//正常定义委托</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">PrintMsgFunctionDelgate</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> Message</span>)</span>;<br>PrintMsgFunctionDelegate print = <span class="hljs-keyword">new</span> PrintMsgFunctionDelegate(PrintMessage)<br>print(<span class="hljs-string">&quot;welcome&quot;</span>)<br><br><span class="hljs-comment">//使用Action定义委托, 可以使用new关键字 或者直接赋值</span><br><span class="hljs-function">Action&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">print</span>()</span> = <span class="hljs-keyword">new</span> Action&lt;<span class="hljs-built_in">string</span>&gt;(PrintMessage);<br><span class="hljs-function">Action&lt;<span class="hljs-built_in">string</span>&gt; <span class="hljs-title">print</span>()</span> = PrintMessage;<br>print(<span class="hljs-string">&quot;welcome&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//使用Action + 匿名方法</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>    Action&lt;<span class="hljs-built_in">int</span>&gt; printActionDel = <span class="hljs-built_in">delegate</span>(<span class="hljs-built_in">int</span> i)<br>                                &#123;<br>                                    Console.WriteLine(i);<br>                                &#125;;<br><br>    printActionDel(<span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-comment">//使用Lambda + Action</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br><br>    Action&lt;<span class="hljs-built_in">int</span>&gt; printActionDel = i =&gt; Console.WriteLine(i);<br>       <br>    printActionDel(<span class="hljs-number">10</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Func</strong></p><blockquote><ul><li>Func适用于有返回值的方法, signature如下<br><img src="/2024/04/26/C#%20---%E5%A7%94%E6%89%98%E6%9C%BA%E5%88%B6%20delegate%20%E5%92%8C%20%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95%20callback/1.png"></li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">namespace</span> <span class="hljs-title">System</span><br>&#123;  <br>    <span class="hljs-comment">//第一个参数是input, 最后一个是返回值类型</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> TResult <span class="hljs-title">Func</span>&lt;<span class="hljs-keyword">in</span> <span class="hljs-title">T</span>, <span class="hljs-keyword">out</span> <span class="hljs-title">TResult</span>&gt;(<span class="hljs-params">T arg</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>The following Func delegate takes two input parameters of int type and returns a value of int type: <code>Func&lt;int, int, int&gt; sum;</code></li></ul></blockquote><blockquote><ul><li>Func with Zero Input Parameter: <code>Func&lt;int&gt; getRandomNumber;</code></li></ul></blockquote><p>Example: </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">Sum</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        Func&lt;<span class="hljs-built_in">int</span>,<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; <span class="hljs-keyword">add</span> = Sum;<br><br>        <span class="hljs-built_in">int</span> result = <span class="hljs-keyword">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br><br>        Console.WriteLine(result); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//Func with an Anonymous Method</span><br>Func&lt;<span class="hljs-built_in">int</span>&gt; getRandomNumber = <span class="hljs-built_in">delegate</span>()<br>                            &#123;<br>                                Random rnd = <span class="hljs-keyword">new</span> Random();<br>                                <span class="hljs-keyword">return</span> rnd.Next(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br>                            &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//Example: Func with lambda expression</span><br>Func&lt;<span class="hljs-built_in">int</span>&gt; getRandomNumber = () =&gt; <span class="hljs-keyword">new</span> Random().Next(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br><br><span class="hljs-comment">//Or </span><br><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt;  Sum  = (x, y) =&gt; x + y;<br></code></pre></td></tr></table></figure><p><strong>使用lambda表达式定义Func和Action委托</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//Example 1: Action委托</span><br>Action&lt;<span class="hljs-built_in">string</span>&gt; greet = name =&gt;<br>&#123;<br>    <span class="hljs-built_in">string</span> greeting = <span class="hljs-string">$&quot;Hello <span class="hljs-subst">&#123;name&#125;</span>!&quot;</span>;<br>    Console.WriteLine(greeting);<br>&#125;;<br>greet(<span class="hljs-string">&quot;World&quot;</span>);<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// Hello World!</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//Example 2: Func委托</span><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>&gt; square = x =&gt; x * x;<br>Console.WriteLine(square(<span class="hljs-number">5</span>));<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// 25</span><br><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">int</span>, <span class="hljs-built_in">bool</span>&gt; testForEquality = (x, y) =&gt; x == y;<br>Console.WriteLine(testForEquality(<span class="hljs-number">5</span>, <span class="hljs-number">7</span>));<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// False</span><br><br>Func&lt;<span class="hljs-built_in">int</span>, <span class="hljs-built_in">string</span>, <span class="hljs-built_in">bool</span>&gt; isTooLong = (x, s) =&gt; s.Length &gt; x;<br>Console.WriteLine(testForEquality(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;hello&quot;</span>));<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// True</span><br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//Example 3: Natural type of a lambda expression</span><br><span class="hljs-comment">//从C# 10开始, lambda expression不需要必须定义成一种委托类型, 比如`Func` 或者 `Action`.</span><br><span class="hljs-comment">//而是可以定义成var类型, 然后由编译器自己推断类型.</span><br><span class="hljs-comment">//会自动转换成 Func&lt;string, int&gt; 类型</span><br><span class="hljs-keyword">var</span> parse = (<span class="hljs-built_in">string</span> s) =&gt; <span class="hljs-built_in">int</span>.Parse(s);<br><br><br><span class="hljs-comment">//会自动转换成 Func&lt;int, int, int&gt; 类型</span><br><span class="hljs-keyword">var</span> IncrementBy = (<span class="hljs-built_in">int</span> source, <span class="hljs-built_in">int</span> increment = <span class="hljs-number">1</span>) =&gt; source + increment;<br>Console.WriteLine(IncrementBy(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 6</span><br>Console.WriteLine(IncrementBy(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>)); <span class="hljs-comment">// 7</span><br><br><br><span class="hljs-comment">//但是必须要有足够的信息才能自动转换</span><br><span class="hljs-keyword">var</span> parse = s =&gt; <span class="hljs-built_in">int</span>.Parse(s); <span class="hljs-comment">// ERROR: Not enough type info in the lambda</span><br></code></pre></td></tr></table></figure><h1 id="委托机制的主要用处-—-回调-Callback"><a href="#委托机制的主要用处-—-回调-Callback" class="headerlink" title="委托机制的主要用处 — 回调 Callback"></a>委托机制的主要用处 — 回调 Callback</h1><blockquote><ul><li><strong>回调的定义</strong><blockquote><ul><li>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>为什么需要将函数的指针当参数传进去, 而不是直接调用需要的函数<blockquote><ul><li>“你想让别人的代码执行你的代码，而别人的代码你又不能动”。所以你要用别人的函数通过指针的形式间接调用你的函数，即回调函数”</li><li>也就是调用我写的函数的人, 可以将任何参数和返回值符合要求的函数传进我写的函数, 然后被我写的函数调用, 而不需要改动我的代码</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>回调最常用的地方是event handler, 也就是根据鼠标或者键盘的event执行不同的函数</li></ul></blockquote><blockquote><ul><li>回调有两种实现方式: 通过<strong>委托</strong>或者<strong>接口</strong>实现</li></ul></blockquote><p><strong>通过委托实现</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">TaskCompletedCallBack</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> taskResult</span>)</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">CallBack</span><br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callBackFunc</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> result</span>)</span><br>    &#123;<br>        Console.WriteLine(result);<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">StartNewTask</span>(<span class="hljs-params">TaskCompletedCallBack taskCompletedCallBack</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;I have started new Task.&quot;</span>);<br>        <span class="hljs-keyword">if</span> (taskCompletedCallBack != <span class="hljs-literal">null</span>)<br>            taskCompletedCallBack(<span class="hljs-string">&quot;I have completed Task.&quot;</span>);<br>    &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Test</span>()</span><br>    &#123;<br>        TaskCompletedCallBack callback = callBackFunc;<br>        StartNewTask(callback);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 语法糖</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# --- cancellation token</title>
    <link href="/2024/04/26/C#%20---%20cancellation%20token/"/>
    <url>/2024/04/26/C#%20---%20cancellation%20token/</url>
    
    <content type="html"><![CDATA[<h1 id="如何终止一个Task-—-cancellation-token"><a href="#如何终止一个Task-—-cancellation-token" class="headerlink" title="如何终止一个Task  — cancellation token"></a>如何终止一个Task  — cancellation token</h1><blockquote><ul><li>由于超时, 耗费资源超额等原因, 有时可能需要终止一个长时间运行的Task</li><li>这是就可以用 cancellation token</li><li>注意 CancellationTokenSource 实现了IDsposable接口, 所以使用时必须要调用 <code>Dispose()</code> 方法或者<code>using</code>代码块释放资源</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// initialize cancellation objects</span><br>CancellationTokenSource cancelTokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<br>CancellationToken token = cancelTokenSource.Token;<br><br><span class="hljs-comment">// execute a parallel operation</span><br>Task task = <span class="hljs-keyword">new</span> Task(() =&gt; &#123; some_operations &#125;, token);<br>task.Start();<br><br><span class="hljs-comment">// cancel the operation</span><br>cancelTokenSource.Cancel();<br><br><span class="hljs-comment">// release resources</span><br>cancelTokenSource.Dispose();<br></code></pre></td></tr></table></figure><h1 id="Example-—-Complete-Task-via-return-Operator"><a href="#Example-—-Complete-Task-via-return-Operator" class="headerlink" title="Example — Complete Task via return Operator"></a>Example — Complete Task via return Operator</h1><blockquote><ul><li>使用return退出循环. In this case, the state of the task will be TaskStatus.RunToCompletion.</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>  CancellationTokenSource cancelTokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<br>  CancellationToken token = cancelTokenSource.Token;<br><br>  Task task = <span class="hljs-keyword">new</span> Task(() =&gt;<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (token.IsCancellationRequested)<br>      &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Operation is canceled&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>      &#125;<br>      Console.WriteLine(<span class="hljs-string">$&quot;Count is equal to &#x27;<span class="hljs-subst">&#123;i&#125;</span>&#x27;&quot;</span>);<br>      <span class="hljs-comment">//add some timeout to emulate real-life execution</span><br>      Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;<br>  &#125;, token);<br> <br>  task.Start();<br><br>  <span class="hljs-comment">// add some timeout to emulate real-life execution</span><br>  Thread.Sleep(<span class="hljs-number">100</span>);<br>  <span class="hljs-comment">// cancel the parallel operation</span><br>  cancelTokenSource.Cancel();<br>  <span class="hljs-comment">// wait till the operation is completed</span><br>  task.Wait();<br>  <span class="hljs-comment">// check the operation status</span><br>  Console.WriteLine(<span class="hljs-string">$&quot;Task Status is equal to &#x27;<span class="hljs-subst">&#123; task.Status &#125;</span>&#x27;&quot;</span>);<br>  <span class="hljs-comment">// release resources</span><br>  cancelTokenSource.Dispose();<br>&#125;<br><br>Output:<br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;1&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;2&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;3&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;4&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;5&#x27;</span><br>Operation <span class="hljs-keyword">is</span> canceled<br>Task Status <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;RanToCompletion&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="Example-—-Complete-Task-via-ThrowIfCancellationRequested"><a href="#Example-—-Complete-Task-via-ThrowIfCancellationRequested" class="headerlink" title="Example — Complete Task via ThrowIfCancellationRequested()"></a>Example — Complete Task via ThrowIfCancellationRequested()</h1><blockquote><ul><li>Throw <code>OperationCanceledException</code> exception via <code>ThrowIfCancellationRequested()</code> method call. In this case, the state of the task will be <code>TaskStatus.Canceled.</code></li><li>The exception will be thrown only in case when <code>Wait()</code> or <code>WaitAll()</code> method is called for the task. Otherwise, no exception is thrown, just <code>TaskStatus.Canceled</code> is set.</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>  CancellationTokenSource cancelTokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<br>  CancellationToken token = cancelTokenSource.Token;<br><br>  Task task = <span class="hljs-keyword">new</span> Task(() =&gt;<br>  &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (token.IsCancellationRequested)<br>        token.ThrowIfCancellationRequested();<br>        Console.WriteLine(<span class="hljs-string">$&quot;Count is equal to &#x27;<span class="hljs-subst">&#123;i&#125;</span>&#x27;&quot;</span>);<br>        <span class="hljs-comment">//add some timeout to emulate real-life execution</span><br>        Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;<br>  &#125;, token);<br><br>  <span class="hljs-keyword">try</span><br>  &#123;<br>    task.Start();<br>    <span class="hljs-comment">// add some timeout to emulate real-life execution</span><br>    Thread.Sleep(<span class="hljs-number">100</span>);<br>    <span class="hljs-comment">// cancel the parallel operation</span><br>    cancelTokenSource.Cancel();<br>    <span class="hljs-comment">// wait till the operation is completed</span><br>    task.Wait();<br>  &#125;<br>  <span class="hljs-keyword">catch</span> (AggregateException ae)<br>  &#123;<br>    <span class="hljs-keyword">foreach</span> (Exception e <span class="hljs-keyword">in</span> ae.InnerExceptions)<br>    &#123;<br>      <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">is</span> TaskCanceledException)<br>        Console.WriteLine(<span class="hljs-string">&quot;Operation is canceled&quot;</span>);<br>      <span class="hljs-keyword">else</span><br>        Console.WriteLine(e.Message);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">finally</span><br>  &#123;<br>    <span class="hljs-comment">// release resources</span><br>    cancelTokenSource.Dispose();<br>  &#125;<br><br>  <span class="hljs-comment">// check the operation status</span><br>  Console.WriteLine(<span class="hljs-string">$&quot;Task Status is equal to &#x27;<span class="hljs-subst">&#123; task.Status &#125;</span>&#x27;&quot;</span>);<br>&#125;<br><br>Output:<br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;1&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;2&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;3&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;4&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;5&#x27;</span><br>Operation <span class="hljs-keyword">is</span> canceled<br>Task Status <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;Canceled&#x27;</span><br></code></pre></td></tr></table></figure><h1 id="Example-—-Register-Operation-Cancellation-Handler"><a href="#Example-—-Register-Operation-Cancellation-Handler" class="headerlink" title="Example — Register Operation Cancellation Handler"></a>Example — Register Operation Cancellation Handler</h1><blockquote><ul><li>It registers an Action delegate that will be called when the CancellationToken is cancelled.</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>&#123;<br>  CancellationTokenSource cancelTokenSource = <span class="hljs-keyword">new</span> CancellationTokenSource();<br>  CancellationToken token = cancelTokenSource.Token;<br><br>  Task task = <span class="hljs-keyword">new</span> Task(() =&gt;<br>  &#123;<br>    <span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>;<br>    token.Register(() =&gt; <br>    &#123; <br>      Console.WriteLine(<span class="hljs-string">&quot;Operation is canceled&quot;</span>);<br>      i = <span class="hljs-number">100</span>;<br>      Console.WriteLine(<span class="hljs-string">$&quot;Count is equal to &#x27;<span class="hljs-subst">&#123;i&#125;</span>&#x27;&quot;</span>);<br>    &#125;);<br>    <span class="hljs-keyword">for</span> (; i &lt; <span class="hljs-number">100</span>; i++)<br>    &#123;<br>      Console.WriteLine(<span class="hljs-string">$&quot;Count is equal to &#x27;<span class="hljs-subst">&#123;i&#125;</span>&#x27;&quot;</span>);<br>      <span class="hljs-comment">//add some timeout to emulate real-life execution</span><br>      Thread.Sleep(<span class="hljs-number">10</span>);<br>    &#125;<br>  &#125;, token);<br>  task.Start();<br><br>  <span class="hljs-comment">// add some timeout to emulate real-life execution</span><br>  Thread.Sleep(<span class="hljs-number">100</span>);<br>  <span class="hljs-comment">// cancel the parallel operation</span><br>  cancelTokenSource.Cancel();<br>  <span class="hljs-comment">// wait till the operation is completed</span><br>  task.Wait();<br>  <span class="hljs-comment">// check the operation status</span><br>  Console.WriteLine(<span class="hljs-string">$&quot;Task Status is equal to &#x27;<span class="hljs-subst">&#123; task.Status &#125;</span>&#x27;&quot;</span>);<br>  <span class="hljs-comment">// release resources</span><br>  cancelTokenSource.Dispose();<br>&#125;<br><br>Output:<br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;1&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;2&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;3&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;4&#x27;</span><br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;5&#x27;</span><br>Operation <span class="hljs-keyword">is</span> canceled<br>Count <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;100&#x27;</span><br>Task Status <span class="hljs-keyword">is</span> equal to <span class="hljs-string">&#x27;RanToCompletion&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 并发与异步机制</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C# -- 异步编程 async/await/Task/Wait</title>
    <link href="/2024/04/26/C#%20--%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%20asyncawaitTask/"/>
    <url>/2024/04/26/C#%20--%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%20asyncawaitTask/</url>
    
    <content type="html"><![CDATA[<h1 id="异步机制的使用场景"><a href="#异步机制的使用场景" class="headerlink" title="异步机制的使用场景"></a>异步机制的使用场景</h1><blockquote><ul><li>在代码中遇到耗时任务时 (比如和数据库交互, 发送网络请求, 耗时的计算任务), 我们通常希望代码可以多任务同时进行, 保证不阻塞主线程 (比如我们不希望当进行网络请求时, 软件界面卡死) </li><li>所以 异步机制的核心是为了实现  <strong>执行耗时任务的同时不阻塞主线程(如UI)</strong></li></ul></blockquote><p><strong>异步编程就是一套解决上述问题的机制</strong></p><blockquote><ul><li>在遇到I&#x2F;O bound 任务时, 异步机制是通过底层的DMA机制 完成一些耗时的I&#x2F;O 任务, 如网络请求, 文件读写等, 在这个过程中 线程仅仅负责给硬件传递命令. 但不负责执行任务<blockquote><blockquote><ul><li>所有的程序最终都会由计算机硬件来执行，现代计算机大量的使用了DMA技术, 也就是Direct Memory Access. 网卡，声卡, 显卡也是有DMA 功能的。DMA 就是直接内存访问的意思，也就是说，拥有DMA 功能的硬件在和内存进行数据交换的时候可以不消耗 CPU 资源。只要 CPU 在发起数据传输时发送一个指令，硬件就开始自己和内存交换数据，在传输完成之后硬件会触发一个中断来通知操作完成。这些无须消耗 CPU 时问的操作正是异生操作的硬件基础.依靠底层硬件的DMA机制.</li></ul></blockquote></blockquote></li><li>同时当遇到CPU bound的任务时, 异步机制则采取多线程的方法解决. 也就是创建新的线程在后台执行相应的任务.</li></ul></blockquote><h1 id="TAP-—-Task-based-Asynchronous-Pattern"><a href="#TAP-—-Task-based-Asynchronous-Pattern" class="headerlink" title="TAP — Task-based Asynchronous Pattern"></a>TAP — Task-based Asynchronous Pattern</h1><blockquote><ul><li>C#的异步机制简称为TAP, 也就是核心是基于<code>Task</code> 和 <code>Task&lt;T&gt;</code> objects, 同时通过 <code>async</code> 和 <code>await</code> 关键字完成<blockquote><ul><li>For I&#x2F;O-bound code, you await an operation that returns a <code>Task</code> or <code>Task&lt;T&gt;</code> inside of an <code>async</code> method.</li><li>For CPU-bound code, you await an operation that is started on a background thread with the <code>Task.Run</code> method.</li></ul></blockquote></li></ul></blockquote><h2 id="Example-—-async-await"><a href="#Example-—-async-await" class="headerlink" title="Example — async&#x2F;await"></a>Example — async&#x2F;await</h2><p><strong>await</strong></p><blockquote><ul><li>await 表示从这里开始, 代码必须要等待异步方法完成才可以继续进行, 并将控制权交给上一级方法, 并返回一个Promise  <code>Task&lt;TResult&gt;</code></li></ul></blockquote><p><strong>async</strong></p><blockquote><ul><li>async 表示这个方法内部调用了 async方法并使用了await</li><li>如果一个异步方法没有使用await关键字, 则代码则会同步运行.</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetUrlContentLengthAsync</span>()</span> &#123;<br><span class="hljs-keyword">var</span> client = <span class="hljs-keyword">new</span> HttpClient();<br><br><span class="hljs-comment">// 调用 GetStringAsync 进行网络请求. GetStringAsync 是一个耗时任务, 需要等待请求网站反应</span><br><span class="hljs-comment">// 此时 GetStringAsync 将控制权交给它的 GetUrlContentLengthAsync, 也就是继续往下运行的意思</span><br><span class="hljs-comment">// GetStringAsync 返回 Task&lt;TResult&gt; 并赋值给 getStringTask, TResult在这里是一个string类型. </span><br><span class="hljs-comment">// getStringTask表示这里有个Task,但是还没有完成, 并保证完成后会有一个实际的string值 (一个Promise)</span><br>Task&lt;<span class="hljs-built_in">string</span>&gt; getStringTask = client.GetStringAsync(<span class="hljs-string">&quot;www.google.com&quot;</span>);<br><br>    <span class="hljs-comment">// DoIndenpendentWork 是一个不需要上面的返回值的一个方法, 继续正常运行</span><br>DoIndenpendentWork();<br><br>     <span class="hljs-comment">//此时不需要要 getStringTask的任务已经做完了,必须要等待 getStringTask 拿到string value</span><br><span class="hljs-comment">//如果 getStringTask 还是没有完成, 则 GetUrlContentLengthAsync 会将控制权交给上一级方法.</span><br><span class="hljs-comment">//并同样返回一个 Task&lt;TResult&gt;. 这个返回值保证了这里最终会有一个string value, 也就是一个Promise</span><br><span class="hljs-comment">//当 GetStringAsync 完成时, 代码在这里回调 (getStringTask这个Task里会存进拿到的string value) </span><br><span class="hljs-comment">//继续运行</span><br><span class="hljs-built_in">string</span> contents = <span class="hljs-keyword">await</span> getStringTask;<br><span class="hljs-keyword">return</span> contents.length;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DoIndependentWork</span>()</span> &#123;<br>Console.WriteLine(<span class="hljs-string">&quot;Working...&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="异步方法的返回值"><a href="#异步方法的返回值" class="headerlink" title="异步方法的返回值"></a>异步方法的返回值</h2><blockquote><ul><li>Task, 没有返回值的异步方法必须返回Task</li><li>有返回值的异步方法返回 <code>Task&lt;TResult&gt;</code> 其中TResult为实际返回类型</li><li>Event Handler 返回值可以是void</li><li><code>IAsyncEnumerable&lt;T&gt;</code>, for an async method that returns an async stream</li></ul></blockquote><p><strong>Example: 返回<code>Task</code></strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">DisplayCurrentInfoAsync</span>()</span><br>&#123;<br>    <span class="hljs-keyword">await</span> WaitAndApologizeAsync();<br><br>    Console.WriteLine(<span class="hljs-string">$&quot;Today is <span class="hljs-subst">&#123;DateTime.Now:D&#125;</span>&quot;</span>);<br>    Console.WriteLine(<span class="hljs-string">$&quot;The current time is <span class="hljs-subst">&#123;DateTime.Now.TimeOfDay:t&#125;</span>&quot;</span>);<br>    Console.WriteLine(<span class="hljs-string">&quot;The current temperature is 76 degrees.&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">WaitAndApologizeAsync</span>()</span><br>&#123;<br>    <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">2000</span>);<br><br>    Console.WriteLine(<span class="hljs-string">&quot;Sorry for the delay...\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Example: 返回 <code>Task&lt;Result&gt;</code></strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">ShowTodaysInfoAsync</span>()</span><br>&#123;<br>    <span class="hljs-built_in">string</span> message =<br>        <span class="hljs-string">$&quot;Today is <span class="hljs-subst">&#123;DateTime.Today:D&#125;</span>\n&quot;</span> +<br>        <span class="hljs-string">&quot;Today&#x27;s hours of leisure: &quot;</span> +<br>        <span class="hljs-string">$&quot;<span class="hljs-subst">&#123;<span class="hljs-keyword">await</span> GetLeisureHoursAsync()&#125;</span>&quot;</span>;<br><br>    Console.WriteLine(message);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task&lt;<span class="hljs-built_in">int</span>&gt; <span class="hljs-title">GetLeisureHoursAsync</span>()</span><br>&#123;<br>    DayOfWeek today = <span class="hljs-keyword">await</span> Task.FromResult(DateTime.Now.DayOfWeek);<br><br>    <span class="hljs-built_in">int</span> leisureHours =<br>        today <span class="hljs-keyword">is</span> DayOfWeek.Saturday || today <span class="hljs-keyword">is</span> DayOfWeek.Sunday<br>        ? <span class="hljs-number">16</span> : <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">return</span> leisureHours;<br>&#125;<br><span class="hljs-comment">// Example output:</span><br><span class="hljs-comment">//    Today is Wednesday, May 24, 2017</span><br><span class="hljs-comment">//    Today&#x27;s hours of leisure: 5</span><br></code></pre></td></tr></table></figure><p><strong>Example: 返回void</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">NaiveButton</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">event</span> EventHandler? Clicked;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Click</span>()</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;Somebody has clicked a button. Let&#x27;s raise the event...&quot;</span>);<br>        Clicked?.Invoke(<span class="hljs-keyword">this</span>, EventArgs.Empty);<br>        Console.WriteLine(<span class="hljs-string">&quot;All listeners are notified.&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AsyncVoidExample</span><br>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt; s_tcs = <span class="hljs-keyword">new</span> TaskCompletionSource&lt;<span class="hljs-built_in">bool</span>&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> Task <span class="hljs-title">MultipleEventHandlersAsync</span>()</span><br>    &#123;<br>        Task&lt;<span class="hljs-built_in">bool</span>&gt; secondHandlerFinished = s_tcs.Task;<br><br>        <span class="hljs-keyword">var</span> button = <span class="hljs-keyword">new</span> NaiveButton();<br><br>        button.Clicked += OnButtonClicked1;<br>        button.Clicked += OnButtonClicked2Async;<br>        button.Clicked += OnButtonClicked3;<br><br>        Console.WriteLine(<span class="hljs-string">&quot;Before button.Click() is called...&quot;</span>);<br>        button.Click();<br>        Console.WriteLine(<span class="hljs-string">&quot;After button.Click() is called...&quot;</span>);<br><br>        <span class="hljs-keyword">await</span> secondHandlerFinished;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnButtonClicked1</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;   Handler 1 is starting...&quot;</span>);<br>        Task.Delay(<span class="hljs-number">100</span>).Wait();<br>        Console.WriteLine(<span class="hljs-string">&quot;   Handler 1 is done.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnButtonClicked2Async</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;   Handler 2 is starting...&quot;</span>);<br>        Task.Delay(<span class="hljs-number">100</span>).Wait();<br>        Console.WriteLine(<span class="hljs-string">&quot;   Handler 2 is about to go async...&quot;</span>);<br>        <span class="hljs-keyword">await</span> Task.Delay(<span class="hljs-number">500</span>);<br>        Console.WriteLine(<span class="hljs-string">&quot;   Handler 2 is done.&quot;</span>);<br>        s_tcs.SetResult(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">OnButtonClicked3</span>(<span class="hljs-params"><span class="hljs-built_in">object</span>? sender, EventArgs e</span>)</span><br>    &#123;<br>        Console.WriteLine(<span class="hljs-string">&quot;   Handler 3 is starting...&quot;</span>);<br>        Task.Delay(<span class="hljs-number">100</span>).Wait();<br>        Console.WriteLine(<span class="hljs-string">&quot;   Handler 3 is done.&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Example output:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Before button.Click() is called...</span><br><span class="hljs-comment">// Somebody has clicked a button. Let&#x27;s raise the event...</span><br><span class="hljs-comment">//    Handler 1 is starting...</span><br><span class="hljs-comment">//    Handler 1 is done.</span><br><span class="hljs-comment">//    Handler 2 is starting...</span><br><span class="hljs-comment">//    Handler 2 is about to go async...</span><br><span class="hljs-comment">//    Handler 3 is starting...</span><br><span class="hljs-comment">//    Handler 3 is done.</span><br><span class="hljs-comment">// All listeners are notified.</span><br><span class="hljs-comment">// After button.Click() is called...</span><br><span class="hljs-comment">//    Handler 2 is done.</span><br></code></pre></td></tr></table></figure><h1 id="异步机制和多线程的关系"><a href="#异步机制和多线程的关系" class="headerlink" title="异步机制和多线程的关系"></a>异步机制和多线程的关系</h1><blockquote><ul><li>异步机制的核心是  <strong>执行耗时任务的同时不阻塞主线程(如UI)</strong></li><li>在遇到I&#x2F;O bound 任务时, 异步机制是通过底层的DMA机制 完成一些耗时的I&#x2F;O 任务, 如网络请求, 文件读写等, 在这个过程中 线程仅仅负责给硬件传递命令. 但不负责执行任务</li><li>同时当遇到CPU bound的任务时, 异步机制则采取多线程的方法解决. 也就是创建新的线程在后台执行相应的任务.</li></ul></blockquote><p><strong>I&#x2F;O-bound example: Download data from a web service</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> HttpClient _httpClient = <span class="hljs-keyword">new</span> HttpClient();<br><br>downloadButton.Clicked += <span class="hljs-keyword">async</span> (o, e) =&gt;<br>&#123;<br>    <span class="hljs-comment">// This line will yield control to the UI as the request</span><br>    <span class="hljs-comment">// from the web service is happening.</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// The UI thread is now free to perform other work.</span><br>    <span class="hljs-keyword">var</span> stringData = <span class="hljs-keyword">await</span> _httpClient.GetStringAsync(URL);<br>    DoSomethingWithData(stringData);<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>CPU-bound example: Perform a calculation for a game</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> DamageResult <span class="hljs-title">CalculateDamageDone</span>()</span><br>&#123;<br>    <span class="hljs-comment">// Code omitted:</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// Does an expensive calculation and returns</span><br>    <span class="hljs-comment">// the result of that calculation.</span><br>&#125;<br><br>calculateButton.Clicked += <span class="hljs-keyword">async</span> (o, e) =&gt;<br>&#123;<br>    <span class="hljs-comment">// This line will yield control to the UI while CalculateDamageDone()</span><br>    <span class="hljs-comment">// performs its work. The UI thread is free to perform other work.</span><br>    <span class="hljs-keyword">var</span> damageResult = <span class="hljs-keyword">await</span> Task.Run(() =&gt; CalculateDamageDone());<br>    DisplayDamage(damageResult);<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><ul><li>Java中所有的耗时任务都是通过多线程完成的, 也就是在遇到耗时任务时, Java是使用多线程来完成, 而不是异步机制完成的</li><li>而C# 引入异步机制是因为thread is expensive, 也就是不想用多线程去解决所有的耗时任务问题.</li><li>但是Java团队认为异步机制不能有效的将异步和同步代码相结合 比如all methods in C# doing an await have to be marked as async. 而且异步方法和同步方法在编译阶段是完全不同的, 具体见Oracle工程师的讲座 <a href="https://www.youtube.com/watch?v=r6P0_FDr53Q&t=1231s">https://www.youtube.com/watch?v=r6P0_FDr53Q&amp;t&#x3D;1231s</a></li><li>所以Java团队推出了轻量级线程 aka fibers&#x2F;lightweight threads 降低线程的使用代价, 消除异步机制的使用.</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>C#</category>
      
      <category>C# --- 并发与异步机制</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- 注解 Annotation</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%B3%A8%E8%A7%A3%20Annotation/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%B3%A8%E8%A7%A3%20Annotation/</url>
    
    <content type="html"><![CDATA[<h1 id="Java注解"><a href="#Java注解" class="headerlink" title="Java注解"></a>Java注解</h1><blockquote><ul><li>Java注解它提供了一种安全的类似注释的机制，用来将任何的信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联。</li></ul></blockquote><h1 id="Java自带的标准注解"><a href="#Java自带的标准注解" class="headerlink" title="Java自带的标准注解"></a>Java自带的标准注解</h1><blockquote><ul><li>@Override: 限定重写父类方法, 该注解只能用于方法</li><li>@Deprecated: 用于表示某个程序元素(类, 方法等)已过时</li><li>@SuppressWaring: 作用是屏蔽一些无关紧要的警告。使开发者能看到一些他们真正关心的警告。从而提高开发者的效率<blockquote><ul><li>@SuppressWarnings(“unchecked”)<br>告诉编译器忽略 unchecked 警告信息，如使用List，ArrayList等未进行参数化产生的警告信息。</li><li>@SuppressWarnings(“serial”)<br>如果编译器出现这样的警告信息：The serializable class WmailCalendar does not declare a static final serialVersionUID field of type long，使用这个注释将警告信息去掉。</li><li>@SuppressWarnings(“deprecation”)<br>如果使用了使用@Deprecated注释的方法，编译器将出现警告信息。使用这个注释将警告信息去掉</li></ul></blockquote></li></ul></blockquote><h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><p><strong>元注解</strong>: 自定义注解时需要元注解</p><blockquote><ul><li>@Retention<br>用来定义该注解在哪一个阶段可用，包括 在源代码中(<code>RetentionPolicy.SOURCE</code>)、类文件中(<code>RetentionPolicy.CLASS</code>)或者运行时(<code>RetentionPolicy.RUNTIME</code>)</li><li>@Documented<br>生成文档信息的时候保留注解，对类作辅助说明</li><li>@Target:<br>注解可以修饰什么<br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%B3%A8%E8%A7%A3%20Annotation/1.png"></li><li>@ Inherited<br>说明子类可以继承父类中的该注解. 如果某个类使用了被@Inherited 修饰的Annotation, 则其子类将自动具有该注解</li></ul></blockquote><p><strong>构建自定义注解</strong></p><blockquote><ul><li>定义一个注解</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.FIELD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> IDAuthenticator &#123;<br>    <span class="hljs-comment">//属性类型, 属性名称, 默认值</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">length</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">8</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>构建注解解析</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">check</span><span class="hljs-params">(Student student)</span> <span class="hljs-keyword">throws</span> IllegalAccessException &#123;<br><span class="hljs-comment">//使用Java反射得到属性</span><br>    <span class="hljs-keyword">for</span>(Field field:student.getClass().getDeclaredFields())&#123;<br>    <span class="hljs-comment">//如果属性被IDAuthenticator修饰</span><br>        <span class="hljs-keyword">if</span>(field.isAnnotationPresent(IDAuthenticator.class))&#123;<br>        <span class="hljs-comment">//拿到IDAuthenticator 对象</span><br>            <span class="hljs-type">IDAuthenticator</span> <span class="hljs-variable">idAuthenticator</span> <span class="hljs-operator">=</span> field.getAnnotation(IDAuthenticator.class);<br>            field.setAccessible(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">//拿到student类中对应的属性, 也就是id属性</span><br>            Object value=field.get(student);<br>            <span class="hljs-comment">//判断属性长度</span><br>            <span class="hljs-keyword">if</span>(value <span class="hljs-keyword">instanceof</span> String)&#123;<br>                String id=(String) value;<br>                <span class="hljs-comment">//idAuthenticator.length()就是注解中的属性参数</span><br>                <span class="hljs-keyword">if</span>(id.length()!=idAuthenticator.length())&#123;<br>                    <span class="hljs-keyword">throw</span>  <span class="hljs-keyword">new</span>  <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;the length of &quot;</span>+field.getName()+<span class="hljs-string">&quot; should be &quot;</span>+idAuthenticator.length());<br>                &#125;<br><br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>应用注解</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span>  String name;<br>    <span class="hljs-meta">@IDAuthenticator(length = 4)</span><br>    <span class="hljs-keyword">private</span> String id;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>测试:</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">useAnnotation</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student01</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>, <span class="hljs-string">&quot;20210122&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小军&quot;</span>, <span class="hljs-string">&quot;2021&quot;</span>);<br>    <span class="hljs-type">Student</span> <span class="hljs-variable">student03</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小花&quot;</span>, <span class="hljs-string">&quot;20210121&quot;</span>);<br>    <br>    <span class="hljs-keyword">for</span>(Student student:<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>[]&#123;student01,student02,student03&#125;)&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            check(student);<br>            System.out.println(<span class="hljs-string">&quot; Student &quot;</span>+student+<span class="hljs-string">&quot; checks ok &quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException | IllegalAccessException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot; Student &quot;</span>+student+<span class="hljs-string">&quot; checks failed &quot;</span>+e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 高级特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- 动态代理 Proxy</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%20Proxy/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%20Proxy/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理"></a>什么是代理</h1><blockquote><ul><li>一个类(代理类) 作为另外一个类的代理(被代理类)</li><li>为某些对象的某种行为提供一个代理对象，并由代理对象完全控制该行为的实际执行。</li><li>代理的好处<blockquote><ul><li>可以隐藏委托类的实现</li><li>可以实现客户与委托类间的解耦，在不修改委托类代码的情况下能够做一些额外的处理</li></ul></blockquote></li></ul></blockquote><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><blockquote><ul><li>若代理类在程序运行前就已经存在，那么这种代理方式被成为 静态代理</li></ul></blockquote><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>定义一个接口和一个接口的实现类也就是委托类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sell</span> &#123; <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span>; <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">ad</span><span class="hljs-params">()</span>; <br>&#125; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vendor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sell</span> &#123; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span> &#123; <br>  System.out.println(<span class="hljs-string">&quot;In sell method&quot;</span>); <br> &#125; <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ad</span><span class="hljs-params">()</span> &#123; <br>  System,out.println(<span class="hljs-string">&quot;ad method&quot;</span>) <br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>定义一个代理类: BusinessAgent, 增加一个过滤功能，只卖货给大学生<br>通过静态代理，我们达到了功能增强的目的，而且没有侵入原代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BusinessAgent</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sell</span> &#123; <br>Sell vendor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">BusinesAgent</span> <span class="hljs-params">(Sell vendor)</span> &#123;<br><span class="hljs-built_in">this</span>.vendor = vendor;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-keyword">if</span> (isCollegeStudent()) &#123; <br>vendor.sell(); <br>System.out.println(<span class="hljs-string">&quot;In sell method&quot;</span>); <br>&#125; <br>&#125; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ad</span><span class="hljs-params">()</span> &#123; <br>System,out.println(<span class="hljs-string">&quot;ad method&quot;</span>) <br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure><h2 id="静态代理的缺点"><a href="#静态代理的缺点" class="headerlink" title="静态代理的缺点"></a>静态代理的缺点</h2><blockquote><ol><li>当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：<blockquote><ul><li>只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大</li><li>新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类</li></ul></blockquote></li><li>当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护</li></ol></blockquote><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><blockquote><ul><li>代理类在程序运行时创建的代理方式被成为 动态代理。 也就是说，这种情况下，代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。</li></ul></blockquote><p><strong>委托类</strong></p><blockquote><ul><li>和静态代理一样, 需要定义需要代理的接口和实现类</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Sell</span> &#123; <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span>; <br><span class="hljs-keyword">void</span> <span class="hljs-title function_">ad</span><span class="hljs-params">()</span>; <br>&#125; <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Vendor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Sell</span> &#123; <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sell</span><span class="hljs-params">()</span> &#123; <br>  System.out.println(<span class="hljs-string">&quot;In sell method&quot;</span>); <br> &#125; <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ad</span><span class="hljs-params">()</span> &#123; <br>  System,out.println(<span class="hljs-string">&quot;ad method&quot;</span>) <br>  &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p><strong>中介类</strong></p><blockquote><ul><li>在使用动态代理时，我们需要定义一个位于代理类与委托类之间的中介类，这个中介类被要求实现InvocationHandler接口，这个接口的定义如下：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InvocationHandler</span> &#123; <br>Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>当我们调用代理类对象的方法时，这个“调用”会转送到invoke方法中，<blockquote><ul><li>proxy:  代理类对象，Method: 代理类的某个方法，args: 这个方法的参数</li></ul></blockquote></li><li>这样一来，我们对代理类中的所有方法的调用都会变为对invoke的调用</li><li>我们可以在invoke方法中添加统一的处理逻辑(也可以根据method和参数对不同的代理类方法做不同的处理)</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//下面对委托类的所有方法加上&quot;before&quot;和&quot;after&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123; <br>  <br><span class="hljs-keyword">private</span> Object obj; <span class="hljs-comment">//obj为委托类对象; </span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DynamicProxy</span><span class="hljs-params">(Object obj)</span> &#123; <br><span class="hljs-built_in">this</span>.obj = obj; <br>&#125; <br>  <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123; <br>System.out.println(<span class="hljs-string">&quot;before&quot;</span>); <br><span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(obj, args); <span class="hljs-comment">//这里用到了Java的反射机制</span><br>System.out.println(<span class="hljs-string">&quot;after&quot;</span>); <br><span class="hljs-keyword">return</span> result; <br>&#125; <br>&#125; <br></code></pre></td></tr></table></figure><p><strong>动态生成代理类</strong>  — 使用Proxy类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123; <br><span class="hljs-comment">//创建中介类实例 </span><br><span class="hljs-type">DynamicProxy</span> <span class="hljs-variable">inter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DynamicProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Vendor</span>()); <br><span class="hljs-comment">//加上这句将会产生一个$Proxy0.class文件，这个文件即为动态生成的代理类文件 </span><br>System.getProperties().put(<span class="hljs-string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>,<span class="hljs-string">&quot;true&quot;</span>); <br><span class="hljs-comment">//获取代理类实例sell </span><br><span class="hljs-type">Sell</span> <span class="hljs-variable">sell</span> <span class="hljs-operator">=</span> (Sell)(Proxy.newProxyInstance(Sell.class.getClassLoader(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[] &#123;Sell.class&#125;, inter)); <br><span class="hljs-comment">//通过代理类对象调用代理类方法，实际上会转到invoke方法调用 </span><br>sell.sell(); <br>sell.ad();  <br>&#125; <br></code></pre></td></tr></table></figure><blockquote><ul><li>我们调用Proxy类的newProxyInstance方法来获取一个代理类实例。这个代理类实现了我们指定的接口并且会把方法调用分发到指定的调用处理器。这个方法的声明如下：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">newProxyInstance</span><span class="hljs-params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException<br></code></pre></td></tr></table></figure><p>方法的三个参数含义分别如下：</p><blockquote><ul><li>loader：定义了代理类的ClassLoder;</li><li>interfaces：代理类实现的接口列表</li><li>h：调用处理器，也就是我们上面定义的实现了InvocationHandler接口的类实例</li></ul></blockquote><h1 id="动态代理的主要作用"><a href="#动态代理的主要作用" class="headerlink" title="动态代理的主要作用"></a>动态代理的主要作用</h1><blockquote><ul><li>动态代理的主要用来做方法增强, 可以再不修改源代码的情况下,增强一些方法</li><li>远程调用, 比如现在有Java接口, 这个接口的实现部署在其他服务器上. 在编写客户端代码的时候, 没办法直接调用接口方法, 因为接口是不能直接生成对象的, 这个时候可以考虑动态代理</li><li>可以实现AOP</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 高级特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- 反射机制 Reflection</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%20Reflection/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%20Reflection/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><blockquote><ul><li>一般情况下使用new 关键字实例化一个类,创建初始化一个对象</li><li>也就是在写代码时我们就知道类的类别, 类的属性,   类的所有方法等</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Apple</span> <span class="hljs-variable">apple</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>(); <span class="hljs-comment">//直接初始化</span><br>apple.setPrice(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><blockquote><ul><li>而反射则和正常情况相反, 在写代码时我们不知道类的类别, 类的属性, 类的方法等</li><li>这时候，我们使用 JDK 提供的反射 API 进行反射调用创建对象</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Class</span> <span class="hljs-variable">clz</span> <span class="hljs-operator">=</span> Class.forName(<span class="hljs-string">&quot;com.chenshuyi.reflect.Apple&quot;</span>);<br><span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> clz.getMethod(<span class="hljs-string">&quot;setPrice&quot;</span>, <span class="hljs-type">int</span>.class);<br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> clz.getConstructor();<br><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> constructor.newInstance();<br>method.invoke(object, <span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure><blockquote><p><strong>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制. 这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制</strong></p></blockquote><h1 id="反射的实现原理"><a href="#反射的实现原理" class="headerlink" title="反射的实现原理"></a>反射的实现原理</h1><h2 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h2><blockquote><p><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%20Reflection/1.png"></p></blockquote><blockquote><ul><li>当我们写完一个Java项目之后，每个java文件都会被编译成一个 .class文件</li><li>这些 .class文件在程序运行时会被ClassLoader加载到JVM中，当一个类被加载以后，JVM就会在内存中自动产生一个Class对象</li><li>Class类是一个特殊的类, 包括了大量的方法可以获得一个类的详细信息, 下面是常用的方法</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Class.forName();动态加载类。<br>newInstance() ：根据对象的class新建一个对象<br>getSuperclass() 获取继承的父类<br>getInterfaces() 获取继承的接口<br>getDeclaredFields() 获取所有属性名<br>getDeclaredMethods();获取当前类的所有方法。<br>getConstructors() ：获得所有的构造函数。<br>getModifiers() ： 反射中获得修饰符<br>getPackage() ：反射中获得<span class="hljs-keyword">package</span><br><span class="hljs-title function_">getField</span><span class="hljs-params">(String name)</span>：反射中获得属性成员。<br>getFields() :获得域数组成员。<br>isAnnotation() ：判断是否为注解类型。<br>isPrimitive() ：判断是否为基本类型。<br>isArray() ：判断是否为数组类型。<br>isEnum() ：判断是否为枚举类型。<br>getClassLoader() ：获得类的类加载器<br>getMethods() 获得公共的方法<br></code></pre></td></tr></table></figure><p><strong>获取Class对象的三个方法</strong></p><blockquote><p>Class.forName(“全类名”)<br>注意是全类名,也就是类的完整路径</p></blockquote><blockquote><p>类名.class<br>通过类名的class属性获取</p></blockquote><blockquote><p>对象名.getClass()<br>getClass()方法定义于Object类中</p></blockquote><h1 id="使用-java-lang-reflect和Class类"><a href="#使用-java-lang-reflect和Class类" class="headerlink" title="使用 java.lang.reflect和Class类"></a>使用 java.lang.reflect和Class类</h1><blockquote><p><strong>反射的本质其实就是用java.lang.reflect类库API操作Class对象的结果</strong></p></blockquote><blockquote><ul><li>java.lang.reflect中最主要的类: Field, Method, and Constructor , 分别描述一个类的成员属性, 所有方法以及构造函数</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> reflection; <br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * This program uses reflection to print all features of a class.</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@version</span> 1.1 2004-02-21</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@author</span> Cay Horstmann</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// read class name from command line args or user input</span><br>String name;<br><span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">0</span>) name = args[<span class="hljs-number">0</span>];<br> <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>System.out.println(<span class="hljs-string">&quot;Enter class name (e.g. java.util.Date): &quot;</span>);<br>name = in.next();<br>&#125;<br> <span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">// print class name and superclass name (if != Object)</span><br><span class="hljs-type">Class</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Class.forName(name);<br><span class="hljs-type">Class</span> <span class="hljs-variable">supercl</span> <span class="hljs-operator">=</span> cl.getSuperclass();<br><span class="hljs-type">String</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> Modifier.toString(cl.getModifiers());<br><span class="hljs-keyword">if</span> (modifiers.length() &gt; <span class="hljs-number">0</span>) System.out.print(modifiers + <span class="hljs-string">&quot; &quot;</span>);<br>System.out.print(<span class="hljs-string">&quot;class &quot;</span> + name);<br><span class="hljs-keyword">if</span> (supercl != <span class="hljs-literal">null</span> &amp;&amp; supercl != Object.class) System.out.print(<span class="hljs-string">&quot; extends &quot;</span>+ supercl.getName());<br>System.out.print(<span class="hljs-string">&quot;\n&#123;\n&quot;</span>);<br><br>printConstructors(cl);<br>System.out.println();<br>printMethods(cl);<br>System.out.println();<br>printFields(cl);<br>System.out.println(<span class="hljs-string">&quot;&#125;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>e.printStackTrace();<br>&#125;<br>System.exit(<span class="hljs-number">0</span>);<br>&#125;<br> <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">* Prints all constructors of a class</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> cl a class</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printConstructors</span><span class="hljs-params">(Class cl)</span> &#123;<br>Constructor[] constructors = cl.getDeclaredConstructors();<br><br><span class="hljs-keyword">for</span> (Constructor c : constructors) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> c.getName();<br>System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> Modifier.toString(c.getModifiers());<br><span class="hljs-keyword">if</span> (modifiers.length() &gt; <span class="hljs-number">0</span>) System.out.print(modifiers + <span class="hljs-string">&quot; &quot;</span>); <br>System.out.print(name + <span class="hljs-string">&quot;(&quot;</span>);<br> <span class="hljs-comment">// print parameter types</span><br>Class[] paramTypes = c.getParameterTypes();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; paramTypes.length; j++) &#123;<br><span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) System.out.print(<span class="hljs-string">&quot;, &quot;</span>);<br>System.out.print(paramTypes[j].getName());<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;);&quot;</span>);<br>&#125;<br>&#125;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">* Prints all methods of a class</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> cl a class</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printMethods</span><span class="hljs-params">(Class cl)</span> &#123;<br>Method[] methods = cl.getDeclaredMethods();<br><br><span class="hljs-keyword">for</span> (Method m : methods) &#123;<br><span class="hljs-type">Class</span> <span class="hljs-variable">retType</span> <span class="hljs-operator">=</span> m.getReturnType();<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> m.getName();<br>System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-comment">// print modifiers, return type and method name</span><br><span class="hljs-type">String</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> Modifier.toString(m.getModifiers());<br><span class="hljs-keyword">if</span> (modifiers.length() &gt; <span class="hljs-number">0</span>) System.out.print(modifiers + <span class="hljs-string">&quot; &quot;</span>); <br>System.out.print(retType.getName() + <span class="hljs-string">&quot; &quot;</span> + name + <span class="hljs-string">&quot;(&quot;</span>);<br> <br><span class="hljs-comment">// print parameter types</span><br>Class[] paramTypes = m.getParameterTypes();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; paramTypes.length; j++) &#123;<br><span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>) System.out.print(<span class="hljs-string">&quot;, &quot;</span>);<br>System.out.print(paramTypes[j].getName());<br>&#125;<br>System.out.println(<span class="hljs-string">&quot;);&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Prints all fields of a class</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> cl a class</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printFields</span><span class="hljs-params">(Class cl)</span> &#123;<br>Field[] fields = cl.getDeclaredFields();<br><br><span class="hljs-keyword">for</span> (Field f : fields) &#123;<br><span class="hljs-type">Class</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> f.getType();<br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> f.getName();<br>System.out.print(<span class="hljs-string">&quot; &quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">modifiers</span> <span class="hljs-operator">=</span> Modifier.toString(f.getModifiers());<br><span class="hljs-keyword">if</span> (modifiers.length() &gt; <span class="hljs-number">0</span>) System.out.print(modifiers + <span class="hljs-string">&quot; &quot;</span>); <br>System.out.println(type.getName() + <span class="hljs-string">&quot; &quot;</span> + name + <span class="hljs-string">&quot;;&quot;</span>);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>input:  java.lang.Double<br>下面是输出结果: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.Double <span class="hljs-keyword">extends</span> <span class="hljs-title class_">java</span>.lang.Number<br>&#123;<br> <span class="hljs-comment">//Constructor</span><br> <span class="hljs-keyword">public</span> java.lang.Double(java.lang.String);<br> <span class="hljs-keyword">public</span> java.lang.Double(<span class="hljs-type">double</span>);<br> <br> <span class="hljs-comment">//All methods</span><br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(java.lang.Object)</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(java.lang.Double)</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(java.lang.Object)</span>;<br> <span class="hljs-keyword">public</span> java.lang.String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> java.lang.String <span class="hljs-title function_">toString</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> java.lang.Double <span class="hljs-title function_">valueOf</span><span class="hljs-params">(java.lang.String)</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNaN</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNaN</span><span class="hljs-params">()</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInfinite</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInfinite</span><span class="hljs-params">()</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span> <span class="hljs-title function_">byteValue</span><span class="hljs-params">()</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">short</span> <span class="hljs-title function_">shortValue</span><span class="hljs-params">()</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">intValue</span><span class="hljs-params">()</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">longValue</span><span class="hljs-params">()</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title function_">floatValue</span><span class="hljs-params">()</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">doubleValue</span><span class="hljs-params">()</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">parseDouble</span><span class="hljs-params">(java.lang.String)</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">doubleToLongBits</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">doubleToRawLongBits</span><span class="hljs-params">(<span class="hljs-type">double</span>)</span>;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-type">double</span> <span class="hljs-title function_">longBitsToDouble</span><span class="hljs-params">(<span class="hljs-type">long</span>)</span>;<br> <br> <span class="hljs-comment">//All fields</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> POSITIVE_INFINITY;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> NEGATIVE_INFINITY;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> NaN;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> MAX_VALUE;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> MIN_VALUE;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> java.lang.Class TYPE;<br> <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> value;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> serialVersionUID;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="反射的优势和劣势"><a href="#反射的优势和劣势" class="headerlink" title="反射的优势和劣势"></a>反射的优势和劣势</h1><p>优势</p><blockquote><ul><li>使用反射的时候，可以只传入类名参数，就可以生成对象，降低了耦合性，使得程序更具灵活性</li></ul></blockquote><p>劣势</p><blockquote><ul><li>因为是运行时的操作, 所以性能方面要慢</li><li>反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题</li></ul></blockquote><h1 id="反射的实际使用场景"><a href="#反射的实际使用场景" class="headerlink" title="反射的实际使用场景"></a>反射的实际使用场景</h1><p>以下是一些反射的使用场景</p><h2 id="IDE的使用"><a href="#IDE的使用" class="headerlink" title="IDE的使用"></a>IDE的使用</h2><blockquote><ul><li>当我们在使用 IDE(如 Eclipse，IDEA)时，当我们输入一个对象或类并想调用它的属性或方法时，一按点号，编译器就会自动列出它的属性或方法，这里就会用到反射</li></ul></blockquote><h2 id="JDBC连接数据库"><a href="#JDBC连接数据库" class="headerlink" title="JDBC连接数据库"></a>JDBC连接数据库</h2><blockquote><ul><li>数据库的连接驱动类就是编译的时候不知道你到底是用的mysql，oracle还是其他数据库，而是由运行期动态加载的</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1.加载驱动程序</span><br>      Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>      <span class="hljs-comment">// 2.获得数据库的连接</span><br>      <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> DriverManager.getConnection(URL, NAME, PASSWORD);<br>     .......<br></code></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><blockquote><ul><li>反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 Bean），为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射，运行时动态加载需要加载的对象。</li></ul></blockquote><p>举一个例子，在运用 Struts 2 框架的开发中我们一般会在 struts.xml 里去配置 Action，比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;login&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.ScZyhSoft.test.action.SimpleLoginAction&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;execute&quot;</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">result</span>&gt;</span>/shop/shop-index.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span>login.jsp<span class="hljs-tag">&lt;/<span class="hljs-name">result</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>配置文件与 Action 建立了一种映射关系，当 View 层发出请求时，请求会被 <code>StrutsPrepareAndExecuteFilter</code> 拦截，然后 <code>StrutsPrepareAndExecuteFilter</code> 会去动态地创建 Action 实例。比如我们请求 <code>login.action</code>，那么 <code>StrutsPrepareAndExecuteFilter</code>就会去解析<code>struts.xml</code>文件，检索action中name为login的Action，并根据class属性创建SimpleLoginAction实例，并用invoke方法来调用execute方法，这个过程离不开反射。</p></blockquote><blockquote><p>对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。而对于一般的开发者来说，不深入框架开发则用反射用的就会少一点，不过了解一下框架的底层机制有助于丰富自己的编程思想，也是很有益的。</p></blockquote><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><h2 id="利用反射写一个Generic-Array"><a href="#利用反射写一个Generic-Array" class="headerlink" title="利用反射写一个Generic Array"></a>利用反射写一个Generic Array</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> arrays;<br><span class="hljs-keyword">import</span> java.lang.reflect.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* This program demonstrates the use of reflection for manipulating arrays.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@version</span> 1.2 2012-05-04</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> Cay Horstmann</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyOfTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-type">int</span>[] a = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> &#125;;<br>a = (<span class="hljs-type">int</span>[]) goodCopyOf(a, <span class="hljs-number">10</span>);<br>System.out.println(Arrays.toString(a));<br>String[] b = &#123; <span class="hljs-string">&quot;Tom&quot;</span>, <span class="hljs-string">&quot;Dick&quot;</span>, <span class="hljs-string">&quot;Harry&quot;</span> &#125;;<br>b = (String[]) goodCopyOf(b, <span class="hljs-number">10</span>);<br>System.out.println(Arrays.toString(b));<br>System.out.println(<span class="hljs-string">&quot;The following call will generate an exception.&quot;</span>);<br>b = (String[]) badCopyOf(b, <span class="hljs-number">10</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* This method attempts to grow an array by allocating a new array and copying all elements.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> a the array to grow</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> newLength the new length</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> a larger array that contains all elements of a. However, the returned array has </span><br><span class="hljs-comment">* type Object[], not the same type as a</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object[] badCopyOf(Object[] a, <span class="hljs-type">int</span> newLength) <span class="hljs-comment">// not useful</span><br>&#123;<br>Object[] newArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[newLength];<br>System.arraycopy(a, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, Math.min(a.length, newLength));<br><span class="hljs-keyword">return</span> newArray;<br>&#125;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* This method grows an array by allocating a new array of the same type and</span><br><span class="hljs-comment">* copying all elements.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> a the array to grow. This can be an object array or a primitive</span><br><span class="hljs-comment">* type array</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> a larger array that contains all elements of a.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">goodCopyOf</span><span class="hljs-params">(Object a, <span class="hljs-type">int</span> newLength)</span> <br>&#123;<br><span class="hljs-type">Class</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> a.getClass();<br><span class="hljs-keyword">if</span> (!cl.isArray()) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">Class</span> <span class="hljs-variable">componentType</span> <span class="hljs-operator">=</span> cl.getComponentType();<br><span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> Array.getLength(a);<br><span class="hljs-type">Object</span> <span class="hljs-variable">newArray</span> <span class="hljs-operator">=</span> Array.newInstance(componentType, newLength);<br>System.arraycopy(a, <span class="hljs-number">0</span>, newArray, <span class="hljs-number">0</span>, Math.min(length, newLength));<br><span class="hljs-keyword">return</span> newArray;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义配置文件"><a href="#自定义配置文件" class="headerlink" title="自定义配置文件"></a>自定义配置文件</h2><p><strong>原文链接：<a href="https://blog.csdn.net/weixin_45333509/article/details/115360094">https://blog.csdn.net/weixin_45333509/article/details/115360094</a></strong></p><blockquote><p>游戏中有两名英雄角色供玩家选择<br>角色1：<br>姓名：安琪拉<br>职业：中单<br>一技能：程序中会使用public修饰，代表角色行为的方法<br>被动：程序中会使用private修饰，代表角色行为的方法</p></blockquote><blockquote><p>角色2<br>姓名：凯<br>职业：上单<br>一技能：程序中会使用public修饰，代表角色行为的方法<br>被动：程序中会使用private修饰，代表角色行为的方法</p></blockquote><blockquote><p>此时我们需要一个配置文件供玩家配置想要选择的英雄角色以及要释放的技能 people.properties</p></blockquote><p><strong>定义角色1 AnQiLa</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.demo.roles;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AnQiLa</span> &#123;<br>    <span class="hljs-keyword">private</span> String name=<span class="hljs-string">&quot;安琪拉&quot;</span>;<br>    <span class="hljs-keyword">private</span> String job=<span class="hljs-string">&quot;中单&quot;</span>;<br><br>    <span class="hljs-comment">//私有化角色触发被动技能的方法</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getPassiveSkill</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name+<span class="hljs-string">&quot;: [触发了被动技能！]&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//角色一技能</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFirstSkill</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name+<span class="hljs-string">&quot;: [在中路使用了一技能]&quot;</span>;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getJob</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> job;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setJob</span><span class="hljs-params">(String job)</span> &#123;<br>        <span class="hljs-built_in">this</span>.job = job;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>定义角色2 Kai</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.demo.roles;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Kai</span> &#123;<br>    <span class="hljs-keyword">private</span> String name=<span class="hljs-string">&quot;凯&quot;</span>;<br>    <span class="hljs-keyword">private</span> String job=<span class="hljs-string">&quot;上单&quot;</span>;<br><br>    <span class="hljs-comment">//私有化角色触发被动技能的方法</span><br>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getPassiveSkill</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name+<span class="hljs-string">&quot;: [触发了被动技能！]&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//角色一技能</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getFirstSkill</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> name+<span class="hljs-string">&quot;: [在上路使用了一技能]&quot;</span>;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getJob</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> job;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setJob</span><span class="hljs-params">(String job)</span> &#123;<br>        <span class="hljs-built_in">this</span>.job = job;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>开发业务场景工具类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.demo.controller;<br><br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.util.Properties;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectUtil</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//加载玩家配置信息</span><br>        <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>        <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoader</span> <span class="hljs-operator">=</span> ReflectUtil.class.getClassLoader();<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">resourceAsStream</span> <span class="hljs-operator">=</span> classLoader.getResourceAsStream(<span class="hljs-string">&quot;people.properties&quot;</span>);<br>        properties.load(resourceAsStream);<br><br>        <span class="hljs-comment">//从配置文件中读取玩家选择的英雄角色</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">role</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;object.role&quot;</span>);<br>        <span class="hljs-comment">//从配置文件中读取玩家使用的技能</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">actions</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;method.skills&quot;</span>);<br>        String[] skills = actions.split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>        <span class="hljs-comment">//通过反射实例化玩家选择的角色对象</span><br>        <span class="hljs-type">Class</span> <span class="hljs-variable">aClass</span> <span class="hljs-operator">=</span> Class.forName(role);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> aClass.newInstance();<br><br>        <span class="hljs-comment">//遍历玩家选择使用的技能</span><br>        <span class="hljs-keyword">for</span> (String skill : skills) &#123;<br>            <span class="hljs-comment">//获取玩家使用角色的所有技能</span><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">declaredSkill</span> <span class="hljs-operator">=</span> aClass.getDeclaredMethod(skill);<br>            <span class="hljs-comment">//判断获得的技能是否私有</span><br>            <span class="hljs-keyword">if</span> (declaredSkill.toString().contains(<span class="hljs-string">&quot;private&quot;</span>)) &#123;<br>                <span class="hljs-comment">//如果是私有的被动技能，则需设置私有技能可使用</span><br>                declaredSkill.setAccessible(<span class="hljs-literal">true</span>);<br>                <span class="hljs-comment">//使用被动</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> declaredSkill.invoke(instance, <span class="hljs-literal">null</span>);<br>                System.out.println(invoke.toString());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//如果是普通技能 则可以直接访问</span><br>                <span class="hljs-type">Object</span> <span class="hljs-variable">invoke</span> <span class="hljs-operator">=</span> declaredSkill.invoke(instance, <span class="hljs-literal">null</span>);<br>                System.out.println(invoke.toString());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来玩家只需要通过更改people.properties配置文件选择需要使用的角色和需要使用的技能，工具类就可以帮我们完成角色的创建以及技能的释放</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">#玩家配置需要选择的英雄角色<br>#选择AnQiLa[安琪拉]<br>object.role=com.demo.roles.AnQiLa<br><br>#玩家配置需要使用的技能,多个技能之间用英文逗号隔开<br>#选择使用一技能并触发私有的被动技能<br>method.skills=getPassiveSkill,getFirstSkill<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\bin\java.exe <span class="hljs-string">&quot;-javaagent:D:\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=63738:D:\IntelliJ IDEA 2019.1.4\bin&quot;</span> -Dfile.encoding=UTF-<span class="hljs-number">8</span> -classpath F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\charsets.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\deploy.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\access-bridge-<span class="hljs-number">64.</span>jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\cldrdata.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\dnsns.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\jaccess.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\jfxrt.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\localedata.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\nashorn.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\sunec.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\sunjce_provider.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\sunmscapi.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\sunpkcs11.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\zipfs.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\javaws.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\jce.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\jfr.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\jfxswt.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\jsse.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\management-agent.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\plugin.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\resources.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\rt.jar;D:\ideastudyspace\spring_study\reflect-demo\target\classes com.demo.controller.ReflectUtil<br>安琪拉: [触发了被动技能！]<br>安琪拉: [在中路使用了一技能]<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>假如玩家此时想玩上单使用凯，直接在people.properties配置文件里选择即可</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">#玩家配置需要选择的英雄角色<br>#选择Kai[凯]<br>object.role=com.demo.roles.Kai<br><br>#玩家配置需要使用的技能,多个技能之间用英文逗号隔开<br>#选择使用一技能并触发私有的被动技能<br>method.skills=getPassiveSkill,getFirstSkill<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\bin\java.exe <span class="hljs-string">&quot;-javaagent:D:\IntelliJ IDEA 2019.1.4\lib\idea_rt.jar=63947:D:\IntelliJ IDEA 2019.1.4\bin&quot;</span> -Dfile.encoding=UTF-<span class="hljs-number">8</span> -classpath F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\charsets.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\deploy.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\access-bridge-<span class="hljs-number">64.</span>jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\cldrdata.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\dnsns.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\jaccess.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\jfxrt.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\localedata.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\nashorn.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\sunec.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\sunjce_provider.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\sunmscapi.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\sunpkcs11.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\ext\zipfs.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\javaws.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\jce.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\jfr.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\jfxswt.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\jsse.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\management-agent.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\plugin.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\resources.jar;F:\software\Java\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_121</span>\jre\lib\rt.jar;D:\ideastudyspace\spring_study\reflect-demo\target\classes com.demo.controller.ReflectUtil<br>凯: [触发了被动技能！]<br>凯: [在上路使用了一技能]<br><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 高级特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数据库JDBC --- Java Database Connectivity</title>
    <link href="/2024/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93JDBC%20---%20Java%20Database%20Connectivity/"/>
    <url>/2024/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93JDBC%20---%20Java%20Database%20Connectivity/</url>
    
    <content type="html"><![CDATA[<h1 id="关于JDBC"><a href="#关于JDBC" class="headerlink" title="关于JDBC"></a>关于JDBC</h1><h2 id="什么是JDBC"><a href="#什么是JDBC" class="headerlink" title="什么是JDBC"></a>什么是JDBC</h2><blockquote><ul><li>JDBC为使用关系型数据库提供了一套标准化接口<blockquote><ul><li>因为每一个数据库的底层实现原理都不一样, Oracle数据库有自己的原理, MySQL数据库也有自己的原理。<br>MS SqlServer数据库也有自己的原理。</li></ul></blockquote></li><li>JDBC标准化了<blockquote><ul><li>如何和数据库建立连接</li><li>如何初始化查询</li><li>创建查询的方法</li><li>储存查询结果的数据结构</li></ul></blockquote></li><li>注意不同数据库的SQL的语法没有统一</li><li>JDBC需要引用java.sql package</li></ul></blockquote><h2 id="JDBC的组成"><a href="#JDBC的组成" class="headerlink" title="JDBC的组成"></a>JDBC的组成</h2><blockquote><ul><li>JDBC API :   一套完整的java api</li><li>JDBC Driver Manager: 实际和数据库交互的部分<br><img src="/2024/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93JDBC%20---%20Java%20Database%20Connectivity/1.png"></li></ul></blockquote><h2 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h2><p>Collection of interfaces and classes:</p><blockquote><p>• <code>DriverManager</code>: Loads the driver<br>• <code>Driver</code>: Creates a connection<br>• <code>Connection</code>: Represents a connection<br>• <code>DatabaseMetaData</code>: Information about the DB server<br>• <code>Statement</code>: Executing queries<br>• <code>PreparedStatement</code>: Precompiled and stored query<br>• <code>CallableStatment</code>: Execute SQL stored procedures<br>• <code>ResultSet</code>: Results of execution of queries<br>• <code>ResultSetMetaData</code>:Meta data for ResultSet</p></blockquote><h2 id="JDBC的数据类型"><a href="#JDBC的数据类型" class="headerlink" title="JDBC的数据类型"></a>JDBC的数据类型</h2><blockquote><p><img src="/2024/04/26/%E6%95%B0%E6%8D%AE%E5%BA%93JDBC%20---%20Java%20Database%20Connectivity/2.png"></p></blockquote><h1 id="创建JDBC的步骤"><a href="#创建JDBC的步骤" class="headerlink" title="创建JDBC的步骤"></a>创建JDBC的步骤</h1><p><strong>1. 加载驱动</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>Class.forName(<span class="hljs-string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>); <br>Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> &#123; ClassNotFoundException cnfe) &#123; <br>System.out.println(<span class="hljs-string">&quot;Error loading driver: &quot;</span> cnfe);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2. 定义链接URL</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dbhost.yourcompany.com&quot;</span>; <br><span class="hljs-type">String</span> <span class="hljs-variable">dbName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;someName&quot;</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">1234</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">oracleURL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:oracle:thin:@&quot;</span> + host +<span class="hljs-string">&quot;:&quot;</span> + port + <span class="hljs-string">&quot;:&quot;</span> + dbName; <br><span class="hljs-type">String</span> <span class="hljs-variable">mysqlURL</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://&quot;</span> + host +<span class="hljs-string">&quot;:&quot;</span> + port + <span class="hljs-string">&quot;/&quot;</span> + dbName;<br></code></pre></td></tr></table></figure><p><strong>3. 创建链接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>; <br><span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;test&quot;</span>;<br><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(oracleURL,username,password);<br></code></pre></td></tr></table></figure><p><strong>4. 创建Statement Object</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Statement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.createStatement();<br><span class="hljs-comment">// discuss PreparedStatements later</span><br></code></pre></td></tr></table></figure><p><strong>5. 执行查询</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT col1, col2, col3 FROM sometable&quot;</span>; <br><span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery(query);<br></code></pre></td></tr></table></figure><blockquote><ul><li>To modify the database, use <code>executeUpdate()</code>, supplying a string that uses<br><code>UPDATE</code>, <code>INSERT</code>, or <code>DELETE</code></li></ul></blockquote><p><strong>6. 处理结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(resultSet.next()) &#123; <br>System.out.println(resultSet.getString(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot; &quot;</span> +<br>resultSet.getString(<span class="hljs-number">2</span>) + <span class="hljs-string">&quot; &quot;</span> + <br>resultSet.getString(<span class="hljs-number">3</span>)); <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>First column has index 1, not 0</li><li><code>ResultSet</code> provides various <code>getXxx</code> methods that take a column index<br>or name and returns the data</li></ul></blockquote><p><strong>7.关闭链接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">connection.close();<br></code></pre></td></tr></table></figure><blockquote><ul><li>建立连接的代价很高, 所以直到所有数据库操作完成之后再关闭连接</li></ul></blockquote><h1 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h1><h2 id="Result-Set"><a href="#Result-Set" class="headerlink" title="Result Set"></a>Result Set</h2><blockquote><ul><li>Result Set包含SQL查询的结果 —– 也就是根据rows和columns表示的一张表</li><li>ResultSet只能往前遍历(next)</li></ul></blockquote><p>常用的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">getMetaDataObject() <br><span class="hljs-comment">//返回 ResultSetMetaData object</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">next()<br><span class="hljs-comment">//在ResultSet中移动到下一排</span><br><span class="hljs-comment">//如果成功则返回true, 失败则返回false</span><br><span class="hljs-comment">//第一次使用next()会将cursor移动到第一排</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">getWarnings()<br><span class="hljs-comment">//返回第一个SQL Warning 或者返回null如果没有warning</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">findColumn()<br><span class="hljs-comment">//根据对应的列的名字返回对应的数值</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">getXxx()<br><span class="hljs-comment">//Returns the value from the column specified by column name or column index as an Xxx Java type</span><br><span class="hljs-comment">//Legal getXxx types: double, byte, int, Date, String, float, short, long, Time, Object</span><br><span class="hljs-comment">//Be sure to handle the situation where getXxx returns a NULL</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">wasNull()<br><span class="hljs-comment">//To check if the last getXxx read was a SQL NULL</span><br></code></pre></td></tr></table></figure><h2 id="ResultSetMetaData"><a href="#ResultSetMetaData" class="headerlink" title="ResultSetMetaData"></a>ResultSetMetaData</h2><blockquote><ul><li>从 ResultSet 得到 ResultSetMetaData,</li><li><strong>MetaDataResultSet 提供返回的ResultSet的具体信息</strong></li><li>ResultSetMetaData 可以回答以下问题<blockquote><ul><li>result set中有多少row</li><li>指定列的名字</li><li>列名是否区分大小写</li><li>具体一列的数据类型</li><li>是否可以对一列进行查找</li></ul></blockquote></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">getColumnCount()<br><span class="hljs-comment">//返回result set中的columns总数</span><br>getColumnDisplaySize()<br><span class="hljs-comment">//Returns the maximum width of the specified column in characters</span><br>getColumnName()<br><span class="hljs-comment">//The getColumnName method returns the database name of the column</span><br>getColumnType()<br><span class="hljs-comment">//Returns the SQL type for the column to compare against types in java.sql.Type</span><br>isNullable()<br><span class="hljs-comment">//Indicates whether storing a NULL in the column is legal</span><br><span class="hljs-comment">//Compare the return value against ResultSet constants: columnNoNulls, columnNullable, columnNullableUnknown</span><br>isSearchable()<br><span class="hljs-comment">//Returns true or false if the column can be used in a WHERE clause</span><br>isReadOnly() / isWriteable()<br><span class="hljs-comment">//The isReadOnly method indicates if the column is definitely not writable</span><br><span class="hljs-comment">//The isWritable method indicates whether it is possible for a write to succeed</span><br></code></pre></td></tr></table></figure><h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><blockquote><ul><li>SQL statements通过Statement object 发给数据库</li></ul></blockquote><p>不同类型的statement</p><blockquote><ul><li>Statement<blockquote><ul><li>执行简单的SQL语句</li></ul></blockquote></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">executeQuery()<br><span class="hljs-comment">//Executes the SQL query and returns the data in a table (ResultSet)</span><br><span class="hljs-comment">//The resulting table may be empty but never null</span><br>executeUpdate()<br><span class="hljs-comment">//Used to execute for INSERT, UPDATE, or DELETE SQL statements</span><br><span class="hljs-comment">//The return is the number of rows that were affected in the database</span><br>getMaxRows()/setMaxRows()<br><span class="hljs-comment">//Determines the number of rows a ResultSet may contain</span><br><span class="hljs-comment">//Unless explicitly set, the number of rows are unlimited (return value of 0)</span><br>getQueryTimeout()/setQueryTimeout()<br><span class="hljs-comment">//Specifies the amount of a time a driver will wait for a STATEMENT to complete before throwing a SQLException</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>PrepareStatement<blockquote><ul><li>执行带有参数的precompiled SQL statement</li><li>当需要执行多次执行相似的SQL语句时使用, 可以提高性能</li><li>包含execute(), executeQuery(), executeUpdate()</li></ul></blockquote></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <br>DriverManager.getConnection(url, user, password);<br><span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(<span class="hljs-string">&quot;UPDATE employees &quot;</span> +<br><span class="hljs-type">float</span>[] newSalaries = getSalaries(); <br><span class="hljs-type">int</span>[] employeeIDs = getIDs();<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;employeeIDs.length; i++) &#123; <br>statement.setFloat(<span class="hljs-number">1</span>, newSalaries[i]); <br>statement.setInt(<span class="hljs-number">2</span>, employeeIDs[i]);<br>statement.executeUpdate();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>CallableStatement<blockquote><ul><li>for executing a database stored procedure</li></ul></blockquote></li></ul></blockquote><h2 id="SQLException"><a href="#SQLException" class="headerlink" title="SQLException"></a>SQLException</h2><blockquote><ul><li>几乎每个JDBC method 都会抛出一个SQLException</li><li><strong>如果多个错误发生, 它们会被chained together</strong></li><li>SQL exceptions包含:  Description of the error: getMessage()</li><li>The SQLState (Open Group SQL specification) identifying  the exception: getSQLState<blockquote><ul><li>A vendor-specific integer error code:, getErrorCode</li><li>A chain to the next exception: getNextException</li></ul></blockquote></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>... <span class="hljs-comment">// JDBC statement.</span><br>&#125; <span class="hljs-keyword">catch</span> (SQLException sqle) &#123; <br><span class="hljs-keyword">while</span> (sqle != <span class="hljs-literal">null</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;Message: &quot;</span> + sqle.getMessage());<br>System.out.println(<span class="hljs-string">&quot;SQLState: &quot;</span> + sqle.getSQLState()); <br>System.out.println(<span class="hljs-string">&quot;Vendor Error: &quot;</span> + sqle.getErrorCode()); <br>sqle = sqle.getNextException();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="SQL-Warnings"><a href="#SQL-Warnings" class="headerlink" title="SQL Warnings"></a>SQL Warnings</h2><blockquote><ul><li>SQLWarnings are rare, but provide information about the database access warnings</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ResultSet</span> <span class="hljs-variable">results</span> <span class="hljs-operator">=</span> statement.executeQuery(someQuery); <br><span class="hljs-type">SQLWarning</span> <span class="hljs-variable">warning</span> <span class="hljs-operator">=</span> statement.getWarnings();<br><span class="hljs-keyword">while</span> (warning != <span class="hljs-literal">null</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;Message: &quot;</span> + warning.getMessage()); <br>System.out.println(<span class="hljs-string">&quot;SQLState: &quot;</span> + warning.getSQLState()); <br>System.out.println(<span class="hljs-string">&quot;Vendor Error: &quot;</span> + warning.getErrorCode()); <br>warning = warning.getNextWarning();<br>&#125;<br><span class="hljs-keyword">while</span> (results.next()) &#123; <br><span class="hljs-type">int</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> rs.getInt(<span class="hljs-number">1</span>);<br>... <span class="hljs-comment">// Call additonal methods on result set.</span><br><span class="hljs-type">SQLWarning</span> <span class="hljs-variable">warning</span> <span class="hljs-operator">=</span> results.getWarnings(); <br><span class="hljs-keyword">while</span> (warning != <span class="hljs-literal">null</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;Message: &quot;</span> + warning.getMessage()); <br>System.out.println(<span class="hljs-string">&quot;SQLState: &quot;</span> + warning.getSQLState()); <br>System.out.println(<span class="hljs-string">&quot;Vendor Error: &quot;</span> + warning.getErrorCode()); <br>warning = warning.getNextWarning();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h2><blockquote><ul><li>一般默认是 每个SQL statement执行完, 修改会自动comnmitted to database</li><li>关闭auto-commit: <code>connection.setAutoCommit(false)</code></li><li>Call commit to permanently record the changes to the database  after executing a group of statements</li><li>Call rollback if an error occurs</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">getAutoCommit()/setAutoCommit()<br><span class="hljs-comment">//By default, a connection is set to auto-commit</span><br><span class="hljs-comment">// Retrieves or sets the auto-commit mode</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">commit()<br><span class="hljs-comment">//Force all changes since the last call to commit to become permanent</span><br><span class="hljs-comment">//Any database locks currently held by this Connection object are released</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"> rollback()<br><span class="hljs-comment">//Drops all changes since the previous call to commit</span><br><span class="hljs-comment">//Releases any database locks held by this Connection object</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 高级特性</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合 --- Collection 框架</title>
    <link href="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/"/>
    <url>/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Collection-Interface"><a href="#Collection-Interface" class="headerlink" title="Collection Interface"></a>Collection Interface</h1><blockquote><ul><li>the Java collection library separates interfaces and implementations<br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/1.png"></li></ul></blockquote><h1 id="Concrete-Implementations"><a href="#Concrete-Implementations" class="headerlink" title="Concrete Implementations"></a>Concrete Implementations</h1><p><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/2.png"></p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><p><strong>Add</strong><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/3.png"><br><strong>Get and Set</strong><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/4.png"><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/5.png"></p><p><strong>Offer, Peek, Poll</strong><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/6.png"><br><strong>Pop, Push</strong><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/7.png"><br><strong>Remove</strong><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/8.png"><br><strong>Utilities</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>: Removes all of the elements from <span class="hljs-built_in">this</span> list.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span>: Returns a shallow copy of <span class="hljs-built_in">this</span> LinkedList.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span><span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>: Returns <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">this</span> list contains the specified element.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span>: Returns the index of the first occurrence of the specified element in <span class="hljs-built_in">this</span> list, or -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">this</span> list does not contain the element.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span><span class="hljs-title function_">size</span><span class="hljs-params">()</span>: Returns the number of elements in <span class="hljs-built_in">this</span> list.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[]toArray(): Returns an array containing all of the elements in <span class="hljs-built_in">this</span> list in proper <span class="hljs-title function_">sequence</span> <span class="hljs-params">(from first to last element)</span>.<br></code></pre></td></tr></table></figure><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><p><strong>Add</strong><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/9.png"><br><strong>delete</strong><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/10.png"><br><strong>set, get, replace</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span>: Returns the element at the specified position in <span class="hljs-built_in">this</span> list.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">E <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span>: Replaces the element at the specified position in <span class="hljs-built_in">this</span> list with the specified element.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">replaceAll</span><span class="hljs-params">(UnaryOperator&lt;E&gt; operator)</span>: Replaces each element of <span class="hljs-built_in">this</span> list with the result of applying the operator to that element.##  Sets<br></code></pre></td></tr></table></figure><p><strong>Utilities</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span>: Removes all of the elements from <span class="hljs-built_in">this</span> list.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span>: Returns a shallow copy of <span class="hljs-built_in">this</span> ArrayList instance.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span><span class="hljs-title function_">contains</span><span class="hljs-params">(Object o)</span>: Returns <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">this</span> list contains the specified element.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span>: Performs the given action <span class="hljs-keyword">for</span> each element of the Iterable until all elements have been processed or the action <span class="hljs-keyword">throws</span> an exception.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span><span class="hljs-title function_">indexOf</span><span class="hljs-params">(Object o)</span>: Returns the index of the first occurrence of the specified element in <span class="hljs-built_in">this</span> list, or -<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">this</span> list does not contain the element.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] toArray(): Returns an array containing all of the elements in <span class="hljs-built_in">this</span> list in proper <span class="hljs-title function_">sequence</span> <span class="hljs-params">(from first to last element)</span>.<br></code></pre></td></tr></table></figure><p><strong>“only arrayList”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span><span class="hljs-title function_">isEmpty</span><span class="hljs-params">()</span>: Returns <span class="hljs-literal">true</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">this</span> list contains no elements.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span><span class="hljs-title function_">size</span><span class="hljs-params">()</span>: Returns the number of elements in <span class="hljs-built_in">this</span> list.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-built_in">super</span> E&gt; c)</span>: Sorts <span class="hljs-built_in">this</span> list according to the order induced by the specified Comparator.<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">()</span>: Trims the capacity of <span class="hljs-built_in">this</span> ArrayList instance to be the list<span class="hljs-string">&#x27;s current size.</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span>: Increases the capacity of <span class="hljs-built_in">this</span> ArrayList instance, <span class="hljs-keyword">if</span> necessary, to ensure that it can hold at least the number of elements specified by the minimum capacity argument.<br></code></pre></td></tr></table></figure><h2 id="ArrayList-和-LinkedList的区别"><a href="#ArrayList-和-LinkedList的区别" class="headerlink" title="ArrayList 和 LinkedList的区别"></a>ArrayList 和 LinkedList的区别</h2><p><strong>insert and delete</strong></p><blockquote><ul><li>ArrayList: O(n), 因为要将目标位置之后的元素向前移位(delete)或者向后移位(insert),<br>如果超出capacity则需要扩容会增加时间复杂度</li><li>LinkedList: O(n), 需要遍历linkedlist找到node, 然后进行操作: O(1)</li></ul></blockquote><p><strong>set and get</strong> </p><blockquote><ul><li>ArrayList: O(1), 通过下标直接操作</li><li>LinkedList: O(n) 需要遍历linkedlist找到node, 然后进行操作</li></ul></blockquote><p><strong>“space”</strong></p><blockquote><ul><li>ArrayList: 只需数组的空间</li><li>LinkedList: 有overhead, 比如next,pre指针</li></ul></blockquote><p><strong>Summary</strong> </p><blockquote><ul><li>很多场景下ArrayList更受欢迎</li></ul></blockquote><h2 id="Queues-and-Deques"><a href="#Queues-and-Deques" class="headerlink" title="Queues and Deques"></a>Queues and Deques</h2><blockquote><ul><li>Queue:  在尾部加入元素, 从头部删除元素</li><li>Deque (double-ended queue): 可以从头部或者尾部加入删除元素</li><li>可以用LinkedList替代(LinkedList提供了Queue和Deque功能)<br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/11.png"><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/12.png"><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/13.png"></li></ul></blockquote><h2 id="Priority-Queues"><a href="#Priority-Queues" class="headerlink" title="Priority Queues"></a>Priority Queues</h2><p><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/14.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> priorityQueue;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.time.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This program demonstrates the use of a priority queue.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.02 2015-06-20</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Cay Horstmann</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityQueueTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>PriorityQueue&lt;LocalDate&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>pq.add(LocalDate.of(<span class="hljs-number">1906</span>, <span class="hljs-number">12</span>, <span class="hljs-number">9</span>)); <span class="hljs-comment">// G. Hopper</span><br>pq.add(LocalDate.of(<span class="hljs-number">1815</span>, <span class="hljs-number">12</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// A. Lovelace</span><br>pq.add(LocalDate.of(<span class="hljs-number">1903</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>)); <span class="hljs-comment">// J. von Neumann</span><br>pq.add(LocalDate.of(<span class="hljs-number">1910</span>, <span class="hljs-number">6</span>, <span class="hljs-number">22</span>)); <span class="hljs-comment">// K. Zuse</span><br>System.out.println(<span class="hljs-string">&quot;Iterating over elements...&quot;</span>);<br><span class="hljs-keyword">for</span> (LocalDate date : pq)<br>   System.out.println(date);<br>   System.out.println(<span class="hljs-string">&quot;Removing elements...&quot;</span>);<br>   <span class="hljs-keyword">while</span> (!pq.isEmpty())<br>    System.out.println(pq.remove());<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="HashSets"><a href="#HashSets" class="headerlink" title="HashSets"></a>HashSets</h2><blockquote><ul><li>无序的set</li><li>使用HashTable实现 bucket hashing (Array + LinkedList)</li><li>默认bucket大小是 2^16, load factor是0.75</li></ul></blockquote><p><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/15.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SetTest</span><br>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Set&lt;String&gt; words = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(); <span class="hljs-comment">// HashSet implements Set</span><br><span class="hljs-type">long</span> <span class="hljs-variable">totalTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in)) &#123;<br><span class="hljs-keyword">while</span> (in.hasNext()) &#123;<br> <span class="hljs-type">String</span> <span class="hljs-variable">word</span> <span class="hljs-operator">=</span> in.next();<br> <span class="hljs-type">long</span> <span class="hljs-variable">callTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br> words.add(word);<br> callTime = System.currentTimeMillis() - callTime;<br> totalTime += callTime;<br> &#125;<br> &#125;<br> <br> Iterator&lt;String&gt; iter = words.iterator();<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">20</span> &amp;&amp; iter.hasNext(); i++)<br> System.out.println(iter.next());<br> System.out.println(<span class="hljs-string">&quot;. . .&quot;</span>);<br> System.out.println(words.size() + <span class="hljs-string">&quot; distinct words. &quot;</span> + totalTime + <span class="hljs-string">&quot; milliseconds.&quot;</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>LinkedHashSet</strong></p><blockquote><p>是HashSet的一个子类, 元素按照加入顺序排序</p></blockquote><h2 id="TreeSets"><a href="#TreeSets" class="headerlink" title="TreeSets"></a>TreeSets</h2><blockquote><ul><li>有序的Set</li><li>使用红黑树实现</li><li>TreeSet的插入复杂度要比HashSet快, 但是检查重复要比HashSet快(LogN)</li><li>因为是有序的所以必须重新<code>compareTo</code> 否则会报错, String等非自定义类型已经重写了compareTo方法</li><li>如果数据不要求排序最好使用HashSet</li></ul></blockquote><p><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/16.png"><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/17.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSetTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>SortedSet&lt;Item&gt; parts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>parts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>(<span class="hljs-string">&quot;Toaster&quot;</span>, <span class="hljs-number">1234</span>));<br>parts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>(<span class="hljs-string">&quot;Widget&quot;</span>, <span class="hljs-number">4562</span>));<br>parts.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Item</span>(<span class="hljs-string">&quot;Modem&quot;</span>, <span class="hljs-number">9912</span>));<br>System.out.println(parts);<br>NavigableSet&lt;Item&gt; sortByDescription = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<br>Comparator.comparing(Item::getDescription)); <br>sortByDescription.addAll(parts);<br>System.out.println(sortByDescription);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h2><blockquote><ul><li>element是enum类型</li><li>Since an enumerated type has a finite number of instances, the EnumSet is internally implemented simply as a sequence of bits. </li><li>A bit is turned on if the corresponding value is present in the set.</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Weekday</span> &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY &#125;;<br>EnumSet&lt;Weekday&gt; always = EnumSet.allOf(Weekday.class);<br>EnumSet&lt;Weekday&gt; never = EnumSet.noneOf(Weekday.class);<br>EnumSet&lt;Weekday&gt; workday = EnumSet.range(Weekday.MONDAY, Weekday.FRIDAY);<br>EnumSet&lt;Weekday&gt; mwf = EnumSet.of(Weekday.MONDAY, Weekday.WEDNESDAY, Weekday.FRIDAY);<br></code></pre></td></tr></table></figure><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><blockquote><ul><li>Map没有继承Collection接口</li><li>AbstractMap和AbstractCollection是平级关系<br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Collection%20%E6%A1%86%E6%9E%B6/18.png"></li></ul></blockquote><h2 id="Map的基本操作"><a href="#Map的基本操作" class="headerlink" title="Map的基本操作"></a>Map的基本操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> map;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This program demonstrates the use of a map with key type String and value type Employee.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.12 2015-06-21</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Cay Horstmann</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Map&lt;String, Employee&gt; staff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>staff.put(<span class="hljs-string">&quot;144-25-5464&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Amy Lee&quot;</span>));<br>staff.put(<span class="hljs-string">&quot;567-24-2546&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Harry Hacker&quot;</span>));<br>staff.put(<span class="hljs-string">&quot;157-62-7935&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Gary Cooper&quot;</span>));<br>staff.put(<span class="hljs-string">&quot;456-62-5527&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Francesca Cruz&quot;</span>));<br><span class="hljs-comment">// print all entries</span><br>System.out.println(staff);<br><span class="hljs-comment">// remove an entry</span><br>staff.remove(<span class="hljs-string">&quot;567-24-2546&quot;</span>);<br><span class="hljs-comment">// replace an entry</span><br>staff.put(<span class="hljs-string">&quot;456-62-5527&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Francesca Miller&quot;</span>));<br><span class="hljs-comment">// look up a value</span><br>System.out.println(staff.get(<span class="hljs-string">&quot;157-62-7935&quot;</span>));<br><span class="hljs-comment">// iterate through all entries</span><br>staff.forEach((k, v) -&gt; <br>System.out.println(<span class="hljs-string">&quot;key=&quot;</span> + k + <span class="hljs-string">&quot;, value=&quot;</span> + v));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何查看Map"><a href="#如何查看Map" class="headerlink" title="如何查看Map"></a>如何查看Map</h2><p><strong>the set of keys</strong>: 将所有的key作为一个set返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; keys = map.keySet();<br><span class="hljs-keyword">for</span> (String key : keys) &#123;<br><span class="hljs-keyword">do</span> something with key<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>the collection of values (which is not a set)</strong>: 将所有的value作为一个collection返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;V&gt; <span class="hljs-title function_">values</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,String&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       map.put(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>       map.put(<span class="hljs-string">&quot;efg&quot;</span>,<span class="hljs-string">&quot;456&quot;</span>);<br>       <span class="hljs-comment">// 使用增强型for遍历循环Map集合</span><br>       Collection&lt;String&gt; values = map.values();<br>       <span class="hljs-keyword">for</span> (String value : values) &#123;<br>           System.out.println(value);<br>       &#125;<br></code></pre></td></tr></table></figure><p><strong>the set of key&#x2F;value pairs</strong>: 得到每一对key value pair</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Employee&gt; entry : staff.entrySet()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> entry.getKey();<br><span class="hljs-type">Employee</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> entry.getValue();<br><span class="hljs-keyword">do</span> something with k, v<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Type-of-HashMap"><a href="#Type-of-HashMap" class="headerlink" title="Type of HashMap"></a>Type of HashMap</h2><p><strong>HashMap</strong></p><blockquote><ul><li>Hash table based implementation of the Map interface</li><li>the default load factor (.75)</li><li>有一个子类为LinkedHashMap, 元素按照加入顺序排序</li></ul></blockquote><p><strong>TreeMap</strong></p><blockquote><ul><li>A Red-Black tree based NavigableMap implementation.</li><li>需要根据compareTo排序</li></ul></blockquote><p><strong>EumerateHashMap</strong></p><blockquote><ul><li>A specialized Map implementation for use with enum type keys. </li><li>All of the keys in an enum map must come from a single enum type that is specified</li></ul></blockquote><p><strong>WeakHashMap</strong></p><blockquote><ul><li>Hash table based implementation of the Map interface, with weak keys.</li><li>An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use</li></ul></blockquote><h2 id="Collection和Array互相转换"><a href="#Collection和Array互相转换" class="headerlink" title="Collection和Array互相转换"></a>Collection和Array互相转换</h2><p><strong>Collection To Array</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] values = staff.toArray();<br></code></pre></td></tr></table></figure><blockquote><ul><li>但是values的类型是Object并且不能转换类型  <code>String[] values = (String[]) staff.toArray(); // Error!</code></li><li>可以用如下写法: <code>String[] values = staff.toArray(new String[staff.size()]);</code></li></ul></blockquote><p><strong>Array To Collection</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.asList()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] values = . . .;<br>HashSet&lt;String&gt; staff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(values)); <span class="hljs-comment">//所有的collection都可以通过另外一个collection初始化</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 集合Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合 --- HashMap的底层原理</title>
    <link href="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="HashMap的下标计算"><a href="#HashMap的下标计算" class="headerlink" title="HashMap的下标计算"></a>HashMap的下标计算</h1><h2 id="计算步骤"><a href="#计算步骤" class="headerlink" title="计算步骤"></a>计算步骤</h2><p> <strong>第一步: 计算hash值</strong></p><blockquote><ul><li>将h 和 h右移十六位的结果 进行XOR操作</li><li>操作说明:<br>高16位不动, 低16位与高16位做异或运算,<br> 也就是<strong>高十六位 + (低十六位 ^ 高十六位)</strong></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">//hashCode()是native方法, 用 C/C++实现</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二步: 通过hash值计算下标值</strong></p><blockquote><ul><li>将hash值 和 hash数组减一 之后的数值进行AND操作</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//n为 HashMap的长度</span><br><span class="hljs-comment">//这里 &amp; 操作等同于取余操作</span><br>i = (n - <span class="hljs-number">1</span>) &amp; hash <br></code></pre></td></tr></table></figure><p><strong>Example:</strong> </p><blockquote><ul><li>HashMap的默认长度为16, 所以n-1这里取1111</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">  h = key.hashCode()     <span class="hljs-number">01101010</span> <span class="hljs-number">11101111</span> <span class="hljs-number">11100010</span> <span class="hljs-number">11000100</span><br>             h &gt;&gt;&gt; <span class="hljs-number">16</span>    <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">01101010</span> <span class="hljs-number">11101111</span> <br>------------------------------------------------------------<br>hash = h ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>)    <span class="hljs-number">01101010</span> <span class="hljs-number">11101111</span> <span class="hljs-number">10001000</span> <span class="hljs-number">00101011</span><br>  (n - <span class="hljs-number">1</span>) = (<span class="hljs-number">2</span>^<span class="hljs-number">4</span> - <span class="hljs-number">1</span>)    <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00001111</span><br>------------------------------------------------------------<br>     (<span class="hljs-number">2</span>^<span class="hljs-number">4</span> - <span class="hljs-number">1</span>) &amp; hash    <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00001011</span><br></code></pre></td></tr></table></figure><h2 id="为什么要-h-h-16"><a href="#为什么要-h-h-16" class="headerlink" title="为什么要 h ^ (h &gt;&gt;&gt; 16)"></a>为什么要 <code>h ^ (h &gt;&gt;&gt; 16)</code></h2><p>假如没有做<code>h ^ (h &gt;&gt;&gt; 16)</code>运算, 则hash的计算过程为:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">hash = key.hashCode()    <span class="hljs-number">01101010</span> <span class="hljs-number">11101111</span> <span class="hljs-number">11100010</span> <span class="hljs-number">11000100</span><br>              (n - <span class="hljs-number">1</span>)    <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00001111</span><br>------------------------------------------------------------<br>     (n - <span class="hljs-number">1</span>) &amp; hash =    <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000100</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>结合以上示例会发现，整个hash值，除了低四位参与了计算，其他全部没有起到任何的作用.. 全部被0覆盖掉了. </li><li>而大部分情况下, n的值(map的大小) 一般都会小于2^16次方，也就是65536. 则全部集中在低16位</li><li>则如果key的hash值低位相同，计算出来的槽位下标都是同一个，大大增加了碰撞的几率；</li><li>但如果使用h ^ (h &gt;&gt;&gt; 16)，将高位参与到低位的运算，整个随机性就大大增加了；</li><li><strong>结论: 增加离散性, 降低碰撞概率</strong></li></ul></blockquote><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="为什么数组长度必须是2-n"><a href="#为什么数组长度必须是2-n" class="headerlink" title="为什么数组长度必须是2^n"></a>为什么数组长度必须是<code>2^n</code></h2><p><strong>增加离散性, 降低碰撞概率</strong></p><blockquote><ul><li>根据源码可知，无论是初始化，还是保存过程中的扩容，map的长度始终是2^n</li><li>假如默认n的长度不是16（2^4）,而是17，会出现什么效果呢？</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">hash           <span class="hljs-number">01101010</span> <span class="hljs-number">11101111</span> <span class="hljs-number">10001000</span> <span class="hljs-number">00101011</span><br>&amp;<br>(<span class="hljs-number">17</span> - <span class="hljs-number">1</span>) = <span class="hljs-number">16</span>  <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00010000</span><br>----------------------------------------------<br>               <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span> <span class="hljs-number">00000000</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>由于16的二进制是00010000,最终参与&amp;(与运算)的只有1位，其他的值全部被0给屏蔽了；导致最终计算出来的下标只会是0或16. </li><li>所以n的二进制值中必须尽可能多的出现1, 否则在&amp;操作时不管hash值为多少都为0.</li><li>二进制中出现1最多的数就是 2^n - 1</li></ul></blockquote><p><strong>使用&amp;替代 %, 提高计算效率</strong></p><blockquote><ul><li>还有一个原因是当 length &#x3D; 2^n 时，<strong>X % length &#x3D; X &amp; (length - 1)</strong> <blockquote><ul><li>具体数学推导: <a href="https://blog.csdn.net/Ricardo18/article/details/108846384">https://blog.csdn.net/Ricardo18/article/details/108846384</a></li></ul></blockquote></li><li>而在计算机中 &amp; 的效率比 % 高很多.</li></ul></blockquote><h1 id="HashMap的树化"><a href="#HashMap的树化" class="headerlink" title="HashMap的树化"></a>HashMap的树化</h1><p><strong>背景补充</strong></p><blockquote><ul><li>JDK 1.7及之前HashMap的结构为: <strong>数组 + 链表</strong><blockquote><ul><li>Java7中Hashmap底层采用的是Entry对数组，而每一个Entry对又向下延伸是一个链表，在链表上的每一个Entry对不仅存储着自己的key&#x2F;value值，还存了前一个和后一个Entry对的地址.</li></ul></blockquote></li><li>JDK 1.8: <strong>数组+链表+红黑树</strong><blockquote><ul><li>Java8中的Hashmap底层结构有一定的变化，还是使用的数组，但现在换成了Node对象（存储时也会存key&#x2F;value键值对、前一个和后一个Node的地址），</li><li>以前所有的Entry向下延伸都是链表，Java8变成链表和红黑树的组合，数据少量存入的时候优先还是链表，当链表长度大于8，且总数据量大于64的时候，链表就会转化成红黑树，</li><li>所以你会看到Java8的Hashmap的数据存储是链表+红黑树的组合，<strong>如果数据量小于64则只有链表，如果数据量大于64，且某一个数组下标数据量大于8，那么该处即为红黑树</strong></li></ul></blockquote></li></ul></blockquote><p><strong>树化的条件</strong></p><blockquote><ul><li><strong>条件一:  一个Node中链表的节点数量大于等于树化阈值 (也就是8). 源码如下</strong></li><li>必须满足第一个条件才能进入下一个条件</li><li>HashMap触发判断第一个条件的位置主要有4个方法，分别是putVal方法、computeIfAbsent方法、compute方法、merge方法</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>    treeifyBin(tab, hash);<br></code></pre></td></tr></table></figure><blockquote><ul><li><strong>条件二: HashMap的Capacity大于等于最小树化容量值</strong><blockquote><ul><li>如果capacity小于64, 则选择扩容</li><li>如果capacity大于等于64, 则进行树化</li></ul></blockquote></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K,V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br><span class="hljs-type">int</span> n, index; Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>    <span class="hljs-comment">//这里选择扩容</span><br>    resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">do</span> &#123;<br>        TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>)<br>        hd = p;<br>        <span class="hljs-keyword">else</span> &#123;<br>            p.prev = tl;<br>            tl.next = p;<br>        &#125;<br>        tl = p;<br>     &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>     <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>        hd.treeify(tab);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结</strong></p><blockquote><ul><li><strong>如果数据量小于64则只有链表，如果数据量大于64，且某一个数组下标数据量大于8，那么该处即为红黑树</strong></li></ul></blockquote><p><strong>为什么链表变树的阈值为8</strong></p><blockquote><ul><li>在HashMap中, TreeNode的大小是普通node大小的两倍, 所以只有当链表里的node足够多时再树化 (平衡时间和空间) ‘</li><li>对于一个well-distributed的HashMap, node基本不会树化</li><li>HashMap的节点数量分布符合泊松分布:  <blockquote><p> 0:    0.60653066<br>  1:    0.30326533<br>  2:    0.07581633<br>  3:    0.01263606<br>  4:    0.00157952<br>  5:    0.00015795<br>  6:    0.00001316<br>  7:    0.00000094<br>  8:    0.00000006</p></blockquote></li><li>链表长度为8的概率为0.00000006，在这种比较罕见和极端的情况下， 才会把链表转变为红黑树，转变为红黑树也是消耗性能的，是一个权衡的措施.</li><li>当k&#x3D;9时，也就是发生的碰撞次数为9次时，概率为亿分之三，碰撞的概率已经无限接近为0。<br>如果设置为9，意味着，几乎永远都不会再次发生碰撞，基本永远都不会变树，因为概率太小了。因此设置为9，实在没必要。</li></ul></blockquote><p><strong>为什么使用红黑树 而不是 AVL树</strong></p><blockquote><ul><li>红黑树相比avl树，在检索的时候效率其实差不多，都是通过平衡来二分查找。</li><li>AVL树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，AVL树为了维持这种高度的平衡，就要付出更多代价。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用AVL树的代价就有点高了。</li><li>红黑树只是做到了近似平衡，并不严格的平衡，所以在维护的成本上，要比AVL树要低</li><li>所以，红黑树的插入、删除、查找各种操作性能都比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。在现在很多地方都是底层都是红黑树的天下.</li></ul></blockquote><h1 id="HashMap的扩容"><a href="#HashMap的扩容" class="headerlink" title="HashMap的扩容"></a>HashMap的扩容</h1><p><strong>背景补充:</strong></p><blockquote><ul><li>HashMap的初始容量16, 每次扩容都是两倍, 所以HashMap的容量必为2的n次幂</li><li>负载因子默认为0.75, 也就是当数组的密度大于百分之75时会进行扩容</li><li>当链表的长度大于8, 但数组长度小于64的时候, 会进行扩容</li><li>JDK1.7在链表中的插入方式为头插法, 这样可以避免遍历链表, 但是在多线程的情况下会有死循环问题, JDK1.8则改为尾插法</li></ul></blockquote><blockquote><ul><li>JDK1,7 中部会新建一个数组，然后通过transfer方法, 将原数组中的键值对依次加入到新数组中。transfer方法会遍历旧数组，对于每个数组元素，会遍历其中的每个节点，并重新计算其hash值，然后使用头插法将其插入到新的索引位置上</li></ul></blockquote><p><strong>JDK1.8的扩容方式 – 不需要重新计算hash的值</strong><br>第一步:</p><blockquote><ul><li>由于扩容直接加了1倍，因此相当于length-1原来的最右侧的0变为了1, 比如:</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">16</span> -&gt; <span class="hljs-number">32</span><br><span class="hljs-number">16</span>-<span class="hljs-number">1</span> = <span class="hljs-number">15</span>   <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000001111</span><br><span class="hljs-number">32</span>-<span class="hljs-number">1</span> = <span class="hljs-number">31</span>   <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000011111</span><br></code></pre></td></tr></table></figure><p>第二步:</p><blockquote><ul><li>下标的计算是 hash &amp; (n-1), 所以新下标取决于变为1的那个bit所对应的hash中的bit是0还是1</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">长度为<span class="hljs-number">16</span> = <span class="hljs-number">10000</span><br>hash        xxxxxxxxxxxxxxxx xxxxxxxxxxxyxxxx<br><span class="hljs-number">16</span> - <span class="hljs-number">1</span>      <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000001111</span><br><br>下标为xxxx<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">长度为<span class="hljs-number">32</span> = <span class="hljs-number">100000</span><br>hash        xxxxxxxxxxxxxxxx xxxxxxxxxxxyxxxx<br><span class="hljs-number">16</span> - <span class="hljs-number">1</span>      <span class="hljs-number">0000000000000000</span> <span class="hljs-number">0000000000011111</span><br><br>如果y = <span class="hljs-number">1</span> 则新下标为 1xxxx 也就是 <span class="hljs-number">10000</span> + xxxx = 原来的capacity + 原位置<br>如果y = <span class="hljs-number">0</span> 则新下标不变, 为 xxxx<br></code></pre></td></tr></table></figure><blockquote><ul><li>这个设计非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点</li></ul></blockquote><h1 id="HashMap的put流程"><a href="#HashMap的put流程" class="headerlink" title="HashMap的put流程"></a>HashMap的put流程</h1><blockquote><ul><li>首先判断table是否为空或者length &#x3D; 0<blockquote><ul><li>如果是则进行扩容</li></ul></blockquote></li><li>通过key计算下标位置<blockquote><ul><li>如果node为空直接插入</li><li>如果node不为空(说明发生冲突) <blockquote><ul><li>如果为TreeNode则插入红黑树</li><li>如果为node则判断链表是否大于8, 小于8直接插入链表</li><li>大于8则进行树化</li></ul></blockquote></li></ul></blockquote></li><li>加入新元素后, 判断是否需要扩容, 然后结束<br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20HashMap%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/1.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="HashMap的线程安全问题"><a href="#HashMap的线程安全问题" class="headerlink" title="HashMap的线程安全问题"></a>HashMap的线程安全问题</h1><blockquote><ul><li>HashMap是线程不安全的</li><li>线程安全的hashmap为 <code>ConcurrentHashMap</code>, 或者<code>HashTable</code> (不常用)</li></ul></blockquote><p><strong>多线程下 put 会导致元素丢失</strong></p><blockquote><ul><li>多线程同时执行 put 操作时，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失</li></ul></blockquote><p><strong>put 和 get 并发时会导致 get 到 null</strong></p><blockquote><ul><li>线程 A 执行put时，因为元素个数超出阈值而出现扩容，线程B 此时执行get。当线程 A 执行完 table &#x3D; newTab 之后，线程 B 中的 table 此时也发生了变化，此时去 get 的时候就会 get 到 null 了，因为元素还没有迁移完成</li></ul></blockquote><p><strong>JDK1.7中头插法带来的死循环问题</strong></p><p><a href="https://blog.csdn.net/littlehaes/article/details/105241194">https://blog.csdn.net/littlehaes/article/details/105241194</a></p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 集合Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合 --- String, StringBuilder, StringBuffer</title>
    <link href="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20String,%20StringBuilder,%20StringBuffer/"/>
    <url>/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20String,%20StringBuilder,%20StringBuffer/</url>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><blockquote><ul><li>字符串对象,程序中定义””都是字符串对象,这个对象的使用频率最高.</li><li>字符串类 java.lang.String类,继承Object类,实现了三个接口.</li></ul></blockquote><h2 id="String的声明方式"><a href="#String的声明方式" class="headerlink" title="String的声明方式"></a>String的声明方式</h2><blockquote><ul><li>直接赋值: String s &#x3D; “hello world”  — 储存在常量池</li><li>调用构造器 String s &#x3D; new String(“hello world”) —- 储存在堆中的地址</li><li>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化, 为字符串开辟一个字符串常量池，类似于缓存区<blockquote><ul><li>直接赋值时，首先坚持字符串常量池是否存在该字符串. 所以如果再次创建一个 String ss &#x3D; “”hello world”. 将会和  s 指向同样的字符串常量<br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20String,%20StringBuilder,%20StringBuffer/1.png" alt="在这里插入图片描述"></li></ul></blockquote></li></ul></blockquote><h2 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h2><blockquote><ul><li>String类声明为final, 所以不能被继承</li><li>String类实际储存字符串数据的是类内部的成员变量  <code>final char [] value</code><blockquote><ul><li>因为value被final修饰, 所以value不能指向新的地址也就是不能再引用其他String变量</li></ul></blockquote></li><li>String 内部没有改变 value 数组的方法，也就是不能更改String中任何一个char 元素, 因此可以保证 String 不可变。</li></ul></blockquote><p>String不可变性的体现:  <strong>只要对string做出修改, 就会开辟新的内存空间</strong></p><blockquote><ul><li>1.当对字符串重新赋值时，会重新开辟新的内存空间储存新的字符串</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//常量池中会同时储存 &quot;hello world&quot; 和  &quot;hello&quot; , 而不是 &quot;hello world&quot; 被覆盖掉</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello world&quot;</span><br>s = <span class="hljs-string">&quot;hello&quot;</span> <br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> s;<br>         <br>    s = <span class="hljs-string">&quot;world&quot;</span>; <br>    <span class="hljs-type">String</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;  <br>         <br>    <span class="hljs-keyword">if</span> (ss == temp) &#123;<br>       <span class="hljs-comment">//注意这里对比的是地址, 说明ss和temp指向同样的地址</span><br>       <span class="hljs-comment">//也就是 &quot;hello&quot; 没有被world覆盖掉</span><br>        System.out.println(<span class="hljs-string">&quot;same&quot;</span>);<br>    &#125;<br>&#125;<br>output: <span class="hljs-string">&quot;same&quot;</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>2.当对现有的字符串进行连接操作时，会重新开辟新的内存空间储存拼接后的字符串</li><li>3.当调用String的<code>replace().</code> 或者 <code>substring()</code> 等方法修改指定字符或字符串时，也会重新开辟新的内存空间储存修改后的字符串</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">temp1</span> <span class="hljs-operator">=</span> s;<br>    <br>    s = s + <span class="hljs-string">&quot;world&quot;</span> ;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">temp2</span> <span class="hljs-operator">=</span> s;<br>         <br>    <span class="hljs-keyword">if</span> (temp1 != temp2) &#123;<br>        System.out.println(<span class="hljs-string">&quot;not same&quot;</span>);<br>    &#125;<br>&#125;<br><br>output: <span class="hljs-string">&quot;not same&quot;</span><br></code></pre></td></tr></table></figure><h2 id="对比两个String"><a href="#对比两个String" class="headerlink" title="对比两个String"></a>对比两个String</h2><blockquote><ul><li>使用 &#x3D;&#x3D; 对比两字符串时实际对比的是地址, 而不是实际内容</li><li>所以一律使用 <code>s1.equals(s2)</code> 或者 <code>s1.compareTo(s2)</code> 对比string</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    <br>    System.out.println(s == ss);<br>    System.out.println(s == sss);<br>    System.out.println(ss == sss);<br>&#125;<br><br>output:<br><span class="hljs-literal">true</span> <span class="hljs-comment">// 因为 直接赋值创建String时, JVM会首先在常量池中寻找是否已经有同样的字符串. 所以s和ss指向同样的地址</span><br><span class="hljs-literal">false</span> <span class="hljs-comment">//使用构造器创建String时, 地址会指向堆内存, 然后堆内存中的地址指向常量池, 所以不一样</span><br><span class="hljs-literal">false</span> <span class="hljs-comment">//同上</span><br><br></code></pre></td></tr></table></figure><p>Another example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">fun1</span><span class="hljs-params">(String s1)</span> &#123;<br>    <span class="hljs-keyword">return</span> s1;<br>    &#125;<br>      <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> fun1(s);<br>    <span class="hljs-comment">//因为s和ss都等于hello, 所以共用常量池中的字符串</span><br>    System.out.println(s == ss);<br>    &#125;<br>&#125;<br><br>ouput: <span class="hljs-literal">true</span><br><span class="hljs-comment">//但是如果在fun1中对s1进行任何修改, 如拼接等, 就会开辟新的内存空间, 则 s != ss</span><br></code></pre></td></tr></table></figure><p>Another Example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">ss</span> <span class="hljs-operator">=</span> s;<br><span class="hljs-comment">//此时ss和s指向同一个地址</span><br><br>s = <span class="hljs-string">&quot;World&quot;</span>;<br><span class="hljs-comment">//常量池中开辟了新的空间, s指向新的地址</span><br><br><span class="hljs-keyword">if</span> (ss == s) &#123;<br>System.out.println(<span class="hljs-string">&quot;same&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;not same&quot;</span>);<br>&#125;<br><br>System.out.println(s.hashCode());<br>System.out.println(ss.hashCode());<br><span class="hljs-comment">//s和ss指向不一样的地址, 所以not same</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>Another Example</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">(String s1)</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">newS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>System.out.println(newS == s1);<br><span class="hljs-comment">//答案是相等</span><br>   &#125;<br>     <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span> &#123;<br>   <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>   fun1(s);<br>   &#125;<br></code></pre></td></tr></table></figure><h1 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h1><blockquote><ul><li>如果代码中需要对string进行大量修改, 则推荐使用 StringBuilder类</li><li>StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象</li></ul></blockquote><p>Example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pathToStartValue</span><span class="hljs-params">(TreeNode node, <span class="hljs-type">int</span> startValue, String pathStart)</span> &#123;<br><span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>   <span class="hljs-keyword">return</span>;<br>   &#125;<br>       <br>   <span class="hljs-keyword">if</span> (node.val == startValue) &#123;<br>       pathTostartValue = pathStart;<br>       <span class="hljs-keyword">return</span>;<br>   &#125;<br>   <br>   <span class="hljs-comment">//这里pathStart + &quot;U&quot; 会生成新的String, 最后导致内存超限</span><br>   <span class="hljs-comment">//所以需要改用StringBuilder</span><br>   pathToStartValue(node.left, startValue, pathStart + <span class="hljs-string">&quot;U&quot;</span>);<br>   pathToStartValue(node.right, startValue, pathStart + <span class="hljs-string">&quot;U&quot;</span>);<br>       <br>   <span class="hljs-keyword">return</span>;     <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>StringBuilder提供对String的增删改查, 包括:</li></ul></blockquote><p><strong>append:</strong><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20String,%20StringBuilder,%20StringBuffer/2.png" alt="在这里插入图片描述"><br><strong>insert</strong><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20String,%20StringBuilder,%20StringBuffer/3.png" alt="在这里插入图片描述"><br><strong>setCharAt</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setCharAt</span><span class="hljs-params">(<span class="hljs-type">int</span> index, <span class="hljs-type">char</span> ch)</span><br><span class="hljs-comment">//The character at the specified index is set to ch.</span><br></code></pre></td></tr></table></figure><p><strong>delete</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder<span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span><br><span class="hljs-comment">//Removes the characters in a substring of this sequence.</span><br>StringBuilder<span class="hljs-title function_">deleteCharAt</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span><br><span class="hljs-comment">//Removes the char at the specified position in this sequence.</span><br></code></pre></td></tr></table></figure><p><strong>replace</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">StringBuilder<span class="hljs-title function_">replace</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, String str)</span><br><span class="hljs-comment">//Replaces the characters in a substring of this sequence with characters in the specified String.</span><br></code></pre></td></tr></table></figure><p><strong>substring</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">String<span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> start)</span><br><span class="hljs-comment">//Returns a new String that contains a subsequence of characters currently contained in this character sequence.</span><br>String<span class="hljs-title function_">substring</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span><br><span class="hljs-comment">//Returns a new String that contains a subsequence of characters currently contained in this sequence.</span><br></code></pre></td></tr></table></figure><h2 id="StringBuilder-和-StringBuffer-的区别"><a href="#StringBuilder-和-StringBuffer-的区别" class="headerlink" title="StringBuilder 和 StringBuffer 的区别"></a>StringBuilder 和 StringBuffer 的区别</h2><blockquote><ul><li>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</li></ul></blockquote><blockquote><ul><li>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 集合Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合 --- 如何遍历Map</title>
    <link href="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86Map/"/>
    <url>/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86Map/</url>
    
    <content type="html"><![CDATA[<blockquote><ul><li>Map没有继承Collection接口</li><li>AbstractMap和AbstractCollection是平级关系<br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86Map/1.png"></li></ul></blockquote><h2 id="Map的基本操作"><a href="#Map的基本操作" class="headerlink" title="Map的基本操作"></a>Map的基本操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> map;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * This program demonstrates the use of a map with key type String and value type Employee.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.12 2015-06-21</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Cay Horstmann</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>Map&lt;String, Employee&gt; staff = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>staff.put(<span class="hljs-string">&quot;144-25-5464&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Amy Lee&quot;</span>));<br>staff.put(<span class="hljs-string">&quot;567-24-2546&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Harry Hacker&quot;</span>));<br>staff.put(<span class="hljs-string">&quot;157-62-7935&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Gary Cooper&quot;</span>));<br>staff.put(<span class="hljs-string">&quot;456-62-5527&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Francesca Cruz&quot;</span>));<br><span class="hljs-comment">// print all entries</span><br>System.out.println(staff);<br><span class="hljs-comment">// remove an entry</span><br>staff.remove(<span class="hljs-string">&quot;567-24-2546&quot;</span>);<br><span class="hljs-comment">// replace an entry</span><br>staff.put(<span class="hljs-string">&quot;456-62-5527&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;Francesca Miller&quot;</span>));<br><span class="hljs-comment">// look up a value</span><br>System.out.println(staff.get(<span class="hljs-string">&quot;157-62-7935&quot;</span>));<br><span class="hljs-comment">// iterate through all entries</span><br>staff.forEach((k, v) -&gt; <br>System.out.println(<span class="hljs-string">&quot;key=&quot;</span> + k + <span class="hljs-string">&quot;, value=&quot;</span> + v));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="如何遍历Map"><a href="#如何遍历Map" class="headerlink" title="如何遍历Map"></a>如何遍历Map</h2><p><strong>the set of keys</strong>: 将所有的key作为一个set返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;K&gt; <span class="hljs-title function_">keySet</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;String&gt; keys = map.keySet();<br><span class="hljs-keyword">for</span> (String key : keys) &#123;<br><span class="hljs-keyword">do</span> something with key<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>the collection of values (which is not a set)</strong>: 将所有的value作为一个collection返回</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Collection&lt;V&gt; <span class="hljs-title function_">values</span><span class="hljs-params">()</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">Map&lt;String,String&gt; map=<span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       map.put(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>       map.put(<span class="hljs-string">&quot;efg&quot;</span>,<span class="hljs-string">&quot;456&quot;</span>);<br>       <span class="hljs-comment">// 使用增强型for遍历循环Map集合</span><br>       Collection&lt;String&gt; values = map.values();<br>       <span class="hljs-keyword">for</span> (String value : values) &#123;<br>           System.out.println(value);<br>       &#125;<br></code></pre></td></tr></table></figure><p><strong>the set of key&#x2F;value pairs</strong>: 得到每一对key value pair</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Employee&gt; entry : staff.entrySet()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> entry.getKey();<br><span class="hljs-type">Employee</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> entry.getValue();<br><span class="hljs-keyword">do</span> something with k, v<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Type-of-HashMap"><a href="#Type-of-HashMap" class="headerlink" title="Type of HashMap"></a>Type of HashMap</h2><p><strong>HashMap</strong></p><blockquote><ul><li>Hash table based implementation of the Map interface</li><li>the default load factor (.75)</li><li>有一个子类为LinkedHashMap, 元素按照加入顺序排序</li></ul></blockquote><p><strong>TreeMap</strong></p><blockquote><ul><li>A Red-Black tree based NavigableMap implementation.</li><li>需要根据compareTo排序</li></ul></blockquote><p><strong>EumerateHashMap</strong></p><blockquote><ul><li>A specialized Map implementation for use with enum type keys. </li><li>All of the keys in an enum map must come from a single enum type that is specified</li></ul></blockquote><p><strong>WeakHashMap</strong></p><blockquote><ul><li>Hash table based implementation of the Map interface, with weak keys.</li><li>An entry in a WeakHashMap will automatically be removed when its key is no longer in ordinary use</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 集合Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合 --- Comparable 和 Comparator</title>
    <link href="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Comparable%20%E5%92%8C%20Comparator/"/>
    <url>/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Comparable%20%E5%92%8C%20Comparator/</url>
    
    <content type="html"><![CDATA[<h1 id="Comparable-接口"><a href="#Comparable-接口" class="headerlink" title="Comparable 接口"></a>Comparable 接口</h1><blockquote><ul><li>comparable接口只有一个方法 — <code>compareTo(T o)</code><br><img src="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Comparable%20%E5%92%8C%20Comparator/1.png" alt="在这里插入图片描述"></li><li>一个类实现 Comparable 接口并重写 compareTo 方法就可以支持 <code>Collections.sort</code> 和 <code>Arrays.sort</code> 的排序</li><li>返回值 — 从小到大排序: <blockquote><ul><li>如果当前对象this大于形参对象obj，则返回正整数；</li><li>如果当前对象this小于形参对象obj，则返回负整数；</li><li>如果当前对象this等于参数对象obj，则返回零。</li></ul></blockquote></li><li>this - input   (从小到大排序) ,    input - this (从大到小排序)<blockquote><ul><li>example:   </li><li>从大到小 <code>p.getAge() - this.getAge()</code></li><li>从小到大 <code>this.getAge() - p.getAge()</code></li></ul></blockquote></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Person&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(<span class="hljs-type">int</span> id, <span class="hljs-type">int</span> age, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.age = age;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">//重写compareTo, 使用 `Collections.sort` 和 `Arrays.sort` 的时候就可以根据年龄从大到小排序</span><br>    <span class="hljs-comment">//如果从小到大排序, 则 this.getAge() - p.getAge();</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Person p)</span> &#123;<br>        <span class="hljs-keyword">return</span> p.getAge() - <span class="hljs-built_in">this</span>.getAge();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparableExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">2</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&quot;MySQL&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&quot;Redis&quot;</span>);<br>        List&lt;Person&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(p1);<br>        list.add(p2);<br>        list.add(p3);<br>        <span class="hljs-comment">// 进行排序操作(根据 Person 类中 compareTo 中定义的排序规则)</span><br>        Collections.sort(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Another example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//指明商品比较大小的方法，按照价格从低到高,如果价格相同，按照产品名称从低到高</span><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Goods)&#123;<br>            Goods goods=(Goods) o;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.price&gt;goods.price)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.price&lt;goods.price)&#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">//价格相同,按照产品名称从低到高比较</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.compareTo(goods.name);<br>     &#125;<br></code></pre></td></tr></table></figure><h1 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h1><blockquote><ul><li>comparatro接口包含很多方法,  其中排序的方法是 <code>compare(T o1, T o2)</code></li><li>默认为从小到大排序，用参数o1减参数o2。若需要从大到小排序，则用参数o2减参数o1</li><li>重写Comparator接口有三种方法<blockquote><ul><li>使用内部静态类</li><li>使用内部匿名类</li><li>使用lambda表达式</li></ul></blockquote></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">使用内部静态类<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorExample</span> &#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 用于 Person 类的比较器</span><br><span class="hljs-comment">  */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Person&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Person p1, Person p2)</span> &#123;<br>        <span class="hljs-keyword">return</span> p2.getAge() - p1.getAge();<br>    &#125;<br>&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">1</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;Java&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">2</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&quot;MySQL&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-string">&quot;Redis&quot;</span>);<br>        <span class="hljs-comment">// 添加对象到集合</span><br>        List&lt;Person&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        list.add(p1);<br>        list.add(p2);<br>        list.add(p3);<br>        <span class="hljs-comment">// 进行排序操作(根据 PersonComparator 中定义的排序规则)</span><br>        Collections.sort(list, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PersonComparator</span>());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="重写Comparator-—-Arrays-sort"><a href="#重写Comparator-—-Arrays-sort" class="headerlink" title="重写Comparator — Arrays.sort()"></a>重写Comparator — Arrays.sort()</h2><blockquote><ul><li>重写comparator使Arrays.sort可以对二维数组从小到大排序</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//内部匿名类</span><br>Arrays.sort(nums, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;<span class="hljs-type">int</span>[]&gt;() &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(<span class="hljs-type">int</span>[] a, <span class="hljs-type">int</span>[] b)</span>&#123;<br><span class="hljs-keyword">if</span>(a[<span class="hljs-number">0</span>]==b[<span class="hljs-number">0</span>])&#123;<br><span class="hljs-keyword">return</span> a[<span class="hljs-number">1</span>] - b[<span class="hljs-number">1</span>];<br>&#125;<span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>&#125;<br>&#125;<br>&#125;);<br><span class="hljs-comment">//lambda表达式</span><br> Arrays.sort(intervals,(<span class="hljs-type">int</span> [] o1, <span class="hljs-type">int</span> [] o2)-&gt;&#123;<br>            <span class="hljs-keyword">return</span>  o1[<span class="hljs-number">0</span>]-o2[<span class="hljs-number">0</span>];<br>        &#125;);<br></code></pre></td></tr></table></figure><h2 id="重写Comparator-—-PriorityQueue"><a href="#重写Comparator-—-PriorityQueue" class="headerlink" title="重写Comparator  — PriorityQueue()"></a>重写Comparator  — PriorityQueue()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> num;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> freq;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span> freq)</span> &#123;<br>            <span class="hljs-built_in">this</span>.num = num;<br>            <span class="hljs-built_in">this</span>.freq = freq;<br>        &#125;<br>    &#125;<br>    <br> <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] topKFrequent(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">//重写heap的comparator, heap将根据freq从大到小排序</span><br>        <span class="hljs-comment">//内部匿名类</span><br>        PriorityQueue&lt;Node&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Node&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Node o1, Node o2)</span> &#123;<br>                <span class="hljs-keyword">return</span> o2.freq - o1.freq;<br>            &#125;<br>        &#125;);<br>        <br><span class="hljs-comment">//lambda表达式</span><br>PriorityQueue&lt;Integer&gt; priorityQueue2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((Integer o1, Integer o2) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> o2 - o1;<br>     &#125;);<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><h1 id="Comparable-和-Comparator的区别"><a href="#Comparable-和-Comparator的区别" class="headerlink" title="Comparable 和 Comparator的区别"></a>Comparable 和 Comparator的区别</h1><blockquote><ul><li>使用 Comparable 必须要修改原有的类，也就是你要排序那个类，就要在那个中实现 Comparable 接口并重写 compareTo 方法</li><li>而 Comparator 的使用则不相同，Comparator 无需修改原有类。也就是在最极端情况下，即使 Person 类是第三方提供的，我们依然可以通过创建新的自定义比较器 Comparator，来实现对第三方类 Person 的排序功能。也就是说通过 Comparator 接口可以实现和原有类的解耦，在不修改原有类的情况下实现排序功能，</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 集合Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合 --- Array和List互相转换</title>
    <link href="/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Array%E5%92%8CList%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/"/>
    <url>/2024/04/26/Java%20%E9%9B%86%E5%90%88%20---%20Array%E5%92%8CList%E4%BA%92%E7%9B%B8%E8%BD%AC%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="List-转-Array"><a href="#List-转-Array" class="headerlink" title="List 转 Array"></a>List 转 Array</h1><p>使用toArray方法只能返回 Object [] 数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>Object [] array = nums.toArray();<br></code></pre></td></tr></table></figure><p>而强制转型会出现异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] temp = (Integer[])nums.toArray();<br>class [Ljava.lang.Object; cannot be cast to class [Ljava.lang.Integer;<br></code></pre></td></tr></table></figure><p>可以使用以下方式进行指定类型转换, 但是注意只能返回引用类型<br>如下，如果是 int [] temp 就会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Integer[] temp = nums.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[nums.size()]);<br><span class="hljs-comment">//int [] temp = nums.toArray(new Integer[nums.size()]); 会报错</span><br></code></pre></td></tr></table></figure><p>Integer 数组转化成i int 数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test05</span><span class="hljs-params">()</span> &#123;<br>    Integer[] arr = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>&#125;;<br>    <span class="hljs-comment">//先将Integer[]转成Stream&lt;Integer&gt;，再转成IntStream</span><br>    <span class="hljs-type">int</span>[] res = Arrays.stream(arr).mapToInt(Integer::valueOf).toArray();<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Array-转-List"><a href="#Array-转-List" class="headerlink" title="Array 转 List"></a>Array 转 List</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//注意这里必须是 Integer 因为list只能用引用类型</span><br>Integer [] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[] &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">45</span>&#125;;<br>List&lt;Integer&gt; list = Arrays.asList(array);<br></code></pre></td></tr></table></figure><h1 id="包装类数组和基本类型数组互相转换"><a href="#包装类数组和基本类型数组互相转换" class="headerlink" title="包装类数组和基本类型数组互相转换"></a>包装类数组和基本类型数组互相转换</h1><p><strong>Integer数组转成int数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test05</span><span class="hljs-params">()</span> &#123;<br>    Integer[] arr = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>&#125;;<br>    <span class="hljs-comment">//先将Integer[]转成Stream&lt;Integer&gt;，再转成IntStream</span><br>    <span class="hljs-type">int</span>[] res = Arrays.stream(arr).mapToInt(Integer::valueOf).toArray();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>int数组转成Integer数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test06</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">12</span>,<span class="hljs-number">13</span>,<span class="hljs-number">15</span>&#125;;<br>    <span class="hljs-comment">//先将int[]装成intStream，然后使用boxed()进行装箱，得到Stream(Integer)</span><br>    <span class="hljs-comment">//然后使用Stream的toArray，传入IntFunction&lt;A[]&gt; generator，返回Integer[]</span><br>    Integer[] res = Arrays.stream(arr).boxed().toArray(Integer[]::<span class="hljs-keyword">new</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 集合Collection</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 创建线程,  线程状态</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B,%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B,%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="如何创建线程"><a href="#如何创建线程" class="headerlink" title="如何创建线程"></a>如何创建线程</h1><h2 id="使用Thread类"><a href="#使用Thread类" class="headerlink" title="使用Thread类"></a>使用Thread类</h2><blockquote><ul><li>创建一个类继承Thread类</li><li>重写该接口的run()方法，该run()方法的方法体是该线程的线程执行体</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SimpleThread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//重写run方法, 具体业务逻辑的实现</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>System.out.println(<span class="hljs-string">&quot;Hello: &quot;</span> + count);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>count++;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//创建Cat对象，可以当做线程使用</span><br>        <span class="hljs-type">SimpleThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleThread</span>();<br>        <span class="hljs-comment">//启动线程</span><br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用Runnable接口"><a href="#使用Runnable接口" class="headerlink" title="使用Runnable接口"></a>使用Runnable接口</h2><blockquote><ul><li>创建一个类实现Runnable接口, 并重写该接口的run()方法，该run()方法的方法体同样是该线程的线程执行体。</li><li>创建Runnable实现类的实例, 然后使用Runnable实例创建一个Thread实例,</li><li>调用Thread实例的start方法开始线程<br><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B,%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/1.png"></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SimpleThread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRunnable</span> &#123;<br><br><span class="hljs-comment">//创建一个类实现Runnable接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskOne</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//重写该接口的run()方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>count++;<br>System.out.println(<span class="hljs-string">&quot;taskOne: &quot;</span> + count);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">500</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>&#125;<br><br>&#125;<br><span class="hljs-comment">//创建一个类实现Runnable接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskTwo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//重写该接口的run()方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>count++;<br>System.out.println(<span class="hljs-string">&quot;taskTwo: &quot;</span> + count);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//创建Runnable实现类的实例</span><br><span class="hljs-type">TaskOne</span> <span class="hljs-variable">taskOne</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskOne</span>();<br><span class="hljs-type">TaskTwo</span> <span class="hljs-variable">taskTwo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskTwo</span>();<br><span class="hljs-comment">//使用Runnable实例创建Thread实例</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(taskOne);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(taskTwo);<br><span class="hljs-comment">//调用Thread实例的start方法开始线程</span><br>t1.start();<br>t2.start();<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用Runnable接口和继承Thread类的区别-continue"><a href="#使用Runnable接口和继承Thread类的区别-continue" class="headerlink" title="使用Runnable接口和继承Thread类的区别 (continue)"></a>使用Runnable接口和继承Thread类的区别 (continue)</h2><p>使用Runnable接口</p><blockquote><ul><li>优点<blockquote><ul><li>使用Runnable接口的类还可以继承其他类</li><li>多个线程可以共享一个target对象</li></ul></blockquote></li><li>缺点<blockquote><ul><li>编程稍微复杂, 比如要访问当前线程, 则必须使用Thread.currentThread()方法</li></ul></blockquote></li></ul></blockquote><p>继承Thread类</p><blockquote><ul><li>优点<blockquote><p>编写简单, 比如需要访问当前线程,则直接使用this</p></blockquote></li><li>缺点<blockquote><p>因为已经继承了Thread类, 则不能继承其他父类</p></blockquote></li></ul></blockquote><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><h2 id="New-Threads"><a href="#New-Threads" class="headerlink" title="New Threads"></a>New Threads</h2><blockquote><ul><li>当用new符号创建线程时, 比如 <code>new Thread(r)</code>. 这个线程还不在运行状态, 而属于new threads.</li><li>在这个阶段, 会进行线程的资源分配</li></ul></blockquote><h2 id="Runnable-Threads"><a href="#Runnable-Threads" class="headerlink" title="Runnable Threads"></a>Runnable Threads</h2><blockquote><ul><li>当一个thread调用statr方法时, 这个线程处于 <code>runnable</code> 状态</li><li>一个runnable状态的线程可能在也可能不在运行, 取决于操作系统有没有让这个线程运行</li><li><strong>Java specification 没有区分 running和runnable, 一个running thread依然是runnable state</strong></li><li><strong>Always keep in mind that a runnable thread may or may not be running at any given time</strong></li></ul></blockquote><h2 id="Blocked-and-Waiting-Threads"><a href="#Blocked-and-Waiting-Threads" class="headerlink" title="Blocked and Waiting Threads"></a>Blocked and Waiting Threads</h2><blockquote><ul><li>阻塞状态（Blocked） 阻塞状态是线程因为某种原因放弃CPU使用权，进行上下文切换, 暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<blockquote><ul><li>等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。</li><li>同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入Entry Set中. </li><li>其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I&#x2F;O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</li></ul></blockquote></li></ul></blockquote><h2 id="Terminated-Threads"><a href="#Terminated-Threads" class="headerlink" title="Terminated Threads"></a>Terminated Threads</h2><blockquote><ul><li>It dies a natural death because the run method exits normally. (包括使用interrupt)</li><li>It dies abruptly because an uncaught exception terminates the run method</li></ul></blockquote><p><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B,%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/2.png"></p><h1 id="线程优先级-Thread-Priorities"><a href="#线程优先级-Thread-Priorities" class="headerlink" title="线程优先级 Thread Priorities"></a>线程优先级 Thread Priorities</h1><blockquote><ul><li>每一个线程都有优先级</li><li>一个线程默认继承父类线程的优先级, 但是也可以通过<code>setPriority</code>设置线程优先级. From <code>MIN_PRIORITY</code> (数值为1) to <code>NORM_PRIORITY</code> (数值为5)</li><li>当scheduler选择线程时, 优先选择优先级高的线程.</li><li><strong>线程优先级根据系统不同也会有改变. Java虚拟机会根据host操作系统改变对应的系统优先级, 比如Windows有7个优先级, 有些Java的优先级会有一样的操作系统优先级. In the Oracle JVM for Linux, thread priorities are ignored altogether—all threads have the same priority</strong></li><li>如果有几个线程的优先级很高, 则低优先级的线程可能会处于饥饿状态</li><li><strong>所以不要将程序的正确性依赖于线程优先级.</strong><br><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B,%20%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81/3.png"></li></ul></blockquote><h1 id="守护线程-Daemon-Thread"><a href="#守护线程-Daemon-Thread" class="headerlink" title="守护线程  Daemon Thread"></a>守护线程  Daemon Thread</h1><blockquote><ul><li>当一个线程的唯一作用是服务于其他线程时, 比如timer thread给其他线程发送”timer ticks” , 这个线程被叫做Daemon Thread.</li><li>可以通过<code>t.setDaemon(true)</code>将一个线程设置为Daemon Thread</li><li>当只有daemon thread 存在时, JVM会自动退出.</li><li>不要让Daemon Thread使用persistent resource, 比如数据或者文件. 因为daemon thread可能随时被终止.</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 终止线程 Terminate Threads</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%20Terminate%20Threads/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%20Terminate%20Threads/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要终止线程"><a href="#为什么要终止线程" class="headerlink" title="为什么要终止线程"></a>为什么要终止线程</h1><blockquote><ul><li>线程消耗资源(包括内存,内核, CPU等资源). </li><li>只有当一个Java程序的所有线程都运行结束的时候，一个 Java 程序才算运行结束.</li><li>所以当一个线程不再被需要使用时或者运行不正常时需要清理掉.</li></ul></blockquote><blockquote><ul><li>下面代码中, 即使main方法已经运行完毕, 但是整个程序还是等待 BlockingTask运行结束.</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingTask</span>());<br><br>        thread.start();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">//do things</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">500000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Existing blocking thread&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="终止线程的方法"><a href="#终止线程的方法" class="headerlink" title="终止线程的方法"></a>终止线程的方法</h1><h2 id="return"><a href="#return" class="headerlink" title="return()"></a>return()</h2><blockquote><ul><li>当一个线程的<code>run</code>方法执行<code>return</code>语句时, 线程会自动结束</li></ul></blockquote><h2 id="stop"><a href="#stop" class="headerlink" title="stop()"></a>stop()</h2><blockquote><ul><li>再以前的版本中, 使用stop和suspend可以立即结束一个线程</li><li>但是已经被废弃, 因为直接中断的方式，并没有让线程留下存储数据的时间，这也极容易导致线程的数据丢失或不一致性的问题</li></ul></blockquote><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><blockquote><ul><li>java并没有提供任何机制来安全的停止线程，只提供了中断（interruption），这其实是一种协作机制，让一个线程去通知另外一个线程停止当前的工作。</li><li>interrupt方法不是直接终止线程, 而是给目标线程发送一个中断信号，如果目标线程没有接收线程中断的信号并结束线程，线程则不会终止，具体是否退出或者执行其他逻辑由目标线程决定. </li><li>When the interrupt method is called on a thread, the interrupted status of the thread is set. This is a boolean flag that is present in every thread.</li></ul></blockquote><p><strong>interrupt() 和 isInterrupted()</strong></p><blockquote><ul><li>可以使用<code>interrupt()</code> 和 <code>isInterrupted()</code>从一个线程中断另一个线程并查看目前线程是否被中断</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.math.BigInteger;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main2</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LongComputationTask</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(<span class="hljs-string">&quot;200000&quot;</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">BigInteger</span>(<span class="hljs-string">&quot;100000000&quot;</span>)));<br><br>        thread.start();<br>        <span class="hljs-comment">//中断thread线程</span><br>        thread.interrupt();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LongComputationTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-keyword">private</span> BigInteger base;<br>        <span class="hljs-keyword">private</span> BigInteger power;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">LongComputationTask</span><span class="hljs-params">(BigInteger base, BigInteger power)</span> &#123;<br>            <span class="hljs-built_in">this</span>.base = base;<br>            <span class="hljs-built_in">this</span>.power = power;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(base + <span class="hljs-string">&quot;^&quot;</span> + power + <span class="hljs-string">&quot; = &quot;</span> + pow(base, power));<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> BigInteger <span class="hljs-title function_">pow</span><span class="hljs-params">(BigInteger base, BigInteger power)</span> &#123;<br>            <span class="hljs-type">BigInteger</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> BigInteger.ONE;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">BigInteger</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> BigInteger.ZERO; i.compareTo(power) != <span class="hljs-number">0</span>; i = i.add(BigInteger.ONE)) &#123;<br>                <br>                <span class="hljs-comment">// 查看目前线程是否被中断, 以及做出相应处理</span><br>                <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Prematurely interrupted computation&quot;</span>);<br>                    <span class="hljs-keyword">return</span> BigInteger.ZERO;<br>                &#125;<br>                result = result.multiply(base);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="InterruptedException"><a href="#InterruptedException" class="headerlink" title="InterruptedException"></a>InterruptedException</h1><blockquote><ul><li>当线程处于阻塞状态时(比如sleep和wait), 线程无法使用<code>isInterrupted()</code>查看是否收到中断信号, 此时需要<code>InterruptedException</code></li><li><code>InterruptedException</code>会结束线程的阻塞状态</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br> <span class="hljs-keyword">try</span><br> &#123;<br>  . . .<br> <span class="hljs-keyword">while</span> (more work to <span class="hljs-keyword">do</span>)<br> &#123;<br><span class="hljs-comment">//do more work</span><br> Thread.sleep(delay);<br> &#125;<br> &#125;<br> <span class="hljs-keyword">catch</span>(InterruptedException e) &#123;<br> <span class="hljs-comment">// thread was interrupted during sleep</span><br> &#125;<br> <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-comment">//cleanup, if required</span><br> &#125;<br> <span class="hljs-comment">// exiting the run method terminates the thread</span><br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><ul><li>当InterruptedException被抛出后, Interrupt status会被清除</li><li>下面代码就中断失败, 因为当InterruptedException被抛出后, Interrupt status被清除. 代码进入不到if语句</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 响应中断</span><br>            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;青秧线程被中断，程序退出。&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;青秧线程休眠被中断，程序退出。&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    thread.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>中断成功: 在catch中加入Thread.currentThread().interrupt(). 重新设置中断状态.</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 响应中断</span><br>            <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;青秧线程被中断，程序退出。&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;青秧线程休眠被中断，程序退出。&quot;</span>);<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;<br>    &#125;);<br>    thread.start();<br>    Thread.sleep(<span class="hljs-number">2000</span>);<br>    thread.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用sleep时, 不要在底层代码中处理InterruptException</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassInterrupt</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;go&quot;</span>);<br>            throwInMethod();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwInMethod</span><span class="hljs-params">()</span>  &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">PassInterrupt</span>());<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%20Terminate%20Threads/1.png" alt="在这里插入图片描述"></p><blockquote><ul><li>因为throwInMethod存在于底层方法中，如果在其中进行try&#x2F;catch顶层方法可能无法感知，导致该中断被遗漏.</li></ul></blockquote><p><strong>正确方式: 将exception抛给顶层方法处理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PassInterrupt</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;go&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                throwInMethod();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-comment">//保存日志/停止程序等操作</span><br>                System.out.println(<span class="hljs-string">&quot;日志已经保存&quot;</span>);<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwInMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>         Thread.sleep(<span class="hljs-number">2000</span>);<br>        <span class="hljs-comment">//不在这里try/catch 是因为在这里的代码层次很深，run在较高层次，而throwInMethod较低层次</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        Thread thread=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">PassInterrupt</span>());<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>isInterrupt() 和 interrupted的区别</strong> (注意是interrupted不是interrupt)</p><blockquote><ul><li>The <code>interrupted</code> method is a static method that checks whether the current thread has<br>been interrupted. <strong>Furthermore, calling the interrupted method clears the interrupted<br>status of the thread.</strong> </li><li><code>isInterrupted</code> method is an instance method that you can use to check whether any thread has been interrupted.<br><strong>Calling it does not change the interrupted status.</strong></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 多线程的相关概念</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>背景: <a href="https://blog.csdn.net/weixin_38803409/article/details/120763089">操作系统 — 线程&#x2F;进程 同步</a></p><h1 id="Race-Condition-问题"><a href="#Race-Condition-问题" class="headerlink" title="Race Condition 问题"></a>Race Condition 问题</h1><blockquote><ul><li>下面的代码会创建100个银行账户,每一个账户初始金额是1000. 然后不段的随机给另外一个账户转钱.</li><li>不管怎么转钱, 100个账户的总金额应该一直保持为10000. </li><li>但是有的输出结果总金额不到10000, 因为出现了对critical section资源竞争的问题</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SimpleThread;<br><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span>[] accounts;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Bank</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">double</span> initialBalance)</span> &#123;<br>accounts = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[n];<br>Arrays.fill(accounts, initialBalance);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">double</span> amount)</span> &#123;<br><span class="hljs-keyword">if</span> (accounts[from] &lt; amount) <span class="hljs-keyword">return</span>;<br>System.out.print(Thread.currentThread());<br>accounts[from] -= amount;<br>System.out.printf(<span class="hljs-string">&quot; %10.2f from %d to %d&quot;</span>, amount, from, to);<br>accounts[to] += amount;<br>System.out.printf(<span class="hljs-string">&quot; Total Balance: %10.2f%n&quot;</span>, getTotalBalance());<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTotalBalance</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">double</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">double</span> a : accounts)<br>sum += a;<br><br><span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> accounts.length;<br>&#125;<br> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SimpleThread;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsynchBankTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NACCOUNTS</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">INITIAL_BALANCE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">MAX_AMOUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DELAY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>&#123;<br><span class="hljs-type">Bank</span> <span class="hljs-variable">bank</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bank</span>(NACCOUNTS, INITIAL_BALANCE);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; NACCOUNTS; i++) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">fromAccount</span> <span class="hljs-operator">=</span> i;<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">toAccount</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (bank.size() * Math.random());<br><span class="hljs-type">double</span> <span class="hljs-variable">amount</span> <span class="hljs-operator">=</span> MAX_AMOUNT * Math.random();<br>bank.transfer(fromAccount, toAccount, amount);<br>Thread.sleep((<span class="hljs-type">int</span>) (DELAY * Math.random()));<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><br>&#125;<br>&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>t.start();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/1.png" alt="在这里插入图片描述"></p><blockquote><ul><li>因为 <code>accounts[to] += amount;</code> 和 <code>accounts[from] -= amount;</code>不是原子操作, 也就是此行代码分为三条指令<blockquote><ul><li>step1: 将accounts[i] 放入寄存器</li><li>step2: 将amount增加或者减少</li><li>step3: 将结果放回accounts[i]</li></ul></blockquote></li><li>假设线程1执行完前两步之后被打断, 线程2执行全部三个步骤, 然后线程1继续执行第三步, 则线程2的数据会被线程1的第三步覆盖</li></ul></blockquote><p><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/2.png" alt="在这里插入图片描述"></p><h1 id="并发编程的性质-—-原子性-可见性-有序性"><a href="#并发编程的性质-—-原子性-可见性-有序性" class="headerlink" title="并发编程的性质 — 原子性, 可见性, 有序性"></a>并发编程的性质 — 原子性, 可见性, 有序性</h1><p><strong>原子性</strong></p><blockquote><ul><li>一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。比如上面的例子就没有保证原子性</li></ul></blockquote><blockquote><ul><li>注意: 原子操作 + 原子操作 !&#x3D; 原子操作</li><li>如下: 如果a是原子操作, b也是原子操作 但是 a + b 不是原子操作</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>在 Java 语言中, 除去 long 类型和double 类型, 剩下所有类型 (包括基础类型和引用类型) 的 写(write) 操作都是原子操作.<blockquote><ul><li>写入是原子操作: byte, boolean, short, char, float, int 和其他引用操作</li><li>写入不是原子操作: long, double</li></ul></blockquote></li><li>在 Java 语言中, 所有类型的读取操作都是原子操作</li></ul></blockquote><p><strong>可见性</strong><br><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/3.png" alt="在这里插入图片描述"></p><blockquote><ul><li>由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间）<blockquote><ul><li>工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存</li><li>主内存是共享内存区域，所有线程都可以访问.</li></ul></blockquote></li><li>线程对变量的操作（读取赋值等）必须在工作内存中进行<blockquote><ul><li>首先要将变量从主内存拷贝到自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写会主内存</li><li>不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间的通信（传值）必须通过主内存来完成</li></ul></blockquote></li><li>当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改, 这个就是可见性</li></ul></blockquote><p><strong>有序性</strong></p><blockquote><ul><li>当发生指令重排时, 线程就失去了有序性</li><li>在源代码顺序与程序执行顺序不一致的情况下, 就发生了指令重排序</li><li>编译器出于性能的考虑, 在其认为不影响程序正确性的情况下可能会对源代码顺序进行调整, 从而造成程序顺序与相应的源代码顺序不一致.</li></ul></blockquote><h1 id="上下文切换-Context-Switch"><a href="#上下文切换-Context-Switch" class="headerlink" title="上下文切换 (Context Switch)"></a>上下文切换 (Context Switch)</h1><blockquote><ul><li>当线程切入和切出操作系统的时候需要保存和恢复相应的线程的进度信息(如程序运行到什么程度了,计算的中间结果以及执行到了哪条指令) </li><li>这个进度的信息被称为上下文 (Context). 切换的过程叫做上下文切换(Context Switch)</li><li>一个线程的生命周期状态在 Runnable 状态 与 非Runnable状态之 (包括Blocked,  Waiting) 之间切换的过程就是一个上下文切换的过程</li></ul></blockquote><p><strong>上下文切换的原因 包括主动切换和被动切换</strong></p><blockquote><ul><li>主动切换的原因包括以下<blockquote><ul><li>Thread.sleep</li><li>Object.wait()</li><li>Thread.yield()</li><li>Thread.join()</li><li>等</li></ul></blockquote></li><li>被动切换的原因包括<blockquote><ul><li>线程的时间片用完</li><li>优先级低的线程被优先级高的线程切换</li><li>Java虚拟机也会导致被动上下文切换, 因为垃圾回收器可能需要暂停所有线程才能完成垃圾回收</li></ul></blockquote></li></ul></blockquote><h1 id="线程的一些故障-—-死锁-活锁-饥饿"><a href="#线程的一些故障-—-死锁-活锁-饥饿" class="headerlink" title="线程的一些故障 — 死锁, 活锁, 饥饿"></a>线程的一些故障 — 死锁, 活锁, 饥饿</h1><h2 id="死锁-Deadlock"><a href="#死锁-Deadlock" class="headerlink" title="死锁 (Deadlock)"></a>死锁 (Deadlock)</h2><blockquote><ul><li>死锁: 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</li></ul></blockquote><blockquote><ul><li>死锁的发生条件: <blockquote><ul><li>当前进程或线程拥有其他进程或线程需要的资源</li><li>当前进程或线程等待其他进程或线程已拥有的资源</li><li>都不放弃自己拥有的资源,也就是不能被其他进程或线程剥夺，只能在使用完以后由自己释放</li></ul></blockquote></li></ul></blockquote><p><strong>Example 1:</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c">mutex m<br>function &#123;<br>lock(m) <span class="hljs-comment">//成功拿到锁</span><br>lock(m) <span class="hljs-comment">//拿不到锁，因为已经被自己拿了，所以会无限等待下去</span><br><span class="hljs-comment">//critical section</span><br>unlock(m)<br>unlock(m)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Example 2:</strong><br><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/4.png" alt="在这里插入图片描述"></p><blockquote><ul><li>task A成功拿到M1的锁，同时task B成功拿到M2的锁</li><li>task A等待获取M2的锁，同时task B等待获取M1的锁<blockquote><ul><li>task A只有获得M2的锁才能往下继续然后释放M1的锁</li><li>task B只有获得M1的锁才能往下继续然后释放M2的锁</li></ul></blockquote></li></ul></blockquote><h2 id="活锁-Livelock"><a href="#活锁-Livelock" class="headerlink" title="活锁(Livelock)"></a>活锁(Livelock)</h2><blockquote><ul><li>活锁是不同线程占用对方所需要的资源, 导致任何线程都无法继续向前运行, 但是没有一个线程处于block状态. 而每个线程一遍又一遍的不断尝试获取资源并不断消耗CPU资源.</li></ul></blockquote><p>  <strong>Example 1:</strong></p><blockquote><ul><li>一个系统可以运行的进程总量由process table有多少个entry决定. </li><li>如果一个process table满了会导致一个进程fork子进程失败. 而失败以后父进程不会进入阻塞状态, 而是等待一段时间后再次fork子进程. </li><li>假设一个系统有100个entry. 10个父进程需要各创建12个子进程, 当新创建90个进程之后, process table被占满. 而10个父进程会不断的重新fork子进程.</li></ul></blockquote><p><strong>Example 2:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonResource</span> &#123;<br>    <span class="hljs-keyword">private</span> Worker owner;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CommonResource</span> <span class="hljs-params">(Worker d)</span> &#123;<br>        owner = d;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Worker <span class="hljs-title function_">getOwner</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> owner;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOwner</span> <span class="hljs-params">(Worker d)</span> &#123;<br>        owner = d;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> active;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Worker</span> <span class="hljs-params">(String name, <span class="hljs-type">boolean</span> active)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.active = active;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isActive</span> <span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> active;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">work</span> <span class="hljs-params">(CommonResource commonResource, Worker otherWorker)</span> &#123;<br>        <span class="hljs-keyword">while</span> (active) &#123;<br>            <span class="hljs-comment">// wait for the resource to become available.</span><br>            <span class="hljs-keyword">if</span> (commonResource.getOwner() != <span class="hljs-built_in">this</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    wait(<span class="hljs-number">10</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                   <span class="hljs-comment">//ignore</span><br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// If other worker is also active let it do it&#x27;s work first</span><br>            <span class="hljs-keyword">if</span> (otherWorker.isActive()) &#123;<br>                System.out.println(getName() +<br>                            <span class="hljs-string">&quot; : handover the resource to the worker &quot;</span> +<br>                                                       otherWorker.getName());<br>                commonResource.setOwner(otherWorker);<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//now use the commonResource</span><br>            System.out.println(getName() + <span class="hljs-string">&quot;: working on the common resource&quot;</span>);<br>            active = <span class="hljs-literal">false</span>;<br>            commonResource.setOwner(otherWorker);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Livelock</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span> <span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Worker</span> <span class="hljs-variable">worker1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;Worker 1 &quot;</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Worker</span> <span class="hljs-variable">worker2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&quot;Worker 2&quot;</span>, <span class="hljs-literal">true</span>);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">CommonResource</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommonResource</span>(worker1);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            worker1.work(s, worker2);<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            worker2.work(s, worker1);<br>        &#125;).start();<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><blockquote><ul><li>以上代码当两个线程都是active时, 会互相谦让对方, 然后不断重新尝试, 进入livelock</li></ul></blockquote><p>output:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">Worker <span class="hljs-number">1</span>  : handing over the resource to the worker: Worker <span class="hljs-number">2</span><br>Worker <span class="hljs-number">2</span> : handing over the resource to the worker: Worker <span class="hljs-number">1</span><br>Worker <span class="hljs-number">1</span>  : handing over the resource to the worker: Worker <span class="hljs-number">2</span><br>Worker <span class="hljs-number">2</span> : handing over the resource to the worker: Worker <span class="hljs-number">1</span><br>Worker <span class="hljs-number">1</span>  : handing over the resource to the worker: Worker <span class="hljs-number">2</span><br>Worker <span class="hljs-number">2</span> : handing over the resource to the worker: Worker <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="死锁和活锁的区别"><a href="#死锁和活锁的区别" class="headerlink" title="死锁和活锁的区别"></a>死锁和活锁的区别</h2><blockquote><ul><li>活锁和死锁非常的像, 都是线程互相持有自己所需要的资源导致程序不能正常往下运行</li><li>区别是死锁的线程会进入等待状态, 也就是block状态</li><li>而活锁的进程不会进入等待状态, 而是会不断的尝试运行, 不断的消耗CPU资源.</li></ul></blockquote><h2 id="饥饿-Starvation"><a href="#饥饿-Starvation" class="headerlink" title="饥饿(Starvation)"></a>饥饿(Starvation)</h2><blockquote><ul><li>是指一个可运行的进程尽管能继续执行，但被调度器无限期地忽视，而不能被调度执行的情况</li></ul></blockquote><p><strong>Example:</strong></p><blockquote><ul><li>如果进程按照优先级运行, 也就是先运行高优先级的进程</li><li>那么如果一直有新的高优先级的进程被创建, 则低优先级的进程永远不会被执行, 进入饥饿状态</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 锁的概念和类型划分</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="锁的概念"><a href="#锁的概念" class="headerlink" title="锁的概念"></a>锁的概念</h1><blockquote><ul><li>锁可以将多个线程对共享数据的并发访问转换为串行访问, 这样一个共享数据一次只能被一个线程访问, 该线程访问结束后其他线程才能对其进行访问.</li><li>锁具有排他性 (Exclusive), 即一个锁一次只能被一个线程持有. 所以这种锁被称为排他锁或者互斥锁 (Mutex).</li></ul></blockquote><h1 id="锁可以保证-—-原子性-可见性-有序性"><a href="#锁可以保证-—-原子性-可见性-有序性" class="headerlink" title="锁可以保证 — 原子性, 可见性, 有序性"></a>锁可以保证 — 原子性, 可见性, 有序性</h1><p><strong>原子性</strong></p><blockquote><ul><li>锁是通过互斥保障原子性的。所谓至斥(Mutual Exclusion), 就是指一个锁一次只能被一个线程持有。因此一个线程持有一个锁的时候，其他线程无法获得该锁，而只能等待其释放该锁后再申请。这就保证了临界区代码一次只能够被一个线程执行</li><li>因此，一个线程执行临界区期间没有其他线程能够访问相应的共享数据，这使得临界区代码所执行的操作自然而然地具有不可分割的特性，即具备了原子性.<blockquote><ul><li>从互斥的角度来看，锁其实是将多个线程对共享数据的访问由本来的并发（未使用锁的情况下）改为串行（使用锁之后)。因此，虽然实现并发是多线程编程的目标，但是这种并发往往是并发中带有串行的局部并发</li></ul></blockquote></li></ul></blockquote><p><strong>可见性</strong></p><blockquote><ul><li>可见性的保障是通过<code>写线程冲刷处理器缓存</code>和<code>读线程刷新处理器绶存</code>这两个动作实现的.</li><li><code>锁的获得</code>隐含着<code>刷新处理器缓存</code>. 这个动作这使得读线程在执行临界区代码前（获得锁之后) 可以将其他写线程对共享变量所做的更新同步到该线程执行处理器的高速级存中</li><li><code>锁的释放</code>隐含者冲刷处理器缓存这个动作，这使得写线程对共享变量所作的更新能够被”推送” 到该线程执行处理器的高速缓存中, 从而对读线程可同步. 因此锁能够保障可见性</li><li>具体原理参见 “内存屏障”</li></ul></blockquote><p><strong>有序性</strong></p><blockquote><ul><li>锁能够保障有序性。写线程在临界区中所执行的一系列操作在读线程所执行的临界区看起来像是完全按照源代码顺序执行的，即读线程对这些操作的感知顺序与源代码顺序一致。这是锁对原子性和可见性的保障的结果。</li></ul></blockquote><blockquote><ul><li>设写线程在临界区中更新了b、c和nag这3个共享变量。如下代码片段所示：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">b = a + <span class="hljs-number">1</span>:<br>c = <span class="hljs-number">2</span>:<br>flag = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><blockquote><ul><li>由于锁对可见性的保障，写线程在临界区中对上述任何一个共享变量所做的更新都对读线程可见。并且，由于临界区内的操作具有原子性，因此写线程对上述共享变量的更新会同时对读线程可见。即在读线程看来这些变盘就像足在同一刻被更新的。因此读线程并无法（也没有必要）区分写线程实际上是以什么顺序更新上述变量的. 这意味着读线程可以认为写线程是依照源代码顺序更新上述共享变量的，即有序性得以保障。</li><li>由于锁能保障有序性, 因此对于上述例子, 可有：<blockquote><ul><li>如果一个读线程在临界区中读取到变量c的值为2，那么flag的值必然为true。b的值必然比a的值大 1</li><li>如果一个读线程在临界区中读取到flag 的值为true,那么c的值必然为2. b的值必然比a的值大1</li><li>.等等…..</li></ul></blockquote></li><li>尽管锁能够保障有序性，但是这并不意味着临界区内的内存操作不能够被玉排序。临界区内的任意两个操作依然可以在临界区之内被重排序（即不会重排到临界区之外）。由于临界区内的操作具有的原子性，写线程在临界区内对各个共享数据的更新同时对读线程可见，因此这种重排序并不会对其他线程产生影响。</li></ul></blockquote><h1 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h1><blockquote><ul><li>乐观锁和悲观锁严格的说不是一种锁，而是一种策略</li></ul></blockquote><p><strong>悲观锁</strong></p><blockquote><ul><li>加锁是一种悲观的策略，它总是认为每次访问共享资源的时候，总会发生冲突，所以宁愿牺牲性能（时间）来保证数据安全</li><li>悲观锁的使用场景并不少见，数据库很多地方就用到了这种锁机制，比如行锁，表锁，读锁，写锁等，都是在做操作之前先上锁，悲观锁的实现往往依靠数据库本身的锁功能实现。Java程序中的Synchronized和ReentrantLock等实现的锁也均为悲观锁。</li></ul></blockquote><p><strong>乐观锁</strong></p><blockquote><ul><li>乐观锁就是先不加锁. 无锁是一种乐观的策略，它假设线程访问共享资源不会发生冲突，所以不需要加锁，因此线程将不断执行，不需要停止。一旦碰到冲突，就重试当前操作直到没有冲突为止</li><li>无锁的策略之一就是使用CAS机制</li></ul></blockquote><p><strong>CAS机制</strong></p><blockquote><ul><li>CAS的全称是Compare-and-Swap，也就是比较并交换，它包含了三个参数：V，A，B，</li><li>V表示要读写的内存位置，A表示旧的预期值，B表示新值</li><li>具体的机制是，当执行CAS指令的时候，只有当V的值等于预期值A时，才会把V的值改为B，如果V和A不同，有可能是其他的线程修改了，这个时候，执行CAS的线程就会不断的循环重试，直到能成功更新为止<br><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E9%94%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%B1%BB%E5%9E%8B%E5%88%92%E5%88%86/1.png" alt="在这里插入图片描述"></li><li>CAS算是比较高效的并发控制手段，不会阻塞其他线程。但是，这样的更新方式是存在问题的，看流程就知道了，如果C的结果一直跟预期的结果不一样的话，线程A就会一直不断的循环重试，重试次数太多的话对CPU也是一笔不小的开销。</li><li>CAS的ABA问题<blockquote><ul><li>CAS还有个问题就是ABA问题，比如第一次拿到内存里的值时是Ａ，然后被其他线程修改为B, 然后又修改为A, 而此时去比较内存里的值会发现没有变，但是实际上还是有改动</li><li>举个通俗点的例子，你倒了一杯水放桌子上，干了点别的事，然后同事把你水喝了又给你重新倒了一杯水，你回来看水还在，拿起来就喝，如果你不管水中间被人喝过，只关心水还在，还好 ； 但是假若你是一个比较讲卫生的人，那你肯定就不高兴了</li><li>ABA问题的解决思路: 使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A了</li></ul></blockquote></li></ul></blockquote><h1 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h1><p><strong>公平锁</strong></p><blockquote><ul><li>公平锁的概念是多个线程按照申请锁的顺序去获得锁，线程会直接进入阻塞队列去排队，永远都是队列的第一位才能得到锁。</li></ul></blockquote><p><strong>非公平锁</strong></p><blockquote><ul><li>非公平锁的概念是新来的线程如果想获取到锁可以先CAS抢一下，如果抢到了就执行代码，抢不到再去排队</li></ul></blockquote><p><strong>优缺点</strong></p><blockquote><ul><li>公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU 唤醒阻塞线程的开销比非公平锁大</li></ul></blockquote><blockquote><ul><li>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU 不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁</li></ul></blockquote><blockquote><ul><li>公平锁适合于锁被持有的时间相对长或者线程申请锁的平均间隔时间相对长的情形。总的来说使用公平锁的开销比使用非公乎锁的开销要大.</li></ul></blockquote><p><strong>Java中的公平锁和非公平锁</strong></p><blockquote><ul><li>JDK中的ReentrantLock既支持非公平锁又支持公平锁，默认非公平锁</li><li>Synchronized则是非公平锁</li></ul></blockquote><h1 id="什么是可重入锁"><a href="#什么是可重入锁" class="headerlink" title="什么是可重入锁"></a>什么是可重入锁</h1><blockquote><ul><li>所谓重入锁，即一个线程如果获取到了锁，那么这个线程再下一次进入同步代码中的时候可以直接进入，不用重新获取锁，</li><li>我们最熟悉的sychronized和ReentrantLock都是可重入锁。其实从ReentrantLock的名称上就可以看出来，Reentrant这个单词翻译成中文就是可重入的意思.</li></ul></blockquote><blockquote><ul><li>ReentrantLock可重入锁的实现，记录一下当前获取锁的线程记录为ownerThread，如果当前线程在获取锁的时候，发现自己就ownerThread，那么当前线程可以不用去抢锁直接执行</li></ul></blockquote><blockquote><ul><li>可重入锁的好处是可以避免一定程度的死锁情况(自己调用自己的情况), 可以递归调用</li><li>不可重入锁不能自己调用自己, 否则会发生死锁</li></ul></blockquote><h1 id="独占锁与共享锁"><a href="#独占锁与共享锁" class="headerlink" title="独占锁与共享锁"></a>独占锁与共享锁</h1><blockquote><ul><li>独占锁的概念是如果有一个线程已经获取到了锁，其他线程不可以继续获取锁，锁只能有此线程独占。</li></ul></blockquote><blockquote><ul><li>共享锁的概念是一个锁可以有多个线程共享，即一个线程获取到了锁，其他线程还可以继续获取锁</li></ul></blockquote><blockquote><ul><li>基于AQS实现的ReentrantLock就是独占锁，而AQS也提供了实现共享锁的模版方法tryAcquireShared.</li></ul></blockquote><h1 id="轻量级锁和重量级锁"><a href="#轻量级锁和重量级锁" class="headerlink" title="轻量级锁和重量级锁"></a>轻量级锁和重量级锁</h1><blockquote><ul><li>重量级锁的概念是如果锁已经被持有了，当前线程获取不到锁，当前线程挂起，等待锁的释放以及被唤醒。</li></ul></blockquote><blockquote><ul><li>轻量级锁的概念是如果锁已经被持有了，当前线程获取不到锁，那么将使用CAS机制或者自旋的方式获取锁 (<strong>在Java中Synchronized的轻量级锁是用自旋锁实现的</strong>)</li><li>这样设计的原因是大部分情况下我们占用锁的线程很快就执行完了，在很短的时间内就释放了锁，</li></ul></blockquote><blockquote><ul><li>如果使用重量级锁，那么下一个线程想获取锁继续执行的话需要经历挂起以及唤醒，这个过程需要CPU上下文切换，这个时间开销甚至大于用户代码执行的时间，所以轻量级锁让线程等一会，锁一旦释放，当前线程可以立马获取到，省去了不必要的上下文切换的开销</li></ul></blockquote><blockquote><ul><li>JVM对Synchronized锁的优化就是从无锁到重量级锁的升级过程</li><li>无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁</li></ul></blockquote><h1 id="自旋锁-Spinlock"><a href="#自旋锁-Spinlock" class="headerlink" title="自旋锁 (Spinlock)"></a>自旋锁 (Spinlock)</h1><blockquote><ul><li>自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。</li></ul></blockquote><blockquote><ul><li>获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting.</li></ul></blockquote><h1 id="锁泄露"><a href="#锁泄露" class="headerlink" title="锁泄露"></a>锁泄露</h1><p><a href="https://zhuanlan.zhihu.com/p/29729505?from_voters_page=true">https://zhuanlan.zhihu.com/p/29729505?from_voters_page&#x3D;true</a></p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 线程同步与线程协作的区别</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Java中的线程同步机制包括"><a href="#Java中的线程同步机制包括" class="headerlink" title="Java中的线程同步机制包括"></a>Java中的线程同步机制包括</h2><blockquote><ul><li>ReentrantLock (使用锁)</li><li>synchronized关键字 (使用锁)</li><li>volatile关键字</li><li>Java 原子变量类 (Atomics): <code>java.util.concurrent.atomic</code> </li><li>线程安全的集合: <code>ConcurrentHashMap&lt;K,V&gt;, ConcurrentLinkedDeque&lt;E&gt;,  ConcurrentLinkedQueue&lt;E&gt;</code> 等</li></ul></blockquote><p><strong>使用提示:</strong></p><blockquote><ul><li>遇到线程同步的问题时,  首先使用 <code>java.util.concurrent pakcage</code>, (不包括<code>java.util.concurrent.locks</code>) 主要指 <code>atomics类</code> 和 <code>ConcurrentHashMap, ConcurrentLinkedDeque, ConcurrentLinkedQueue</code>. 这些都是封装好的线程安全的库</li><li>如果不能满足需求,  则选择使用<code>synchronized, volatile</code>. </li><li>实在不行再用 <code>java.util.concurrent.locks</code> 包括 <code>ReentrantLock</code></li></ul></blockquote><h1 id="线程协作"><a href="#线程协作" class="headerlink" title="线程协作"></a>线程协作</h1><blockquote><ul><li>线程协作是指多个线程分工合作, 共同完成任务.</li><li>比如线程的互相唤起, 阻塞, 中断等都是线程协作</li></ul></blockquote><h2 id="Java中的线程协作机制包括"><a href="#Java中的线程协作机制包括" class="headerlink" title="Java中的线程协作机制包括"></a>Java中的线程协作机制包括</h2><blockquote><ul><li>等待与通知<code>: Object.wait/notify</code></li><li>Condition变量: <code>java.util.concurrent.locks.Condition</code></li><li>倒计时协调器(CountDownLatch): <code>java.util.concurrent.locks.CountDownLatch</code></li><li>栅栏:(CycliBarrier): <code>java.util.concurrent.locks.CyclicBarrier</code></li><li>生产者消费者模式</li><li>线程中断机制(<code>Interrupt</code>)</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 线程同步 volatile关键字</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="volatile-keyword"><a href="#volatile-keyword" class="headerlink" title="volatile keyword"></a>volatile keyword</h1><blockquote><ul><li>Volatile是Java虚拟机提供的轻量级的同步机制</li><li>Volatile可以保证可见性, 禁止指令重排, 但是不保证原子性<blockquote><ul><li>volatile利用MESI协议和snooping保证可见性</li><li>volatile不保证原子性, 比如 <code>num++</code> 这个操作实际上分为三步, 拿到num值, 对num值加一, 放回num值. </li><li>volatile关键字保证了拿到number的值是正确的，但是在执行对num值加一, 放回num值这些指令的时候，其他线程可能已经把number的值改变了，而操作栈顶的值就变成了过期的数据，所以就可能把较小的number值同步回主内存之中.</li></ul></blockquote></li><li>如果要实现原子性, 可以使用synchronized关键字, 或者使用 Java并发包（JUC）中的AtomicInterger等类</li><li>可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改<blockquote><ul><li>通过之前对synchronzed内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，synchronized具有可见性。</li><li>同样的在volatile分析中，会通过在指令中添加lock指令，以实现内存可见性。因此, volatile具有可见性</li></ul></blockquote></li></ul></blockquote><h1 id="使用volatile保证可见性"><a href="#使用volatile保证可见性" class="headerlink" title="使用volatile保证可见性"></a>使用volatile保证可见性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShareData</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumberTo100</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">this</span>.number = <span class="hljs-number">100</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 资源类</span><br>        <span class="hljs-type">ShareData</span> <span class="hljs-variable">shareData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ShareData</span>();<br> <br>        <span class="hljs-comment">// 子线程 实现了Runnable接口的，lambda表达式</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br> <br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t come in&quot;</span>);<br> <br>            <span class="hljs-comment">// 线程睡眠3秒，假设在进行运算</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">3</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 修改number的值</span><br>            shareData.setNumberTo100();<br> <br>            <span class="hljs-comment">// 输出修改后的值</span><br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t update number value:&quot;</span> + shareData.number);<br> <br>        &#125;, <span class="hljs-string">&quot;child Thread: &quot;</span>).start();<br> <br>        <span class="hljs-keyword">while</span>(shareData.number == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//System.out.println(Thread.currentThread().getName() + &quot;等待number更新为100&quot;);</span><br>        &#125;<br> <br>        <span class="hljs-comment">//这句话输出不出来, 因为子线程更改number值后, main线程没有感知到</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 主线程感知到了 number 不等于 0&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>最后线程没有停止，没有输出”主线程知道了 number 不等于0”这句话，说明没有用volatile修饰的变量，变量的更新是不可见的<br><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20volatile%E5%85%B3%E9%94%AE%E5%AD%97/1.png" alt="在这里插入图片描述"></li></ul></blockquote><blockquote><ul><li>将number 声明为 volatile: <code>volatile int number = 0;</code><br><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20volatile%E5%85%B3%E9%94%AE%E5%AD%97/2.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="使用volatile禁止指令重排"><a href="#使用volatile禁止指令重排" class="headerlink" title="使用volatile禁止指令重排"></a>使用volatile禁止指令重排</h1><blockquote><ul><li>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排序。</li><li>有三种指令重排:<blockquote><ul><li>.编译器优化重排：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>.指令级的并行重排：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>.内存系统的重排：由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li></ul></blockquote></li></ul></blockquote><p>Example: 双重检测锁定的单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jackson0714.passjava.threads;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> 演示volatile 单例模式应用（双边检测）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 悟空聊架构</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-08-17</span><br><span class="hljs-comment"> */</span><br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VolatileSingleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">VolatileSingleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">VolatileSingleton</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;\t 我是构造方法SingletonDemo&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> VolatileSingleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 第一重检测</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 锁定代码块</span><br>            <span class="hljs-keyword">synchronized</span> (VolatileSingleton.class) &#123;<br>                <span class="hljs-comment">// 第二重检测</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 实例化对象</span><br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VolatileSingleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br></code></pre></td></tr></table></figure><p>}</p><blockquote><ul><li>代码看起来没有问题，但是 instance &#x3D; new VolatileSingleton();其实可以看作三条伪代码：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">memory = allocate(); <span class="hljs-comment">// 1、分配对象内存空间</span><br>instance(memory); <span class="hljs-comment">// 2、初始化对象</span><br>instance = memory; <span class="hljs-comment">// 3、设置instance指向刚刚分配的内存地址，此时instance != null</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>步骤2 和 步骤3之间不存在 数据依赖关系，而且无论重排前 还是重排后，程序的执行结果在单线程中并没有改变，因此这种重排优化是允许的。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">memory = allocate(); <span class="hljs-comment">// 1、分配对象内存空间</span><br>instance = memory; <span class="hljs-comment">// 3、设置instance指向刚刚分配的内存地址，此时instance != null，但是对象还没有初始化完成</span><br>instance(memory); <span class="hljs-comment">// 2、初始化对象</span><br></code></pre></td></tr></table></figure><p><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20volatile%E5%85%B3%E9%94%AE%E5%AD%97/3.png" alt="在这里插入图片描述"></p><blockquote><p>可以使用volatile:  <code>private static volatile VolatileSingleton instance = null;</code></p></blockquote><p>注意：当且仅当满足以下所有条件时，才应该用volatile变量</p><blockquote><ul><li>对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。</li><li>该变量不会与其他的状态一起纳入不变性条件中。</li><li>在访问变量时不需要加锁。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 线程同步 内部锁synchronized</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20%E5%86%85%E9%83%A8%E9%94%81synchronized/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20%E5%86%85%E9%83%A8%E9%94%81synchronized/</url>
    
    <content type="html"><![CDATA[<h1 id="Intrinsic-Lock-Monitor"><a href="#Intrinsic-Lock-Monitor" class="headerlink" title="Intrinsic Lock (Monitor)"></a>Intrinsic Lock (Monitor)</h1><blockquote><ul><li>synchronized锁机制是基于monitor对象（也被叫做<code>Monitor 或 Monitor Lock</code>监视器锁或 <code>Intrinsic Lock</code>）实现的，每个对象都存在一个monitor对象与之关联，对象头中有一块专门的内存区域用于存储与之关联的monitor对象的地址。</li></ul></blockquote><blockquote><ul><li>每个monitor对象有三个部分<blockquote><ul><li><code>The Owner</code>: 表示目前锁的持有者, 如果为null则表示是无锁状态</li><li><code>Entry Set:</code> 记录等待获得相应内部锁的线程. 多个线程申请同一个锁的时候, 只有一个申请者能够成为该锁的持有线程, 其他申请失败者会继续保留在Entry Set.</li><li><code>Wait Set:</code>  当一个线程获得锁之后, 因为没有满足某些条件而不得不放弃锁 (调用wait方法). 会被放入Wait Set并进入阻塞状态</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>比如在HotSpot虚拟机中，monitor是由ObjectMonitor实现的，其主要数据结构如下（源码ObjectMonitor.hpp文件，C++实现):</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//只列举出部分关键字段</span><br>ObjectMonitor() &#123;<br>_object;      = NULL;<span class="hljs-comment">//当前monitor关联的锁对象</span><br>    _header       = NULL;<span class="hljs-comment">//当前monitor关联的锁对象的原始对象头</span><br>    _count        = <span class="hljs-number">0</span>;<span class="hljs-comment">//抢占该monitor的线程数</span><br>    _owner        = NULL;<span class="hljs-comment">//占用当前monitor的线程</span><br>    _WaitSet      = NULL; <span class="hljs-comment">//处于wait状态的线程，会被加入到该列表</span><br>    _EntryList    = NULL ; <span class="hljs-comment">//处于block状态的线程，会被加入到该列表</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>内部锁是非公平锁. 所以在wait set的线程被唤醒时, 会有其他的活跃线程(处于Runnable状态, 并且是第一次竞争该锁) 来一起竞争. 所以不是内部锁不是先到先得, 允许线程插队获得锁. </li><li>内部锁是可重入锁, 有一个计数器记录目前线程的所有权, 为0时代表无锁, 为1时代表已被抢占, 当拥有锁的线程再次申请时, 计数器会进行加一操作.</li><li>内部锁是重量级锁 因为monitor锁机制依赖于底层操作系统的Mutex Lock实现，挂起线程和恢复线程都需要从用户态切换到内核态去完成，状态转换耗费的成本非常高，所以synchronized是Java语言中的一个重量级操作</li></ul></blockquote><h1 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h1><blockquote><ul><li>Intrinsic Lock是通过synchronized关键字触发的<blockquote><ul><li>synchronized修饰<code>实例方法</code>上，锁对象是当前的this对象</li><li>synchronized修饰<code>静态方法</code>上，锁对象是方法区中的类对象，是一个全局锁</li><li>synchronized修饰<code>代码块</code>，也就是synchronized(object){}，锁对象是()中的对象</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>synchronized保证原子性, 可见性, 有序性<blockquote><ul><li><code>原子性</code>: 基于 monitorenter 和 monitorexit 字节码指令，保证同步块只有单一线程执行。</li><li><code>可见性</code>: synchronized 的可见性是由“<code>对一个变量执行 unlock 操作之前，必须先把此变量同步回主内存中（执行 store、write 操作）</code>”这条规则获得的。</li><li><code>有序性</code>:</li></ul></blockquote></li></ul></blockquote><p><strong>具体实现</strong></p><blockquote><ul><li>在修饰代码块时，字节码层面上是通过 <code>montiorenter</code> 和 <code>monitorexit</code> 指令来实现的锁获取与释放动作. 当线程进入到<code>monitorenter</code>指令后, 线程将会持有monitor对象.  退出<code>monitorenter</code>指令后，线程将会释放monitor对象<blockquote><ul><li><code>monitorenter</code>指令: 获取monitor对象的所有权, 并会发生如下3中情况之一：<blockquote><ul><li>monitor计数器为0，意味着目前还没有被获得，那这个线程就会立刻获得然后把锁计数器+1，一旦+1，别的线程再想获取，就需要等待</li><li>如果这个monitor已经拿到了这个锁的所有权，又重入了这把锁，那锁计数器就会累加，变成2，并且随着重入的次数，会一直累加 (可重入性)</li><li>第三种情况就是这把锁已经被别的线程获取了，等待锁释放</li></ul></blockquote></li><li><code>monitorexit</code>指令：释放对于monitor的所有权，<blockquote><ul><li>释放过程很简单，就是讲monitor的计数器减1，如果减完以后，计数器不是0，则代表刚才是重入进来的，当前线程还继续持有这把锁的所有权</li><li>如果计数器变成0，则代表当前线程不再拥有该monitor的所有权，即释放锁.</li></ul></blockquote></li></ul></blockquote></li><li>在修饰方法时, JVM通过<code>ACC_SYNCHRONIZED</code>这个标志区分一个方法是否为同步方法. 如果有<code>ACC_SYNCHRONIZED</code>标志, 则会先持有方法所在的monitor对象，然后再执行方法. 在该方法执行时间，其它任何线程均无法再获取到这个monitor对象，当线程执行完该方法后，他会释放掉这个monitor对象</li></ul></blockquote><blockquote><ul><li>Intrinsic Lock的一些限制<blockquote><ul><li>You cannot interrupt a thread that is trying to acquire a lock.</li><li>You cannot specify a timeout when trying to acquire a lock.</li></ul></blockquote></li></ul></blockquote><h2 id="synchronized-修饰实例方法"><a href="#synchronized-修饰实例方法" class="headerlink" title="synchronized 修饰实例方法"></a>synchronized 修饰实例方法</h2><blockquote><ul><li>用synchronized修饰的实例方法叫做<code>同步实例方法</code>, 锁对象是当前的<code>this对象</code></li><li>同步方法的整个方法体就是一个临界区</li></ul></blockquote><p><strong>Example 1: 循环递增序列号生成器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//只有一个线程可以更新序列号, 保证多线程情况下序列号正常更新</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafeCircularSeGenerator</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">short</span> <span class="hljs-variable">sequence</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">short</span> <span class="hljs-title function_">nextSequence</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (sequence &gt;= <span class="hljs-number">999</span>) &#123;<br>sequence = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>sequence++:<br>&#125;<br><span class="hljs-keyword">return</span> sequence;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Example 2: 使用synchronized重写银行账户的transfer方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span><br>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-type">double</span>[] accounts;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> amount)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  <span class="hljs-comment">//余额不足, 等待入账</span><br> <span class="hljs-keyword">while</span> (accounts[from] &lt; amount)<br>wait(); <span class="hljs-comment">// wait on intrinsic object lock&#x27;s single condition</span><br> accounts[from] -= amount;<br> accounts[to] += amount;<br> notifyAll(); <span class="hljs-comment">// notify all threads waiting on the condition</span><br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getTotalBalance</span><span class="hljs-params">()</span> &#123; . . . &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="synchronized-修饰代码块"><a href="#synchronized-修饰代码块" class="headerlink" title="synchronized 修饰代码块"></a>synchronized 修饰代码块</h2><blockquote><ul><li>synchronized修饰的代码块就是临界区,</li><li>synchronized(object)，锁对象是()中的对象叫锁句柄, 是对应的锁 (可以是任何类型的Object或者this指针) </li><li>具体格式如下</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(锁句柄 handle) &#123;<br><span class="hljs-comment">//critical section</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>锁句柄的变量通常采用 <code>private final</code> 修饰. 这是因为锁句柄变量的值一旦改变, 会导致执行同一个同步块的多线程实际上使用不同的锁, 从而产生混乱 如: <code>private final Object lock = new Object()</code></li></ul></blockquote><p><strong>Example 1: 使用sychronized代码块 实现循环递增序列号生成器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//只有一个线程可以更新序列号, 保证多线程情况下序列号正常更新</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">short</span> <span class="hljs-title function_">nextSequence</span><span class="hljs-params">()</span> &#123;<br>synchronied(<span class="hljs-built_in">this</span>) &#123;<br><span class="hljs-keyword">if</span> (sequence &gt;= <span class="hljs-number">999</span>) &#123;<br>sequence = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>sequence++:<br>&#125;<br><span class="hljs-keyword">return</span> sequence;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Example 2: 使用synchronized代码块重写银行账户的transfer方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bank</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> amount)</span> &#123;<br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>accounts[from] -= amount;<br>accounts[to] += amount;<br>&#125;<br>System.out.println(. . .);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="synchronized-修饰静态方法"><a href="#synchronized-修饰静态方法" class="headerlink" title="synchronized 修饰静态方法"></a>synchronized 修饰静态方法</h2><blockquote><ul><li>synchronized 关键字可以修饰静态方法, 也就是对 类 加锁, 也叫做类锁</li><li>用static修饰的同步函数使用的锁为.class文件</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticRuning1</span><span class="hljs-params">(Thread thread)</span>&#123;<br>        System.out.println(thread.getName()+ <span class="hljs-string">&quot; static car1 得到锁&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;------ static car1 is running ------&quot;</span>);<br>        working();<br>        System.out.println(thread.getName()+ <span class="hljs-string">&quot; static car1 释放锁&quot;</span>);<br>        System.out.println();<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticRuning2</span><span class="hljs-params">(Thread thread)</span>&#123;<br>        System.out.println(thread.getName()+ <span class="hljs-string">&quot; static car2 得到锁&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;------ static car2 is running ------&quot;</span>);<br>        working();<br>        System.out.println(thread.getName()+ <span class="hljs-string">&quot; static car2 释放锁&quot;</span>);<br>        System.out.println();<br>    &#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">working</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<span class="hljs-keyword">catch</span>(InterruptedException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">test02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-comment">//线程1 类</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                Car.staticRuning1(Thread.currentThread()); <span class="hljs-comment">//同步类方法1</span><br>            &#125;<br>        &#125;;<br>        t1.start();<br><br>        <span class="hljs-comment">//线程2 类</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                Car.staticRuning2(Thread.currentThread()); <span class="hljs-comment">//同步类方法2</span><br>            &#125;<br>        &#125;;<br>        t2.start();<br>    &#125;<br>&#125;<br><br>output --- Car类不能同时访问两个静态方法<br>Thread-<span class="hljs-number">0</span> <span class="hljs-keyword">static</span> car1 得到锁<br>------ <span class="hljs-keyword">static</span> car1 is running ------<br>Thread-<span class="hljs-number">0</span> <span class="hljs-keyword">static</span> car1 释放锁<br><br>Thread-<span class="hljs-number">1</span> <span class="hljs-keyword">static</span> car2 得到锁<br>------ <span class="hljs-keyword">static</span> car2 is running ------<br>Thread-<span class="hljs-number">1</span> <span class="hljs-keyword">static</span> car2 释放锁<br></code></pre></td></tr></table></figure><h1 id="sychronized的可重入性"><a href="#sychronized的可重入性" class="headerlink" title="sychronized的可重入性"></a>sychronized的可重入性</h1><blockquote><ul><li>内部锁是可重入锁, monitor有一个计数器记录目前线程的所有权, 为0时代表无锁, 为1时代表已被抢占, 当拥有锁的线程再次申请时, 计数器会进行加一操作</li><li>当释放时, monitor会进行减一操作</li><li>可重入锁的好处是可以避免一定程度的死锁情况(自己调用自己), 可以递归调用</li></ul></blockquote><blockquote><ul><li>Example 1: 同一类的同一方法</li><li>因为方法被synchronized修饰，如果不可重入的话，无法执行递归，输出0和1代表进入了两次method方法，说明了Synchronized的可重用性。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedReusing</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SynchronizedReusing</span> <span class="hljs-variable">reusing</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedReusing</span>();<br>        reusing.method(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>)&#123;<br>            System.out.println(i++);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        System.out.println(i++);<br>        method(i);<br>    &#125;<br>&#125;<br><br>Output:<br><span class="hljs-number">0</span><br><span class="hljs-number">1</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>Example 2: 同一类的不同方法</li><li>两个方法都被synchronized修饰，如果不可重入的话，method是无法访问method1的(锁对象都是this, 会有死锁)，说明了Synchronized的可重用性</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedReusing</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SynchronizedReusing</span> <span class="hljs-variable">reusing</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedReusing</span>();<br>        reusing.method(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;method    &quot;</span> + i++);<br>        method1(i);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;method1   &quot;</span> + i);<br>    &#125;<br>&#125;<br><br>Output:<br>method    <span class="hljs-number">0</span><br>method1   <span class="hljs-number">1</span><br>Process finished with exit code <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>例三 不同类的方法</li></ul></blockquote><pre><code class="java">public class SynchronizedReusing &#123;    public synchronized void method()&#123;        System.out.println(&quot;父类的方法&quot;);    &#125;&#125;class SynchronizedReusingSon extends SynchronizedReusing &#123;    @Override    public synchronized void method() &#123;        System.out.println(&quot;子类的方法&quot;);        super.method();    &#125;    public static void main(String[] args) &#123;        SynchronizedReusingSon son = new SynchronizedReusingSon();        son.method();    &#125;&#125;Output:子类的方法父类的方法Process finished with exit code 0``</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 线程同步 显式锁ReentrantLock</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20%E6%98%BE%E5%BC%8F%E9%94%81ReentrantLock/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20%E6%98%BE%E5%BC%8F%E9%94%81ReentrantLock/</url>
    
    <content type="html"><![CDATA[<h1 id="显式锁-Lock接口"><a href="#显式锁-Lock接口" class="headerlink" title="显式锁: Lock接口"></a>显式锁: Lock接口</h1><blockquote><ul><li>显式锁是自 JDK 1.5 开始引人的排他锁。作为一种线程同步机制，其作用与内部锁相<br>同。它提供了一些内部锁所不具备的特性，但并不是内部锁的替代品。</li><li>显式锁(Explicit Lock）是<code>java.util.concurrent.lcoks.Lock</code> 接口的实例。该接口对显式<br>锁进行了抽象</li><li><code>java.util.concurrent.lcoks.ReentrantLock</code> 是 Lock 接口的默认实现类.</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> : 获取锁。<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span>:如果当前线程未被中断，则获取锁。<br>Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>: 返回绑定到此 Lock 实例的新 Condition 买例。<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">trylock</span><span class="hljs-params">()</span>: 仅在调用时锁为空闲状态寸获取该锁。<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span>: 如果锁在给定的等待时间内空闲，井且当前线程未被中睡，则获取锁.<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> 释放锁.<br></code></pre></td></tr></table></figure><p><strong>使用格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Lock 1ock= ... ：<span class="hljs-comment">//创建一个Iock 接口实例</span><br>1ock.lock() <span class="hljs-comment">//在访问共享数据前申请相应的显式锁。这一步，我们直接调用相应 Lock.lock即可</span><br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-comment">//在此对共享数据进行访问</span><br>&#125; <span class="hljs-keyword">finally</span>&#123;<br><span class="hljs-comment">//总是在final1y 块中释放锁，以避免锁泄漏</span><br>lock.unlock() <span class="hljs-comment">//释放锁 lock</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>在临界区中访问共享数据。<code>Lock.lock()</code> 调用与 <code>Lock.unlock()</code>调用之间的代码区域<br>为临界区。不过，一般我们视上述的 try 代码块为临界区。因此，对共享数据的访问都仅放在该代码块中。</li><li>共享数据访问结束后释放锁。虽然释放锁的操作通过调用 <code>Lock.unlock()</code>即可实现，<br>但是为了避免锁泄漏，我们必领将这个调用放在 finally 块中执行<blockquote><ul><li>这样，无论是临界区代码执行正常结束还是由于其抛出异常而提前退出，相应锁的 unlock 方法<br>总是可以被执行，从而避免了锁泄漏。可见，显式锁不像内部锁那样可以由编译器代为规避锁泄漏问题.</li></ul></blockquote></li><li>ReentrantLock 既支持非公平锁也支持公平锁。ReentrantLock 的一个构造器的签名如下：<code>ReentrantLock (boolean fair)</code><blockquote><ul><li>该构造器使得我们在创建显式锁实例的时候可以指定相应的锁是否是公平锁（fair参数值true 表示是公平锁)。</li><li>显式锁默认使用的是非公平调度策略.</li></ul></blockquote></li></ul></blockquote><p><strong>Example:  使用显示锁实现循环递增序列号生成器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockbasedCircularSeqGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CircularSeqGenerator</span>&#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">short</span> <span class="hljs-variable">sequence</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">short</span> <span class="hljs-title function_">nextsequence</span><span class="hljs-params">()</span><br>lock.lock () ;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (sequence &gt;= <span class="hljs-number">999</span>) &#123;<br>sequence<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>sequence--;<br>&#125;<br><span class="hljs-keyword">return</span> sequence;<br><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>lock.unlock () <br>&#125;<br></code></pre></td></tr></table></figure><h1 id="显性锁的实现原理-—-AQS机制"><a href="#显性锁的实现原理-—-AQS机制" class="headerlink" title="显性锁的实现原理 — AQS机制"></a>显性锁的实现原理 — AQS机制</h1>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 线程同步 CAS机制与Java原子类</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20CAS%E6%9C%BA%E5%88%B6%E4%B8%8EJava%E5%8E%9F%E5%AD%90%E7%B1%BB/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20CAS%E6%9C%BA%E5%88%B6%E4%B8%8EJava%E5%8E%9F%E5%AD%90%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h1><h2 id="为什么使用CAS机制"><a href="#为什么使用CAS机制" class="headerlink" title="为什么使用CAS机制"></a>为什么使用CAS机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">incremnt</span><span class="hljs-params">()</span> &#123;<br>sychronized(<span class="hljs-built_in">this</span>) &#123;<br>count++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>实际上，这里使用锁来保障原子性显得有点杀鸡用牛刀的样子.</li><li>锁固然是功能最强大适用范围也很广泛的同步机制，但是毕竟它的开销也是最大的。另外，volatile 虽然开销小一点，但是它无法保障“count++”这种自增操作的原子性.</li><li>事实上，保障像自增这种比较简单的操作的原子性我们有更好的选择-CAS.</li></ul></blockquote><h2 id="CAS机制原理"><a href="#CAS机制原理" class="headerlink" title="CAS机制原理"></a>CAS机制原理</h2><blockquote><ul><li>CAS的全称是Compare-and-Swap，也就是比较并交换，它包含了三个参数：V，A，B.</li><li>V表示要读写的内存位置，A表示旧的预期值，B表示新值</li><li>具体的机制是，当执行CAS指令的时候，只有当V的值等于预期值A时，才会把V的值改为B，如果V和A不同，有可能是其他的线程修改了，这个时候，执行CAS的线程就会不断的循环重试，直到能成功更新为止<br><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%20CAS%E6%9C%BA%E5%88%B6%E4%B8%8EJava%E5%8E%9F%E5%AD%90%E7%B1%BB/1.png" alt="在这里插入图片描述"></li><li>CAS可以保证 <code>共享变量更新</code> 这个操作的原子性, 但是不保证可见性</li></ul></blockquote><p><strong>CAS机制的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//伪代码</span><br><span class="hljs-comment">//V为维护的共享变量</span><br><span class="hljs-comment">//A为old value</span><br><span class="hljs-comment">//B为new value</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwap</span><span class="hljs-params">(Variable V, Object A, Object B)</span> &#123;<br><span class="hljs-keyword">if</span> (A == v.get()) ( <span class="hljs-comment">// check:检查变量值是否被其他线程修改过</span><br>v.set(B);<span class="hljs-comment">// act:更新变量值</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<span class="hljs-comment">//更新成功</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//变量值已被其他线程修改，更新失败</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用CAS改写Increment</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CASBasedCounter</span> &#123;<br><span class="hljs-comment">//需要注意的是，CAS 只是保障了共享变量更新这个操作的原子性，它并不保障可见, 因此，在上述代码中我们仍然采用 volatile 修饰共享变量 count。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> count;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">vaule</span><span class="hljs-params">()</span> (<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">long</span> oldValue;<br><span class="hljs-type">long</span> newValue;<br><span class="hljs-keyword">do</span> &#123;<br>oldValue = count;<span class="hljs-comment">// 读取共享变量的当前值</span><br>newValue = oldvalue + <span class="hljs-number">1</span>;<span class="hljs-comment">// 计算共享变量的新值</span><br>&#125; <span class="hljs-keyword">while</span> (compareAndSwap(oldValue，newValue));  <span class="hljs-comment">//调用CAS</span><br></code></pre></td></tr></table></figure><p><strong>优缺点</strong></p><blockquote><ul><li>CAS算是比较高效的并发控制手段，不会阻塞其他线程, 避免了线程上下文切换带来的开销. </li><li>但是，这样的更新方式是存在问题的，看流程就知道了，如果C的结果一直跟预期的结果不一样的话，线程A就会一直不断的循环重试，重试次数太多的话对CPU也是一笔不小的开销.</li></ul></blockquote><blockquote><ul><li>CAS的ABA问题<blockquote><ul><li>CAS还有个问题就是ABA问题，比如第一次拿到内存里的值时是Ａ，然后被其他线程修改为B, 然后又修改为A, 而此时去比较内存里的值会发现没有变，但是实际上还是有改动.</li><li>举个通俗点的例子，你倒了一杯水放桌子上，干了点别的事，然后同事把你水喝了又给你重新倒了一杯水，你回来看水还在，拿起来就喝，如果你不管水中间被人喝过，只关心水还在，还好; 但是假若你是一个比较讲卫生的人，那你肯定就不高兴了.</li><li>ABA问题的解决思路: 使用版本号。在变量前面追加上版本号, 每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A了</li></ul></blockquote></li></ul></blockquote><h1 id="Java-原子变量类"><a href="#Java-原子变量类" class="headerlink" title="Java 原子变量类"></a>Java 原子变量类</h1><blockquote><ul><li>原子变量类(Atomics)是基于CAS 实现的能够保障对共享变量进行 read-modify-write更新操作, 例如自增操作“count++”</li><li>原子变量类可以保证<code>原子性</code>和<code>可见性</code>. <blockquote><ul><li>原子变量类的内部实现通常借助一个 volatile变量保证可见性, 并通过CAS保证原子性</li></ul></blockquote></li><li>原子变量类一共有 12 个，可以被分为4组，如下:</li></ul></blockquote><table><thead><tr><th>分组</th><th>类</th></tr></thead><tbody><tr><td>基础数据型</td><td>AtomicInteger, AtomicLong, AtomicBoolean</td></tr><tr><td>数组型</td><td>AtomicIntegerArray ,  AtomicLongArray,  AtomicReferenceArray</td></tr><tr><td>字段更新器</td><td>AtomicIntegerFieldUpdater,  AtomicLongFieldUpdater, AtomicReferenceFieldUpdater</td></tr><tr><td>引用型</td><td>AtomicReference, AtomicStampedReference, AtomicMarkableReference</td></tr></tbody></table><p><strong>Example:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//记录请求总数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">requestCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 记录处理成功总数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">successCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLonq</span>(<span class="hljs-number">0</span>);<br><span class="hljs-comment">// 记录处理失败总数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">failureCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newRequestReceived</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//使总请求数增加1。 这里无须加锁</span><br>requestCount.incrementAndGet();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">newRequestProcessed</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//使总请求数增加 1。 这里无须加锁</span><br>successCount.incrementAndGet();<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestProcessedFailed</span><span class="hljs-params">()</span> &#123; <br><span class="hljs-comment">//使总请求数增加 1。 这里无须加锁</span><br>failureCount.incrementAndGet(); <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 线程协作 wait and notify</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C%20wait%20and%20notify/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C%20wait%20and%20notify/</url>
    
    <content type="html"><![CDATA[<p>@[TOC](Java 多线程 — 线程协作 wait&#x2F;notify)</p><h1 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait &#x2F; notify"></a>wait &#x2F; notify</h1><blockquote><ul><li>在多线程中, 如果程序拿到锁之后, 但是没有满足指定条件而不能继续往下执行, 我们可以将当前线程暂停(<strong>进入阻塞状态</strong>), 直到满足所需要的条件时再将线程唤醒, 结构如下:</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">atomic &#123;<br><span class="hljs-keyword">while</span> (条件 不成立) &#123;<br> wait <span class="hljs-comment">//暂停当前线程</span><br>&#125;<br><span class="hljs-comment">//执行目标动作</span><br>doAction();<br>notify<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>上述操作必须是原子操作. 一个线程因其执行目标动作所需的条件为满足而被暂停的过程就是<code>等待 (Wait)</code></li><li>一个线程使用完critical section. 更新了系统的状态, 使得其他线程所需的保护条件得以,满足的时候唤醒那些被暂停的线程的过程就被称为<code>通知 (Notify)</code></li></ul></blockquote><h1 id="Object-wait-Object-notify-notifyAll"><a href="#Object-wait-Object-notify-notifyAll" class="headerlink" title="Object.wait() , Object.notify() &#x2F; notifyAll()"></a>Object.wait() , Object.notify() &#x2F; notifyAll()</h1><blockquote><ul><li>Java中通过 Object.wait() 和 Object.notify() 实现等待和通知. <blockquote><ul><li>wait和notify都是Object的方法, 也就是每个对象都有wait和notify方法</li></ul></blockquote></li><li>wait()的作用是使正在执行的线程被阻塞</li><li>notify()的作用是唤醒一个被阻塞的线程.</li><li>notifyAll()的作用是唤醒全部被阻塞的线程</li><li>具体格式如下</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">sychrnoized(lock) &#123;<br><span class="hljs-keyword">while</span> (条件 不成立) &#123;<br> lock.wait <span class="hljs-comment">//暂停当前线程</span><br>&#125;<br><span class="hljs-comment">//执行目标动作</span><br>doAction();<br>lock.notify<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Example:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">给你一个类：<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span> &#123; print(<span class="hljs-string">&quot;first&quot;</span>); &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">second</span><span class="hljs-params">()</span> &#123; print(<span class="hljs-string">&quot;second&quot;</span>); &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">third</span><span class="hljs-params">()</span> &#123; print(<span class="hljs-string">&quot;third&quot;</span>); &#125;<br>&#125;<br>三个不同的线程 A、B、C 将会共用一个 Foo 实例。<br><br>线程 A 将会调用 first() 方法<br>线程 B 将会调用 second() 方法<br>线程 C 将会调用 third() 方法<br><br>请设计修改程序，以确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//声明一个objetc作为锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Foo</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">(Runnable printFirst)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            <span class="hljs-keyword">while</span>( flag != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//还没有轮到自己运行, 进入阻塞状态. </span><br>                lock.wait();<br>            &#125;<br>            printFirst.run();<br>            flag = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//唤醒其他在阻塞状态的线程</span><br>            lock.notifyAll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">second</span><span class="hljs-params">(Runnable printSecond)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            <span class="hljs-keyword">while</span> (flag != <span class="hljs-number">1</span>)&#123;<br>                lock.wait();<br>            &#125;<br>            printSecond.run();<br>            flag = <span class="hljs-number">2</span>;<br>            lock.notifyAll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">third</span><span class="hljs-params">(Runnable printThird)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            <span class="hljs-keyword">while</span> (flag != <span class="hljs-number">2</span>)&#123;<br>                lock.wait();<br>            &#125;<br>            printThird.run();<br>            flag = <span class="hljs-number">0</span>;<br>            lock.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="notify-和-wait-的原理"><a href="#notify-和-wait-的原理" class="headerlink" title="notify 和 wait 的原理"></a>notify 和 wait 的原理</h1><blockquote><ul><li>每个sychronizied锁(也就是内部锁), 都有一个monitor对象</li><li>monitor对象有三个部分<blockquote><ul><li><code>The Owner</code>: 表示目前锁的持有者, 如果为null则表示是无锁状态</li><li><code>Entry Set:</code> 记录等待获得相应内部锁的线程. 多个线程申请同一个锁的时候, 只有一个申请者能够成为该锁的持有线程, 其他申请失败者会继续保留在Entry Set.</li><li><code>Wait Set:</code>  当一个线程获得锁之后, 因为没有满足某些条件而不得不放弃锁 (调用wait方法). 会被放入Wait Set并进入阻塞状态</li></ul></blockquote></li></ul></blockquote><p><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E5%8D%8F%E4%BD%9C%20wait%20and%20notify/1.png" alt="在这里插入图片描述"></p><blockquote><ul><li>我们知道 Java 虛拟机会为每个锁(也就是对象)维护一个入口集(Entry Set ）用于存储申请该对象的内部锁的线程。</li><li>此外，Java 虛拟机还会为每个锁(也就是对象) 维护一个被称为等待集（Wait Set )的队列，该队列用于存储该对象上的等待线程。</li><li><code>wait方法</code>会将当前线程放进 <code>Wait Set</code>, 并把当前线程变为阻塞状态</li><li><code>notify方法</code>会使该对象的Wait Set中的一个任意线程被唤醒。注意此时线程不会释放锁, 要等待临界区运行完毕, 所以notify尽量放在临界区的末尾.</li><li>被唤醒的线程仍然会停留在相应对象的Wait Set中，直到该线程再次竞争相应内部锁的时候, Object.wait会使当前线程从其所在的<code>Wait Set</code>中移除.<code>(应该是不管竞争失败或者成功都会被移除, 不过这一点不确定)</code>接着 Object.wait调用就返回了. (<code>具体如伪代码所示</code>)</li></ul></blockquote><blockquote><ul><li>Object. waito&#x2F;notify()实现的等待&#x2F;通知中的几个关键动作，包括将当前线程加入等待集, 暂停当前线程, 释放锁以及将唤醒后的等待线程从等待集中移除等，都是在 Obiect.wait() 中实现的. </li><li>Object. wait() 的部分内部实现相当于如下伪代码：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span> <span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">//执行线程必须持有当前对象对应的内部锁</span><br><span class="hljs-keyword">if</span> (!Thread.holdsLock (<span class="hljs-built_in">this</span>) ) &#123;<br><span class="hljs-keyword">throws</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStatefxception</span>():<br>&#125;<br><span class="hljs-keyword">if</span> (当前对象不在等待集中）&#123;<br><span class="hljs-comment">//将当前线程加入当前对象的等待集中</span><br>addToWaitSet(Thread.currentThread ());<br>&#125;<br>atomic &#123; <br><span class="hljs-comment">//原子操作开始, 释放当前对象的内部锁</span><br>releaselock(<span class="hljs-built_in">this</span>) :<br><span class="hljs-comment">//阻塞当前线程</span><br>block(Thread. current <span class="hljs-title function_">Thread</span> <span class="hljs-params">()</span>);<br>&#125;<br><br><span class="hljs-comment">//再次申请当前对象的内部锁</span><br>acquireLock(<span class="hljs-built_in">this</span>);<br><span class="hljs-comment">//将当前线程从当前对象的等待集中移除</span><br>removeFromWaitSet(Thread. currentIhread () ) ;<br><span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="notify会导致死锁的问题"><a href="#notify会导致死锁的问题" class="headerlink" title="notify会导致死锁的问题"></a>notify会导致死锁的问题</h1><blockquote><ul><li>多个线程调用了锁对象的<code>wait()</code>方法，这些线程都会进入到<code>wait set</code>中，等待池中的线程不参与锁竞争。此时只调用一次notify()方法，那么只有一个线程会从<code>wait set</code>进入到<code>entry set</code>竞争资源，并且获得锁资源继续执行接下来的代码。执行完毕后，释放锁。但是由于其它线程都处于等待池中，不会去竞争争夺锁，大家都在等待池中等待通知，故而造成了死锁。除非再次调用<code>notify()</code>或者<code>notifyAll()</code>去触发通知，否则会一直等待下去</li><li>如果使用<code>notifyAll</code>则可以避免这种情况, 因为notifyAll会唤醒所有等待线程, 放入entry set中</li></ul></blockquote><h1 id="wait-notify的开销以及问题"><a href="#wait-notify的开销以及问题" class="headerlink" title="wait &#x2F; notify的开销以及问题"></a>wait &#x2F; notify的开销以及问题</h1><p>To be continued</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 线程池</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h1><blockquote><ul><li>线程池包括许多个可以随时运行的idle线程</li><li>将 Runnable 放入线程池, 线程池中的一个线程会执行 Runnable中的run方法. </li><li>当 run 方法退出, 这个线程不会结束, 而是变为idle线程继续呆在线程池里</li></ul></blockquote><p>为什么需要线程池</p><blockquote><ul><li>创建线程的代价很大, 因为需要和操作系统交互.</li><li>如果需要大量的运行时间不长的线程时, 应该使用线程池</li><li>还有时候使用线程池只是为了方便对task分组并控制</li></ul></blockquote><h1 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h1><blockquote><ul><li><code>Executor</code> 类包含了几个静态工厂方法用来创建线程池<br><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/1.png" alt="在这里插入图片描述"></li><li><code>newCachedThreadPool</code> 方法创建一个线程池, 当新的任务进来时, 如果有idle线程则使用idle线程, 没有会创建新的</li><li><code>newFixedThreadPool</code> 方法创建一个固定大小的线程池. 如果任务数量超出了idle线程的数量, 任务则会被放进queue</li><li><code>newSingleThreadExecutor</code> 方法创建一个大小为1的线程池</li><li>以上三个方法, 会返回一个实现了<code>ExecutorService</code>的<code>ThreadPoolExecutor</code> 对象<blockquote><ul><li>然后通过返回的对象的以下三个方法, 将Runnable或者Callable放进线程池</li><li><code>Future&lt;?&gt; submit(Runnable task)</code></li><li><code>Future&lt;T&gt; submit(Runnable task, T result)</code></li><li><code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code></li><li>submit方法会返回一个Future对象, 用来查询任务状态</li></ul></blockquote></li><li>使用完线程池之后, 使用<code>shutdown</code>方法可以关闭线程池. 线程池将不会接受新的任务, 当所有任务执行完毕后, 线程池关闭</li><li>也可以使用<code>shutdownNow</code>方法, 线程池将取消所有没有执行的任务, 并且会中断正在运行的线程</li></ul></blockquote><p><strong>Summary: 使用线程池的步骤:</strong></p><blockquote><ul><li><ol><li>Call the static newCachedThreadPool or newFixedThreadPool method of the Executors class.</li></ol></li><li><ol start="2"><li>Call submit to submit Runnable or Callable objects.</li></ol></li><li><ol start="3"><li>If you want to be able to cancel a task, or if you submit Callable objects, hang<br>on to the returned Future objects.</li></ol></li><li><ol start="4"><li>Call shutdown when you no longer want to submit any tasks.</li></ol></li></ul></blockquote><h2 id="Example-code"><a href="#Example-code" class="headerlink" title="Example code"></a>Example code</h2><blockquote><ul><li>下面代码的主要功能是统计一个目录下所有文件keyword出现的次数(包括sub directories), keyword是用户自定义输入</li><li>对于每个directory都会使用一个线程, 因为用到的数量很多, 并且持续时间很短, 所以用到了线程池</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> threadPool;<br><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.02 2015-06-21</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Cay Horstmann</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in)) &#123;<br>System.out.print(<span class="hljs-string">&quot;Enter base directory (e.g. /usr/local/jdk5.0/src): &quot;</span>);<br> <span class="hljs-type">String</span> <span class="hljs-variable">directory</span> <span class="hljs-operator">=</span> in.nextLine();<br> System.out.print(<span class="hljs-string">&quot;Enter keyword (e.g. volatile): &quot;</span>);<br> <span class="hljs-type">String</span> <span class="hljs-variable">keyword</span> <span class="hljs-operator">=</span> in.nextLine();<br> <span class="hljs-comment">//创建线程池</span><br> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br> <span class="hljs-comment">//实现了Callable接口的任务</span><br><span class="hljs-type">MatchCounter</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MatchCounter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(directory), keyword, pool);<br><span class="hljs-comment">//提交任务</span><br> Future&lt;Integer&gt; result = pool.submit(counter);<br><span class="hljs-keyword">try</span> &#123;<br>System.out.println(result.get() + <span class="hljs-string">&quot; matching files.&quot;</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>e.printStackTrace();<br>&#125;<br> <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>&#125;<br><span class="hljs-comment">//关闭线程池</span><br>pool.shutdown();<br><span class="hljs-type">int</span> <span class="hljs-variable">largestPoolSize</span> <span class="hljs-operator">=</span> ((ThreadPoolExecutor) pool).getLargestPoolSize();<br>System.out.println(<span class="hljs-string">&quot;largest pool size=&quot;</span> + largestPoolSize);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* This task counts the files in a directory and its subdirectories that contain a given keyword.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MatchCounter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br><span class="hljs-keyword">private</span> File directory;<br><span class="hljs-keyword">private</span> String keyword;<br><span class="hljs-keyword">private</span> ExecutorService pool;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Constructs a MatchCounter.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> directory the directory in which to start the search</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> keyword the keyword to look for</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> pool the thread pool for submitting subtasks</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MatchCounter</span><span class="hljs-params">(File directory, String keyword, ExecutorService pool)</span> &#123;<br><span class="hljs-built_in">this</span>.directory = directory;<br><span class="hljs-built_in">this</span>.keyword = keyword;<br><span class="hljs-built_in">this</span>.pool = pool;<br>&#125;<br><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">try</span> &#123;<br>File[] files = directory.listFiles();<br>List&lt;Future&lt;Integer&gt;&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (File file : files)<br><span class="hljs-keyword">if</span> (file.isDirectory()) &#123;<br><span class="hljs-comment">//对于每个subdirectory都开启一个线程</span><br><span class="hljs-type">MatchCounter</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MatchCounter</span>(file, keyword, pool);<br>Future&lt;Integer&gt; result = pool.submit(counter);<br>results.add(result);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (search(file)) count++;<br>&#125;<br><br><span class="hljs-keyword">for</span> (Future&lt;Integer&gt; result : results)<br><span class="hljs-keyword">try</span> &#123;<br>count += result.get();<br>&#125;<br><span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* Searches a file for a given keyword.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> file the file to search</span><br><span class="hljs-comment">* <span class="hljs-doctag">@return</span> true if the keyword is contained in the file</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">search</span><span class="hljs-params">(File file)</span> &#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">try</span> (<span class="hljs-type">Scanner</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(file, <span class="hljs-string">&quot;UTF-8&quot;</span>)) &#123;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">found</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">while</span> (!found &amp;&amp; in.hasNextLine()) &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">line</span> <span class="hljs-operator">=</span> in.nextLine();<br><span class="hljs-keyword">if</span> (line.contains(keyword)) found = <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">return</span> found;<br>&#125;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException e) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Fork-in-Framework"><a href="#Fork-in-Framework" class="headerlink" title="Fork-in Framework"></a>Fork-in Framework</h1><blockquote><ul><li>使用fork-in framework可以利用多线程完成递归任务</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> forkJoin;<br><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.function.*;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* This program demonstrates the fork-join framework.</span><br><span class="hljs-comment">* <span class="hljs-doctag">@version</span> 1.01 2015-06-21</span><br><span class="hljs-comment">* <span class="hljs-doctag">@author</span> Cay Horstmann</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000000</span>;<br><span class="hljs-type">double</span>[] numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span>[SIZE];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; SIZE; i++) numbers[i] = Math.random();<br><span class="hljs-type">Counter</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(numbers, <span class="hljs-number">0</span>, numbers.length, x -&gt; x &gt; <span class="hljs-number">0.5</span>);<br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>pool.invoke(counter);<br>System.out.println(counter.join());<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">double</span>[] values;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> from;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> to;<br><span class="hljs-keyword">private</span> DoublePredicate filter;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Counter</span><span class="hljs-params">(<span class="hljs-type">double</span>[] values, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, DoublePredicate filter)</span> &#123;<br><span class="hljs-built_in">this</span>.values = values;<br><span class="hljs-built_in">this</span>.from = from;<br><span class="hljs-built_in">this</span>.to = to;<br><span class="hljs-built_in">this</span>.filter = filter;<br>&#125;<br><br><span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">if</span> (to - from &lt; THRESHOLD) &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> from; i &lt; to; i++) &#123;<br><span class="hljs-keyword">if</span> (filter.test(values[i])) count++;<br>&#125;<br><span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (from + to) / <span class="hljs-number">2</span>;<br><span class="hljs-type">Counter</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(values, from, mid, filter);<br><span class="hljs-type">Counter</span> <span class="hljs-variable">second</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>(values, mid, to, filter);<br>invokeAll(first, second);<br><span class="hljs-keyword">return</span> first.join() + second.join();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程 --- 按序打印</title>
    <link href="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/"/>
    <url>/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/</url>
    
    <content type="html"><![CDATA[<p>给你一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">()</span> &#123; print(<span class="hljs-string">&quot;first&quot;</span>); &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">second</span><span class="hljs-params">()</span> &#123; print(<span class="hljs-string">&quot;second&quot;</span>); &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">third</span><span class="hljs-params">()</span> &#123; print(<span class="hljs-string">&quot;third&quot;</span>); &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>三个不同的线程 A、B、C 将会共用一个 Foo 实例。</p><blockquote><ul><li>线程 A 将会调用 first() 方法</li><li>线程 B 将会调用 second() 方法</li><li>线程 C 将会调用 third() 方法</li></ul></blockquote><blockquote><ul><li><strong>请设计修改程序，以确保 second() 方法在 first() 方法之后被执行，third() 方法在 second() 方法之后被执行。</strong></li></ul></blockquote><h1 id="方法1-—-控制变量"><a href="#方法1-—-控制变量" class="headerlink" title="方法1 — 控制变量"></a>方法1 — 控制变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Foo</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">(Runnable printFirst)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        printFirst.run();<br>        order = <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">second</span><span class="hljs-params">(Runnable printSecond)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (order != <span class="hljs-number">2</span>) &#123;&#125;<br>        printSecond.run();<br>        order = <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">third</span><span class="hljs-params">(Runnable printThird)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (order != <span class="hljs-number">3</span>) &#123;&#125;<br>        printThird.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>上面方法会超时</li><li>原因是没有实现可见性, 也就是线程没有立即得到order更新后的值, 所以一直卡在while循环里, 导致超时</li><li>比如线程1将order修改为2之后, 线程2没有得到这个更新, 导致一致卡在自己的while循环中<blockquote><ul><li>关于可见性: 线程在执行的时候会将主内存中的变量拷贝一份到工作内存中，之后线程的运行只与工作内存打交道<br><img src="/2024/04/26/Java%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%20---%20%E6%8C%89%E5%BA%8F%E6%89%93%E5%8D%B0/1.png" alt="在这里插入图片描述"></li></ul></blockquote></li></ul></blockquote><h2 id="使用volatile关键字优化"><a href="#使用volatile关键字优化" class="headerlink" title="使用volatile关键字优化"></a>使用volatile关键字优化</h2><blockquote><ul><li>volatile关键字可以保证可见性, 也就是对变量的更新可以立即被其他线程所捕获</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Foo</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">(Runnable printFirst)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        printFirst.run();<br>        order = <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">second</span><span class="hljs-params">(Runnable printSecond)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (order != <span class="hljs-number">2</span>) &#123;&#125;<br>        printSecond.run();<br>        order = <span class="hljs-number">3</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">third</span><span class="hljs-params">(Runnable printThird)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">while</span> (order != <span class="hljs-number">3</span>) &#123;&#125;<br>        printThird.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>以上实现方法还有缺点, 就是当一个线程执行时, 其他线程会不断的执行while循环, 消耗CPU的资源</li><li>可以通过synchronized + wait + notifyAll的方式解决</li></ul></blockquote><h1 id="方法2-—-synchronized-wait-notifyAll"><a href="#方法2-—-synchronized-wait-notifyAll" class="headerlink" title="方法2 — synchronized + wait + notifyAll"></a>方法2 — synchronized + wait + notifyAll</h1><blockquote><ul><li>使用wait可以让目前还不能允许的线程进入等待阻塞状态, 直到正在允许的线程完成任务之后调用notifyAll唤醒.</li><li>当其他线程被唤醒后, 会竞争锁</li><li>当一个线程拿到锁之后, 通过flag检查是否该自己运行, 如果不该自己运行则又进入等待阻塞状态, 并且释放锁</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//声明一个objetc作为锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Foo</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">(Runnable printFirst)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            <span class="hljs-keyword">while</span>( flag != <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//还没有轮到自己运行, 进入阻塞状态. </span><br>                lock.wait();<br>            &#125;<br>            printFirst.run();<br>            flag = <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//唤醒其他在阻塞状态的线程</span><br>            lock.notifyAll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">second</span><span class="hljs-params">(Runnable printSecond)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            <span class="hljs-keyword">while</span> (flag != <span class="hljs-number">1</span>)&#123;<br>                lock.wait();<br>            &#125;<br>            printSecond.run();<br>            flag = <span class="hljs-number">2</span>;<br>            lock.notifyAll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">third</span><span class="hljs-params">(Runnable printThird)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock)&#123;<br>            <span class="hljs-keyword">while</span> (flag != <span class="hljs-number">2</span>)&#123;<br>                lock.wait();<br>            &#125;<br>            printThird.run();<br>            flag = <span class="hljs-number">0</span>;<br>            lock.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="方法3-—-信号量"><a href="#方法3-—-信号量" class="headerlink" title="方法3  — 信号量"></a>方法3  — 信号量</h1><blockquote><ul><li>也可以使用信号量控制线程的执行顺序</li><li></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> &#123;<br>    <span class="hljs-comment">//控制第一个和第二个线程的顺序,初始信号量为0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">first_to_second</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//控制第二个和第三个线程的顺序, 初始信号量为0</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">second_to_third</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Foo</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">first</span><span class="hljs-params">(Runnable printFirst)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        printFirst.run();<br>        first_to_second.release();<span class="hljs-comment">//增加信号量, first_to_second的信号量变为0, 将线程2唤起</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">second</span><span class="hljs-params">(Runnable printSecond)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>         <span class="hljs-comment">//尝试获取信号量, first_to_second 初始为0, count--, 信号量变为-1, 线程2被放入blocking queue</span><br>        first_to_second.acquire();<br>        printSecond.run();<br>        <span class="hljs-comment">//增加信号量, second_to_third的信号量变为0, 将线程3唤起</span><br>        second_to_third.release();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">third</span><span class="hljs-params">(Runnable printThird)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>         <span class="hljs-comment">//尝试获取信号量, second_to_third 初始为0, count--, 信号量变为-1, 线程3被放入blocking queue</span><br>        second_to_third.acquire();<br>        printThird.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>关于信号量</li></ul></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//pseudo code</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br><span class="hljs-type">int</span> counter;<span class="hljs-comment">//表示目前的资源数量</span><br><span class="hljs-built_in">queue</span> q;<span class="hljs-comment">//用于存放等待中的线程</span><br>&#125; <span class="hljs-type">sem_t</span> <br><br><span class="hljs-comment">//v operation: release</span><br>signal(<span class="hljs-type">sem_t</span> *s) &#123;<br>s.counter++;<br><span class="hljs-comment">//counter小于等于0则说明有线程在排队等待消费资源，所以需要队列中的资源移出,然后唤醒线程</span><br><span class="hljs-keyword">if</span> (s.counter &lt;= <span class="hljs-number">0</span>) &#123;<br>remove(s.q, p);<br>wakeup(q);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//p operation: wait</span><br>wait(<span class="hljs-type">sem_t</span> *s) &#123;<br>s.counter--;<br><span class="hljs-comment">//counter为负说明目前没有资源可供消费，则需要将目前进程放进等待队列, 然后block掉</span><br><span class="hljs-keyword">if</span> (s.counter &lt; <span class="hljs-number">0</span>) &#123;<br>add this thread to s.q;<br>block();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 多线程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- 代码块以及执行顺序</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>@[TOC](Java基础— 代码块以及执行顺序)</p><h1 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h1><blockquote><ul><li>在Java中，使用{}大括号括起来的代码被称为代码块，代码块可以在类的任何地方出现，具体分为： 普通代码块，构造代码块，静态代码块，同步代码块</li></ul></blockquote><h2 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h2><blockquote><ul><li>定义: 在类中用{ }括起来的代码，没有任何的修饰符，参数列表，返回值等 </li><li>执行顺序：在对象被创造时执行，在构造函数之前执行</li><li>构造函数的作用：如果只有一个构造方法，那么构造代码块写在构造方法里也可以，但如果有多个构造方法需要做一部分公共的处理，那么这部分公共的代码可以提取出来放在构造代码块中，这样就可以只写一次，避免代码重复。以及内部匿名类的初始化<br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/1.png" alt="在这里插入图片描述"></li></ul></blockquote><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><blockquote><ul><li>定义: 在类中用 static{}括起来的代码，可以在类中任何地方出现</li><li>执行顺序：在类被加载时执行（不是在对象被创造时执行），并且在main函数之前执行</li><li>静态代码的作用：用于类的初始化以及提升程序性能，只在类被加载时执行一次<br>Ex：包装类的缓存用到了静态代码块<br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/2.png" alt="在这里插入图片描述"></li></ul></blockquote><h2 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h2><blockquote><ul><li>定义：使用synchronized（）{}包裹起来的代码块，在多线程环境下，对共享数据的读写操作是需要互斥进行的，否则会导致数据的不一致性。同步代码块需要写在方法中</li></ul></blockquote><h1 id="代码块执行顺序"><a href="#代码块执行顺序" class="headerlink" title="代码块执行顺序"></a>代码块执行顺序</h1><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><blockquote><ul><li><strong>创造对象时先加载成员数据</strong>然后加载构造代码块然后是构造函数（也是找到父类，然后从父类开始加载构造代码块和构造函数）</li><li>   注意Example3和4</li></ul></blockquote><h2 id="Example-1-只有一个类的情况（无继承）"><a href="#Example-1-只有一个类的情况（无继承）" class="headerlink" title="Example 1: 只有一个类的情况（无继承）"></a>Example 1: 只有一个类的情况（无继承）</h2><blockquote><ul><li><strong>静态代码块  -&gt;  Main函数 -&gt; 构造代码块 -&gt; 构造函数</strong><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/3.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/4.png" alt="在这里插入图片描述"></li></ul></blockquote><h2 id="Example-2-在有继承的情况下"><a href="#Example-2-在有继承的情况下" class="headerlink" title="Example 2: 在有继承的情况下"></a>Example 2: 在有继承的情况下</h2><blockquote><ul><li><strong>父类静态代码块 -&gt; 子类静态代码块 -&gt; Main函数 -&gt; 父类构造代码块 -&gt; 父类构造函数 -&gt;子类构造代码块 -&gt; 子类构造函数</strong><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/5.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/6.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/7.png" alt="在这里插入图片描述"></li></ul></blockquote><h2 id="Example-3"><a href="#Example-3" class="headerlink" title="Example 3"></a>Example 3</h2><p><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/8.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/9.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/10.png" alt="在这里插入图片描述"></p><p><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/11.png" alt="在这里插入图片描述"></p><h2 id="Example-4"><a href="#Example-4" class="headerlink" title="Example 4"></a>Example 4</h2><p><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/12.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/13.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/14.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BB%A5%E5%8F%8A%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/15.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- 泛型 Generics</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%B3%9B%E5%9E%8B%20Generics/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%B3%9B%E5%9E%8B%20Generics/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么需要泛型"><a href="#为什么需要泛型" class="headerlink" title="为什么需要泛型"></a>为什么需要泛型</h1><blockquote><ul><li>在没有泛型类之前, Java用继承解决泛型问题. 也就是利用Object类</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// before generic classes </span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span> &#123;<br><span class="hljs-keyword">private</span> Object[] elementData<br> . . .<br> <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123; . . . &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Object o)</span> &#123; . . . &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>这样有两个问题<blockquote><ul><li>当获取值时必须要转型<br><code>ArrayList files = new ArrayList();</code><br><code>String filename = (String) files.get(0);</code></li><li>没有error checking, 可以给这个arraylist加入任何类(因为所有类的父类都是object)<br><code>files.add(new File(&quot;. . .&quot;));</code> This call compiles and runs without error. Elsewhere, casting the result of get to a String will cause an error</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>泛型提供了type parameter, 这样就可以给泛型指定一个类型, 代码更易读, 不用转型并且有error checking<br><code>ArrayList&lt;String&gt; files = new ArrayList&lt;String&gt;();</code></li></ul></blockquote><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><p><strong>泛型类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br> <span class="hljs-keyword">private</span> T first;<br> <span class="hljs-keyword">private</span> T second;<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">()</span> &#123; first = <span class="hljs-literal">null</span>; second = <span class="hljs-literal">null</span>; &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T second)</span> &#123; <span class="hljs-built_in">this</span>.first = first; <span class="hljs-built_in">this</span>.second = second; &#125;<br> <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> first; &#125;<br> <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getSecond</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> second; &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFirst</span><span class="hljs-params">(T newValue)</span> &#123; first = newValue; &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSecond</span><span class="hljs-params">(T newValue)</span> &#123; second = newValue; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>泛型方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayAlg</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getMiddle</span><span class="hljs-params">(T... a)</span> &#123;<br> <span class="hljs-keyword">return</span> a[a.length / <span class="hljs-number">2</span>];<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Bounds-for-Type-Variable"><a href="#Bounds-for-Type-Variable" class="headerlink" title="Bounds for Type Variable"></a>Bounds for Type Variable</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayAlg</span> &#123; <br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">min</span><span class="hljs-params">(T[] a)</span> <span class="hljs-comment">// almost correct  &#123;</span><br> <span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || a.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br> <span class="hljs-type">T</span> <span class="hljs-variable">smallest</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; a.length; i++)<br> <span class="hljs-keyword">if</span> (smallest.compareTo(a[i]) &gt; <span class="hljs-number">0</span>) smallest = a[i];<br> <span class="hljs-keyword">return</span> smallest;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>上面的代码, T可以是任何类, 但是.<code>compareTo</code>方法只有实现了<code>Comparable</code>接口才有</li><li>如何确保 T 一定实现了<code>Comparable</code>接口<blockquote><ul><li>可以给type variable限定bounds, 也就是限定T必须继承某个父类或者接口<br><code>public static &lt;T extends Comparable&gt; T min(T[] a)</code></li></ul></blockquote></li><li>也可以限定多个接口  <code>T extends Comparable &amp; Serializable</code></li><li><strong>虽然bound可以是接口也可以是类, 但是最多只能限定一个类, 并且必须放在bounds list的第一个. 接口可以限定多个</strong></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayAlg</span><br>&#123;<br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">Gets the minimum and maximum of an array of objects of type T.</span><br><span class="hljs-comment"><span class="hljs-doctag">@param</span> a an array of objects of type T</span><br><span class="hljs-comment"><span class="hljs-doctag">@return</span> a pair with the min and max value, or null if a is</span><br><span class="hljs-comment">null or empty</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&gt; Pair&lt;T&gt; <span class="hljs-title function_">minmax</span><span class="hljs-params">(T[] a)</span><br>&#123;<br><span class="hljs-keyword">if</span> (a == <span class="hljs-literal">null</span> || a.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">T</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br><span class="hljs-type">T</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> a[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; a.length; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (min.compareTo(a[i]) &gt; <span class="hljs-number">0</span>) min = a[i];<br><span class="hljs-keyword">if</span> (max.compareTo(a[i]) &lt; <span class="hljs-number">0</span>) max = a[i];<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;&gt;(min, max);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Java虚拟机如何处理泛型-—-泛型擦除"><a href="#Java虚拟机如何处理泛型-—-泛型擦除" class="headerlink" title="Java虚拟机如何处理泛型 — 泛型擦除"></a>Java虚拟机如何处理泛型 — 泛型擦除</h1><p><strong>泛型擦除 —  Type Erase</strong></p><blockquote><ul><li>Java 中的泛型只有在编译阶段存在，在代码运行的时候是没有泛型的，这也被称为泛型擦除</li><li>虚拟机会对泛型代码进行泛型擦除, 也就是将所有的类型 T 替换成raw type, raw type就是bound list中的第一个类型, 或者是Object类型 如果没有bounds list</li></ul></blockquote><p>无bound list的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//执行完Type Erasure的代码</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span><br>&#123;<br> <span class="hljs-keyword">private</span> Object first;<br> <span class="hljs-keyword">private</span> Object second;<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(Object first, Object second)</span> &#123;<br> <span class="hljs-built_in">this</span>.first = first;<br> <span class="hljs-built_in">this</span>.second = second;<br> &#125;<br> <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> first; &#125;<br> <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getSecond</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> second; &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFirst</span><span class="hljs-params">(Object newValue)</span> &#123; first = newValue; &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSecond</span><span class="hljs-params">(Object newValue)</span> &#123; second = newValue; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有bound list的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Interval</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span> &amp; Serializable&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span><br>&#123;<br> <span class="hljs-keyword">private</span> T lower;<br> <span class="hljs-keyword">private</span> T upper;<br> . . .<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Interval</span><span class="hljs-params">(T first, T second)</span><br> &#123;<br> <span class="hljs-keyword">if</span> (first.compareTo(second) &lt;= <span class="hljs-number">0</span>) &#123; lower = first; upper = second; &#125;<br> <span class="hljs-keyword">else</span> &#123; lower = second; upper = first; &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Interval</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span><br>&#123;<br> <span class="hljs-keyword">private</span> Comparable lower;<br> <span class="hljs-keyword">private</span> Comparable upper;<br> . . .<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Interval</span><span class="hljs-params">(Comparable first, Comparable second)</span> &#123; . . . &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类型转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;Employee&gt; buddies = . . .;<br><span class="hljs-type">Employee</span> <span class="hljs-variable">buddy</span> <span class="hljs-operator">=</span> buddies.getFirst();<br></code></pre></td></tr></table></figure><blockquote><ul><li>经过泛型擦除之后buddies.getFirst返回的是Object类型, 编译器自动进行类型转换, 转为Employee类型</li></ul></blockquote><p><strong>桥接方法 — bridge Method</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt; &#123;<br> <span class="hljs-keyword">private</span> T first;<br> <span class="hljs-keyword">private</span> T second;<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">()</span> &#123; first = <span class="hljs-literal">null</span>; second = <span class="hljs-literal">null</span>; &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">(T first, T second)</span> &#123; <span class="hljs-built_in">this</span>.first = first; <span class="hljs-built_in">this</span>.second = second; &#125;<br> <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getFirst</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> first; &#125;<br> <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getSecond</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> second; &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFirst</span><span class="hljs-params">(T newValue)</span> &#123; first = newValue; &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSecond</span><span class="hljs-params">(T newValue)</span> &#123; second = newValue; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DateInterval</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pair</span>&lt;LocalDate&gt;<br>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSecond</span><span class="hljs-params">(LocalDate second)</span><br> &#123;<br> <span class="hljs-keyword">if</span> (second.compareTo(getFirst()) &gt;= <span class="hljs-number">0</span>)<br> <span class="hljs-built_in">super</span>.setSecond(second);<br> &#125;<br> . . .<br>&#125;<br></code></pre></td></tr></table></figure><p>泛型擦除之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DateInterval</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Pair</span> <span class="hljs-comment">// after erasure</span><br>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSecond</span><span class="hljs-params">(LocalDate second)</span> &#123; . . . &#125;<br> . . .<br>&#125;<br></code></pre></td></tr></table></figure><p>这样DataInterval会有两个setSecond方法</p><blockquote><ol><li><code>public void setSecond(Object second)</code>  从pair继承</li><li><code>public void setSecond(LocalDate second)</code></li></ol></blockquote><p>这是两个完全不同的方法, 因为参数不一样. 但是实际上应该是一个方法, DataInterval应该Override从pair继承的setSecond方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateInterval</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateInterval</span>(. . .);<br>Pair&lt;LocalDate&gt; pair = interval; <span class="hljs-comment">// OK--assignment to superclass</span><br><br><span class="hljs-comment">//pair的声明类型为Pair所以会调用public void setSecond(Object second)</span><br><span class="hljs-comment">//而无法调用 public void setSecond(LocalDate second)</span><br>pair.setSecond(aDate);<br></code></pre></td></tr></table></figure><p>为了解决这个问题, 编译器会在<code>DataInterval</code>类自动生成一个bridge method</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setSecond</span><span class="hljs-params">(Object second)</span> &#123; <br>    <span class="hljs-comment">// 调用 public void setSecond(LocalDate second)</span><br>setSecond((LocalDate) second); <br>&#125;<br></code></pre></td></tr></table></figure><p>当下面代码被调用时, pair.setSecond会调用bridge method, 然后bridge method调用实际的setSecond方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DateInterval</span> <span class="hljs-variable">interval</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DateInterval</span>(. . .);<br>Pair&lt;LocalDate&gt; pair = interval; <span class="hljs-comment">// OK--assignment to superclass</span><br>pair.setSecond(aDate);<br></code></pre></td></tr></table></figure><p>In summary, you need to remember these facts about translation of Java generics:</p><blockquote><ul><li>There are no generics in the virtual machine, only ordinary classes and<br>methods.</li><li>All type parameters are replaced by their bounds.</li><li>Bridge methods are synthesized to preserve polymorphism.</li><li>Casts are inserted as necessary to preserve type safety</li></ul></blockquote><h1 id="Restrictions-and-Limitations"><a href="#Restrictions-and-Limitations" class="headerlink" title="Restrictions and Limitations"></a>Restrictions and Limitations</h1><p><strong>Type Paramter Cannot be Instantiated with Primitive Types</strong></p><blockquote><ul><li>there is no <code>Pair&lt;double&gt;</code>, only <code>Pair&lt;Double&gt;.</code></li><li>因为泛型擦除之后, Pair的类型是Object, double不是Object的子类</li></ul></blockquote><p><strong>在运行时进行的类型查询只适用于原始类型(擦除之后的类型)</strong></p><blockquote><ul><li>对类型的查询只能使用Raw Type (擦除之后的类型)<br><code>if (a instanceof Pair&lt;String&gt;) // Error</code><br><code>if (a instanceof Pair&lt;T&gt;) // Error</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//getClass method 返回的也是raw type</span><br>Pair&lt;String&gt; stringPair = . . .;<br>Pair&lt;Employee&gt; employeePair = . . .;<br><span class="hljs-keyword">if</span> (stringPair.getClass() == employeePair.getClass()) <span class="hljs-comment">// they are equal</span><br></code></pre></td></tr></table></figure><p><strong>Java 不支持泛型数组</strong></p><blockquote><p>在Java中, 数组会记住元素的类型, 如果试图储存其他类型的元素, 就会抛出一个ArrayStoreException</p><ul><li>但是对于泛型类型, 擦除会使这种机制无效. 所以Java 不支持泛型数组</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Pair&lt;String&gt;[] table = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;String&gt;[<span class="hljs-number">10</span>];<br>Object[] objarray = table;<br><span class="hljs-comment">//数组中应该存入Pari&lt;String&gt;类型, 但是下面这行代码可以通过array store exception check因为擦除之后的类型是Object</span><br><span class="hljs-comment">//最终会在运行时报错, </span><br>objarray[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pair</span>&lt;Employee&gt;(); <br></code></pre></td></tr></table></figure><blockquote><ul><li>可以声明通配类型的数组, 然后进行类型转换, 但是结果将是不安全的</li><li><code>Pair&lt;String&gt;[] table = (Pair&lt;String&gt;[]) new Pair&lt;?&gt;[10];</code><br> If you store a Pair<Employee> in table[0] and then call a String<br>method on table[0].getFirst(), you get a ClassCastException.</Employee></li></ul></blockquote><p><strong>不能实例化类型变量</strong><br>You cannot use type variables in an expression such as new T(…).<br>For example, the following Pair<T> constructor is illegal:</T></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Pair</span><span class="hljs-params">()</span> &#123; first = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(); second = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>(); &#125; <span class="hljs-comment">// Error</span><br></code></pre></td></tr></table></figure><p><strong>Type Variable 不能用static关键字修饰</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&lt;T&gt;<br>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> T singleInstance; <span class="hljs-comment">// Error</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> T <span class="hljs-title function_">getSingleInstance</span><span class="hljs-params">()</span> <span class="hljs-comment">// Error</span><br> &#123;<br> <span class="hljs-keyword">if</span> (singleInstance == <span class="hljs-literal">null</span>) construct <span class="hljs-keyword">new</span> <span class="hljs-title class_">instance</span> of T<br> <span class="hljs-keyword">return</span> singleInstance;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>如果允许声明泛型类的static方法或者属性, 则一个程序可以声明两个类比如 <code>Singleton&lt;Random&gt;</code>,  <code>Singleton&lt;JFileChooser&gt;</code>, 但是泛型擦除之后, 只有一个Singleton类和singleInstance属性. 则<code>private static Random singleInstance</code>和<code>private static JFileChooser singleInstance</code> 冲突, 所以不行</li></ul></blockquote><p><strong>泛型类不能继承Throwable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Problem</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Exception</span> &#123; <span class="hljs-comment">/* . . . */</span> &#125; <span class="hljs-comment">// Error--can&#x27;t extend Throwable</span><br></code></pre></td></tr></table></figure><p>不能在catch中使用泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(Class&lt;T&gt; t)</span><br>&#123;<br> <span class="hljs-keyword">try</span><br> &#123;<br><span class="hljs-keyword">do</span> work<br> &#125;<br> <span class="hljs-keyword">catch</span> (T e) <span class="hljs-comment">// Error--can&#x27;t catch type variable</span><br> &#123;<br> Logger.global.info(...)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是可以限定type variable继承Throwable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">(T t)</span> <span class="hljs-keyword">throws</span> T <span class="hljs-comment">// OK</span><br>&#123;<br> <span class="hljs-keyword">try</span><br> &#123;<br><span class="hljs-keyword">do</span> work<br> &#125;<br> <span class="hljs-keyword">catch</span> (Throwable realCause)<br> &#123;<br> t.initCause(realCause);<br>  <span class="hljs-keyword">throw</span> t;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意擦除后的冲突</strong></p><blockquote><ul><li>比如将如下代码加入Pair class</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Pair</span>&lt;T&gt;<br>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(T value)</span> &#123; <span class="hljs-keyword">return</span> first.equals(value) &amp;&amp; second.equals(value); &#125;<br> . . .<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>则会出现两个equals method, 解决方法是重新命名冲突的方法<br><code>boolean equals(String) // defined in Pair&lt;T&gt;</code><br><code>boolean equals(Object) // inherited from Object</code></li></ul></blockquote><p><strong>泛型中的继承</strong></p><blockquote><ul><li>如果Manager是Employee的子类, 那么<code>Pair&lt;Manager&gt;</code> 是<code>Pair&lt;Employee&gt;</code>的子类吗? 答案是”NO”</li><li>所以以下代码是错的, 不能把<code>Pair&lt;Manager&gt;</code> 赋给<code>Pair&lt;Employee&gt;</code></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Manager[] topHonchos = . . .;<br>Pair&lt;Employee&gt; result = ArrayAlg.minmax(topHonchos); <br></code></pre></td></tr></table></figure><p><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%B3%9B%E5%9E%8B%20Generics/1.png" alt="在这里插入图片描述"></p><h1 id="通配符类型-—-Wildcard-Types"><a href="#通配符类型-—-Wildcard-Types" class="headerlink" title="通配符类型 — Wildcard Types"></a>通配符类型 — Wildcard Types</h1><p>类型通配符的分类</p><blockquote><ul><li>类型通配符：<?>List<?>：表示元素类型未知的List，它的元素可以匹配任何的类型<br>这种带通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</li><li>类型通配符上限：&lt;? extends 类型&gt;<br>List&lt;? extends Number&gt;：它表示的类型是Number或者其子类型（也就是最大的就是Number类型）</li><li>类型通配符下限：&lt;? super 类型&gt;<br>List&lt;? super Number&gt;：它表示的类型是Number或者其父类型（也就是最小的就是Number类型）</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GenericDemo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">//类型通配符：&lt;?&gt;</span><br>        List&lt;?&gt; list1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>        List&lt;?&gt; list2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>        List&lt;?&gt; list3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br><br>        <span class="hljs-comment">//类型通配符上限：&lt;? extends 类型&gt;</span><br>        <span class="hljs-comment">//上线Number就是做大的，所以Object不行</span><br><span class="hljs-comment">//        List&lt;? extends Number&gt; list4 = new ArrayList&lt;Object&gt;();</span><br>        List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; list5 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>        List&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; list6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>        System.out.println(<span class="hljs-string">&quot;--------&quot;</span>);<br><br>        <span class="hljs-comment">//类型通配符下限：&lt;? super 类型&gt;</span><br>        List&lt;? <span class="hljs-built_in">super</span> Number&gt; list7 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Object&gt;();<br>        List&lt;? <span class="hljs-built_in">super</span> Number&gt; list8 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Number&gt;();<br>        <span class="hljs-comment">//下线就是Number最小的，所以其子类，Interger不行</span><br><span class="hljs-comment">//        List&lt;? super Number&gt; list9 = new ArrayList&lt;Integer&gt;();</span><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- 内部类 Inner Class</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%86%85%E9%83%A8%E7%B1%BB%20Inner%20Class/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%86%85%E9%83%A8%E7%B1%BB%20Inner%20Class/</url>
    
    <content type="html"><![CDATA[<h1 id="内部类的类别"><a href="#内部类的类别" class="headerlink" title="内部类的类别"></a>内部类的类别</h1><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><blockquote><ul><li>成员内部类是最普通的内部类，它的定义为位于另一个类的内部</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Circle称为外部类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span> &#123;     <span class="hljs-comment">//内部类</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSahpe</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;drawshape&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内部类访问外部类</strong></p><blockquote><ul><li>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-type">privatedouble</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">publicstaticint</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span> &#123;     <span class="hljs-comment">//内部类</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSahpe</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(radius);  <span class="hljs-comment">//外部类的private成员</span><br>            System.out.println(count);   <span class="hljs-comment">//外部类的静态成员</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>当成员内部类拥有和外部类同名的成员变量或者方法时，默认情况下访问的是成员内部类的成员</li><li>要以下面的形式进行访问：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">外部类.<span class="hljs-built_in">this</span>.成员变量<br>外部类.<span class="hljs-built_in">this</span>.成员方法<br></code></pre></td></tr></table></figure><p><strong>外部类访问内部类</strong></p><blockquote><ul><li>外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> &#123;<br>    <span class="hljs-type">privatedouble</span> <span class="hljs-variable">radius</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> radius)</span> &#123;<br>        <span class="hljs-built_in">this</span>.radius = radius;<br>        getDrawInstance().drawSahpe();   <span class="hljs-comment">//必须先创建成员内部类的对象，再进行访问</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Draw <span class="hljs-title function_">getDrawInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Draw</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Draw</span> &#123;     <span class="hljs-comment">//内部类</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drawSahpe</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(radius);  <span class="hljs-comment">//外部类的private成员</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>创建内部类对象</strong></p><blockquote><ul><li>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> classTest &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  &#123;<br>        <span class="hljs-comment">//第一种方式：</span><br>        <span class="hljs-type">Outter</span> <span class="hljs-variable">outter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Outter</span>();<br>        Outter.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> outter.<span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();  <span class="hljs-comment">//必须通过Outter对象来创建</span><br><br>        <span class="hljs-comment">//第二种方式：</span><br>        Outter.<span class="hljs-type">Inner</span> <span class="hljs-variable">inner1</span> <span class="hljs-operator">=</span> outter.getInnerInstance();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Outter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Inner</span> <span class="hljs-variable">inner</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Outter</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> Inner <span class="hljs-title function_">getInnerInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(inner == <span class="hljs-literal">null</span>)<br>            inner = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Inner</span>();<br>        <span class="hljs-keyword">return</span> inner;<br>    &#125;<br><br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">Inner</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Inner</span><span class="hljs-params">()</span> &#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>内部类的访问权限</strong></p><blockquote><ul><li>内部类可以被 private，protected，public修饰， 同时也有包访问权限（默认访问权限，无任何关键字)<blockquote><ul><li>private修饰，则只能在外部类的内部访问</li><li>public修饰，则任何地方都能访问</li><li>protected修饰，则只能在同一个包下或者继承外部类的情况下访问</li><li>如果是默认访问权限，则只能在同一个包下访问</li></ul></blockquote></li><li><strong>外部类只能被public和包访问两种权限修饰</strong></li></ul></blockquote><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><blockquote><ul><li>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static</li><li>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似</li><li>它不能使用外部类的非static成员变量或者方法<blockquote><ul><li>因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>下面代码中, 如果TaskOne和TaskTwo不用static修饰, 则不能直接在main中创建对应的实例</li><li>因为TaskOne和TaskTwo都为内部类, 而内部类是依赖于外部类(只有先创建外部类实例才能创建内部类实例)</li><li>所以将TaskOne和TaskTwo变为静态内部类,则可以直接现在main中创建对应实例, 因为静态内部类是不需要依赖于外部类的</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SimpleThread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRunnable</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskOne</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>count++;<br>System.out.println(<span class="hljs-string">&quot;taskOne: &quot;</span> + count);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">500</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskTwo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>count++;<br>System.out.println(<span class="hljs-string">&quot;taskTwo: &quot;</span> + count);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//TaskOne和TaskTwo变为静态内部类,则可以直接现在main中创建对应实例, 因为静态内部类是不需要依赖于外部类的</span><br><span class="hljs-type">TaskOne</span> <span class="hljs-variable">taskOne</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskOne</span>();<br><span class="hljs-type">TaskTwo</span> <span class="hljs-variable">taskTwo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskTwo</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(taskOne);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(taskTwo);<br>t1.start();<br>t2.start();<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><blockquote><ul><li>局部内部类是定义在一个方法或者一个作用域里面的类</li><li>局部内部类的访问仅限于方法内或者该作用域内, 并且只能访问局部final变量</li><li>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">People</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">People</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Man</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Man</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> People <span class="hljs-title function_">getWoman</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">class</span> <span class="hljs-title class_">Woman</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">People</span>&#123;   <span class="hljs-comment">//局部内部类</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br>        &#125;<br>        returnnew <span class="hljs-title function_">Woman</span><span class="hljs-params">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><blockquote><ul><li>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护</li><li>使用匿名内部类能够在实现父类或者接口中的方法情况下  同时产生一个相应的对象<br>但是前提是这个父类或者接口必须先存在才能这样使用。</li><li>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调</li><li>匿名内部类在编译的时候由系统自动起名为Outter</li><li>局部内部类和匿名内部类只能访问局部final变量</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java">editText.addTextChangedListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TextWatcher</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeTextChanged</span><span class="hljs-params">(CharSequence s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> count, <span class="hljs-type">int</span> after)</span> &#123;<br><br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onTextChanged</span><span class="hljs-params">(CharSequence s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> before, <span class="hljs-type">int</span> count)</span> &#123;<br>                        adapter.getFilter().filter(s);<br>                    &#125;<br><br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterTextChanged</span><span class="hljs-params">(Editable s)</span> &#123;<br><br>                    &#125;<br>                &#125;);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TextWatcher</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">NoCopySpan</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeTextChanged</span><span class="hljs-params">(CharSequence var1, <span class="hljs-type">int</span> var2, <span class="hljs-type">int</span> var3, <span class="hljs-type">int</span> var4)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onTextChanged</span><span class="hljs-params">(CharSequence var1, <span class="hljs-type">int</span> var2, <span class="hljs-type">int</span> var3, <span class="hljs-type">int</span> var4)</span>;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterTextChanged</span><span class="hljs-params">(Editable var1)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="匿名内部类和接口回调"><a href="#匿名内部类和接口回调" class="headerlink" title="匿名内部类和接口回调"></a>匿名内部类和接口回调</h3><blockquote><ul><li>接口回调: 将接口作为参数传入方法，方法内调用接口的方法</li></ul></blockquote><p>声明一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyCallInterface</span> &#123;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">printName</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyCallInterface</span> &#123;<br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">()</span> &#123;<br>          System.out.println(<span class="hljs-string">&quot;This is the client printName method&quot;</span>);<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Caller</span> &#123;<br>    <span class="hljs-comment">//保存一个接口引用</span><br>    <span class="hljs-keyword">private</span> MyCallInterface callInterface;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Caller</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>    <span class="hljs-comment">// 接口作为参数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCallFunc</span><span class="hljs-params">(MyCallInterface callInterface)</span> &#123;<br>         <span class="hljs-built_in">this</span>.callInterface = callInterface;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>         callInterface.printName();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>         <span class="hljs-type">Caller</span> <span class="hljs-variable">caller</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Caller</span>();<br>         caller.setCallFunc(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>());<br>         caller.call();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在测试方法中直接使用匿名类，省去单独写一个class实现接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Caller</span> <span class="hljs-variable">caller</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Caller</span>();<br>        <span class="hljs-comment">//caller.setCallFunc(new Client());使用匿名类代替</span><br>        caller.setCallFunc(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallInterface</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printName</span><span class="hljs-params">()</span> &#123;<br>                 System.out.println(<span class="hljs-string">&quot;This is the client printName method&quot;</span>);<br>            &#125;<br>        &#125;);<br>        caller.call();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Fragment与Activity使用接口回调通信"><a href="#Fragment与Activity使用接口回调通信" class="headerlink" title="Fragment与Activity使用接口回调通信"></a>Fragment与Activity使用接口回调通信</h3><blockquote><ul><li>在Fragment中定义一个接口,接口中定义抽象方法,传什么类型的数据参数就设置为什么类型</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*接口*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CallBack</span>&#123;<br>    <span class="hljs-comment">/*定义一个获取信息的方法*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(String result)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>在Fragment中接着还有写一个调用接口中的抽象方法,把要传递的数据传过去</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*接口回调*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getData</span><span class="hljs-params">(CallBack callBack)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> medit.getText().toString();<br>    <span class="hljs-comment">//这里调用getResult方法, 具体的实现在匿名类中实现</span><br>    callBack.getResult(msg);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>在Activity中适当时机使用接口，重写抽象方法获取数据</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">MyFragment</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFragment</span>();<br>getSupportFragmentManager().beginTransaction().add(R.id.mylayout, f1).commit();<br>button = (Button) findViewById(R.id.btn);<br>button.setOnClickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-comment">//调用getDanta方法, 将new MyFragment.CallBack() 传入</span><br>        f1.getData(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFragment</span>.CallBack() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-comment">//使用接口回调获取数据</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">(String result)</span> &#123;              <span class="hljs-comment">/*打印信息*/</span><br>                 <span class="hljs-comment">//这里是匿名类的具体实现, msg被传入</span><br>                Toast.makeText(MainActivity.<span class="hljs-built_in">this</span>, result, Toast.LENGTH_LONG).show();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="深入内部类"><a href="#深入内部类" class="headerlink" title="深入内部类"></a>深入内部类</h1><h2 id="为什么成员内部类可以无条件访问外部类的成员"><a href="#为什么成员内部类可以无条件访问外部类的成员" class="headerlink" title="为什么成员内部类可以无条件访问外部类的成员"></a>为什么成员内部类可以无条件访问外部类的成员</h2><blockquote><ul><li>编译器会默认为成员内部类添加了一个指向外部类对象的引用</li><li>我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的Outter this&amp;0 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员</li><li>从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类的对象，则无法对Outter this&amp;0引用进行初始化赋值，也就无法创建成员内部类的对象了。</li><li>静态内部类是不持有指向外部类对象的引用的,所以不能调用外部类对象的方法和属性(static除外)</li></ul></blockquote><h2 id="为什么局部内部类和匿名内部类只能访问局部final变量"><a href="#为什么局部内部类和匿名内部类只能访问局部final变量" class="headerlink" title="为什么局部内部类和匿名内部类只能访问局部final变量"></a>为什么局部内部类和匿名内部类只能访问局部final变量</h2><blockquote><ul><li>局部内部类和外部类是处于同一个级别的，局部内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。</li><li>这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是局部内部类对象可能还存在(只有没有人再引用它时，才会死亡)。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量</li></ul></blockquote><p>解决方法：</p><blockquote><ul><li>将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的”copy”</li><li>问题又出现了：将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？</li></ul></blockquote><p><strong>使用final关键字</strong></p><blockquote><ul><li>就将局部变量设置为final，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是一种妥协。</li></ul></blockquote><h2 id="内部类的使用场景和好处"><a href="#内部类的使用场景和好处" class="headerlink" title="内部类的使用场景和好处"></a>内部类的使用场景和好处</h2><blockquote><p>1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，</p></blockquote><blockquote><p>2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</p></blockquote><blockquote><p>3.方便编写事件驱动程序</p></blockquote><blockquote><p>4.方便编写线程代码</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础 --- 异常 Exception</title>
    <link href="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/"/>
    <url>/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/</url>
    
    <content type="html"><![CDATA[<h1 id="Exception-类型"><a href="#Exception-类型" class="headerlink" title="Exception 类型"></a>Exception 类型</h1><blockquote><ul><li>所有的异常都从 <code>java.lang.Throwable</code> 继承</li></ul></blockquote><blockquote><ul><li>Exception class可以被分为三种类型 <strong>system errors</strong>, <strong>exception</strong>, <strong>runtime exceptions</strong><blockquote><ul><li><strong>Error</strong>: There is little you can do beyond notifying the user and trying to terminate the program gracefully. Example: <strong>LinkageError</strong>, <strong>VirtualMachineError</strong></li></ul></blockquote></li></ul><blockquote><ul><li><strong>Exceptions</strong>: describes errors caused by your program and by external circumstances. Example: <strong>ClassNotFoundException, IOException,</strong></li></ul></blockquote><blockquote><ul><li><strong>Runtime Exceptions</strong>: describes programming errors, such as bad casting, accessing an out-of-bounds array, and numeric errors. Example: <strong>NullPointerException, IndexOutOfBoundsException</strong><br><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/1.png" alt="在这里插入图片描述"></li></ul></blockquote></blockquote><blockquote><ul><li><strong>Unchecked Exception</strong>: 不用被强制的显式的抛出或者捕获, 包括 <strong>runtime exceptions</strong>, <strong>error</strong> 和它们的子类<br>In most cases, unchecked exceptions reflect programming logic errors that are unrecoverable. For example, <strong>NullPointerException</strong></li><li><strong>Checked Exception</strong>: 必须强制的被显式的抛出或者捕获(也就是使用try catch处理)，其余的exception都为checked exception</li></ul></blockquote><h1 id="使用Exception"><a href="#使用Exception" class="headerlink" title="使用Exception"></a>使用Exception</h1><p><strong>声明 Exception</strong></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception1<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">myMethod</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception1, Exception2, ..., ExceptionN<br></code></pre></td></tr></table></figure><p><strong>抛出Exception</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Wrong Argument&quot;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">IllegalArgumentException</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Wrong Argument&quot;</span>);<br><span class="hljs-keyword">throw</span> ex;<br></code></pre></td></tr></table></figure><blockquote><ul><li><strong>注意throw是抛出异常的时候用, throws是声明异常的时候用</strong></li></ul></blockquote><p><strong>Catch Exception</strong></p><blockquote><p><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/2.png" alt="在这里插入图片描述"></p><ul><li><strong>Note: 在method2中，如果exception不是ex3，没有被catch住，则程序直接跳会method1，statment5和statment6都不会执行。</strong></li></ul></blockquote><h1 id="Throwable-Class"><a href="#Throwable-Class" class="headerlink" title="Throwable Class"></a>Throwable Class</h1><blockquote><p><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/3.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/4.png" alt="在这里插入图片描述"><br>使用 Throwable<br><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/5.png" alt="在这里插入图片描述"></p></blockquote><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><blockquote><p><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/6.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/7.png" alt="在这里插入图片描述"></p></blockquote><h1 id="finally-关键字"><a href="#finally-关键字" class="headerlink" title="finally 关键字"></a>finally 关键字</h1><blockquote><ul><li>不管有没有exception发生, finally总会被执行<blockquote><ul><li>如果try中出现exception则程序不会回到try中, 执行完finally之后会继续往下执行</li></ul></blockquote></li><li><strong>即使在finally之前有return, finally里的代码还是会被执行</strong></li></ul></blockquote><p><strong>执行顺序  try - catch -finally</strong></p><blockquote><p><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/8.png" alt="在这里插入图片描述"></p></blockquote><blockquote><p>(假设try里有return)</p><ul><li>如果没有exception发生: statement4会被执行, statement 5不会被执行</li><li>如果有exception 并且是 Exception 1, 则4和5都会被执行 </li><li>如果有exception 并且不是 Exception 1, 则4会被执行, 然后程序报错</li></ul></blockquote><blockquote><p>(假设try里没有return)</p><ul><li>如果没有exception发生: statement4, statement 5都会被执行</li><li>如果有exception 并且是 Exception 1, 则4和5都会被执行 </li><li>如果有exception 并且不是 Exception 1, 则4会被执行, 然后程序报错</li></ul></blockquote><blockquote><ul><li>没有exception: try和finally里都有return: 会使用finally里的return<br><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/9.png" alt="在这里插入图片描述"></li></ul></blockquote><blockquote><ul><li>有exception, try,catch, finally里都有return: 会执行finally里的return<br><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/10.png" alt="在这里插入图片描述"></li></ul></blockquote><p><strong>总结:</strong> </p><blockquote><ul><li>如果finally里有return则一定会执行finally里的return</li><li>如果finally里没有return<blockquote><ul><li>没有exception的情况会执行try里的return, 如果try里没有return会继续finally之后的代码执行</li><li>有exception的情况会执行catch里的return,如果catch里没有return会继续finally之后的代码执行</li></ul></blockquote></li></ul></blockquote><p><strong>在finally中修改变量</strong></p><blockquote><ul><li>finally相当于一个方法, 变量相当于参数, 所以遵循java值传递的规则</li><li>下图中finally没有影响tryli的变量<br><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/11.png" alt="在这里插入图片描述"></li><li>以下代码中finally中的put方法起作用了, 但是map &#x3D; null没有起作用<br><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/12.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="Chained-Exception"><a href="#Chained-Exception" class="headerlink" title="Chained Exception"></a>Chained Exception</h1><blockquote><ul><li>Sometimes, you may need to throw a new exception (with additional information) along with the original exception. This is called chained exceptions.<br><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/13.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="自定义Exception"><a href="#自定义Exception" class="headerlink" title="自定义Exception"></a>自定义Exception</h1><p><img src="/2024/04/26/Java%20%E5%9F%BA%E7%A1%80%20---%20%E5%BC%82%E5%B8%B8%20Exception/14.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础--- 转型 Casting</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E8%BD%AC%E5%9E%8B%20Casting/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E8%BD%AC%E5%9E%8B%20Casting/</url>
    
    <content type="html"><![CDATA[<h1 id="基础类型转型"><a href="#基础类型转型" class="headerlink" title="基础类型转型"></a>基础类型转型</h1><h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><blockquote><ul><li>低类型可被自动转换成高类型</li><li>不能对boolean类型进行类型转换</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">低  -----------------------------------高<br><span class="hljs-type">byte</span>, <span class="hljs-type">short</span>, <span class="hljs-type">char</span> --&gt; <span class="hljs-type">int</span> --&gt; <span class="hljs-type">long</span> --&gt; <span class="hljs-type">float</span> --&gt; <span class="hljs-type">double</span><br></code></pre></td></tr></table></figure><h2 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h2><blockquote><ul><li>条件是转换的数据类型必须是兼容的 (比如int转换为byte, 则int的大小必须在 -127 - 127 之间)</li><li>格式：(type)value type是要强制类型转换后的数据类型</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">120</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (<span class="hljs-type">byte</span>)i;<br>System.out.println(b);<br></code></pre></td></tr></table></figure><h2 id="基础类型转换为String"><a href="#基础类型转换为String" class="headerlink" title="基础类型转换为String"></a>基础类型转换为String</h2><blockquote><p>使用基础类型对应包装类的parse方法, 包括: </p></blockquote><p><strong>Byte:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">byte</span><span class="hljs-title function_">parseByte</span><span class="hljs-params">(String s)</span>: Parses the string argument as a signed decimal <span class="hljs-type">byte</span>.<br><span class="hljs-keyword">static</span> <span class="hljs-type">byte</span><span class="hljs-title function_">parseByte</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> radix)</span>: Parses the string argument as a signed <span class="hljs-type">byte</span> in the radix specified by the second argument.<br></code></pre></td></tr></table></figure><p><strong>Short:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">parseShort</span><span class="hljs-params">(String s)</span>: Parses the string argument as a signed decimal <span class="hljs-type">short</span>.<br><span class="hljs-keyword">static</span> <span class="hljs-type">short</span> <span class="hljs-title function_">parseShort</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> radix)</span>: Parses the string argument as a signed <span class="hljs-type">short</span> in the radix specified by the second argument.<br></code></pre></td></tr></table></figure><p><strong>Integer</strong>: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">int</span><span class="hljs-title function_">parseInt</span><span class="hljs-params">(String s)</span>: Parses the string argument as a signed decimal integer.<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span><span class="hljs-title function_">parseInt</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> radix)</span>: Parses the string argument as a signed integer in the radix specified by the second argument.<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span><span class="hljs-title function_">parseUnsignedInt</span><span class="hljs-params">(String s)</span>: Parses the string argument as an unsigned decimal integer.<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span><span class="hljs-title function_">parseUnsignedInt</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> radix)</span>: Parses the string argument as an unsigned integer in the radix specified by the second argument.<br></code></pre></td></tr></table></figure><p><strong>Long</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">parseLong</span><span class="hljs-params">(String s)</span>  <br><span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">parseLong</span><span class="hljs-params">(String s, <span class="hljs-type">int</span> radix)</span>                 <br></code></pre></td></tr></table></figure><p><strong>Float</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">float</span> <span class="hljs-title function_">parseFloat</span><span class="hljs-params">(String s)</span>: Returns a <span class="hljs-keyword">new</span> <span class="hljs-title class_">float</span> initialized to the value represented by the specified String, as performed by the valueOf method of <span class="hljs-keyword">class</span> <span class="hljs-title class_">Float</span>.<br></code></pre></td></tr></table></figure><p><strong>Double</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">parseDouble</span><span class="hljs-params">(String s)</span>: Returns a <span class="hljs-keyword">new</span> <span class="hljs-title class_">double</span> initialized to the value represented by the specified String, as performed by the valueOf method of <span class="hljs-keyword">class</span> <span class="hljs-title class_">Double</span>.<br></code></pre></td></tr></table></figure><h1 id="引用类型转型"><a href="#引用类型转型" class="headerlink" title="引用类型转型"></a>引用类型转型</h1><h2 id="Upcastig-and-Implicitly-Casting"><a href="#Upcastig-and-Implicitly-Casting" class="headerlink" title="Upcastig and Implicitly Casting"></a>Upcastig and Implicitly Casting</h2><blockquote><ul><li>Upcasting:  父类的引用指向子类的对象实例（子类对象实例的声明类型为父类，向上转换了), 下面都是upcasting<blockquote><ul><li><code>Object o1 = new subclassOfObject()</code></li><li><code>o1 = s1</code></li></ul></blockquote></li></ul></blockquote><blockquote><ul><li><strong>Upcasting的变量的声明类型是父类，实际类型是子类</strong>，引用指向的是一个子类实例</li><li><strong>Upcasting的变量只能使用父类的方法</strong>，而不能使用子类独有的方法</li><li>Implicitly casting: 编译器可自动完成upcasting</li></ul></blockquote><p> <strong>Example 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;This is fruit&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;This is Apple&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appleJuice</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Apple Juice&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Peach</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;This is peach&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">peachJuice</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Peach Juice&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayType</span><span class="hljs-params">(Fruit o)</span> &#123;<br><span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Peach) &#123;<br>((Peach) o).peachJuice();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Apple) &#123;<br>((Apple) o).appleJuice();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Fruit</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Peach</span>();<br><span class="hljs-type">Fruit</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Apple</span>();<br>o1.type();<br>o2.type();<br><span class="hljs-comment">//o1.peachJuice; Error</span><br><span class="hljs-comment">//o2.appleJuice; Error</span><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>O1 和 O2的声明类型为Fruit，但是实际类型为Peach和Apple</li><li>此时O1，O2只能使用父类的方法，而不能使用子类独有的方法（动态绑定），所以25，26行会报错</li></ul></blockquote><p><strong>Example 2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Fruit</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;This is fruit&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;This is Apple&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appleJuice</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Apple Juice&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Peach</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Fruit</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">type</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;This is peach&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">peachJuice</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;Peach Juice&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">displayType</span><span class="hljs-params">(Fruit o)</span> &#123;<br><span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Peach) &#123;<br>((Peach) o).peachJuice();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(o <span class="hljs-keyword">instanceof</span> Apple) &#123;<br>((Apple) o).appleJuice();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Fruit</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Fruit</span>();<br><span class="hljs-type">Fruit</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Peach</span>();<br><br><span class="hljs-comment">//check memory address:</span><br>System.out.println(<span class="hljs-string">&quot;before casting: f1 address is &quot;</span> + f1.toString());<br>System.out.println(<span class="hljs-string">&quot;before casting: p1 address is &quot;</span> + p1.toString());<br><br><br>f1 = p1; <span class="hljs-comment">//upcasting</span><br><span class="hljs-comment">//after casting the decalred type of f1 is Fruit, and the actual type is peach</span><br><br><br><span class="hljs-comment">//check memory address:</span><br>System.out.println(<span class="hljs-string">&quot;---------------------------------------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;after casting: f1 address is &quot;</span> + f1.toString());<br>System.out.println(<span class="hljs-string">&quot;after casting: p1 address is &quot;</span> + p1.toString());<br><br><br>System.out.println(<span class="hljs-string">&quot;---------------------------------------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;check what methods that f1 can use: &quot;</span>);<br>f1.type(); <br><span class="hljs-comment">//f1.peachJuice(); Error</span><br><br>System.out.println(<span class="hljs-string">&quot;check what methods that p1 can use: &quot;</span>);<br>p1.type();<br>&#125;<br><br>&#125;<br><br>output:<br>before casting: f1 address is upcasting.Fruit@3fee733d<br>before casting: p1 address is upcasting.Peach@5acf9800<br>---------------------------------------------<br>after casting: f1 address is upcasting.Peach@5acf9800<br>after casting: p1 address is upcasting.Peach@5acf9800<br>---------------------------------------------<br>check what methods that f1 can use: <br>This is peach<br>check what methods that p1 can use: <br>This is peach<br></code></pre></td></tr></table></figure><blockquote><ul><li>在upcasting之前，f1，p1的地址不一样</li><li>在upcasting之后，f1的地址更改为p1的地址，并且类型改为peach</li><li><strong>在Upcasting之后，虽然f1的地址为p1的地址，并且类型也是peach，但是还是不能使用p1的独有方法</strong>。<blockquote><ul><li>这是因为f1的声明类型依然是fruit，实际类型是peach，需要遵守动态绑定，所以p1的独有方法不能使用。</li></ul></blockquote></li></ul></blockquote><h2 id="Downcasting-and-Explicitly-Casting"><a href="#Downcasting-and-Explicitly-Casting" class="headerlink" title="Downcasting and  Explicitly Casting"></a>Downcasting and  Explicitly Casting</h2><blockquote><ul><li>Downcasting: 将子类的引用指向父类的对象实例<blockquote><ul><li>需要使用 (subclass type) superclass variable格式完成casting —- Explicitly Casting</li><li><code>subclass s = (subclass) Object</code></li></ul></blockquote></li><li><strong>downcast的类型要遵循object的实际类型</strong> (Example1)</li><li><strong>所以在downcasting之前, 必须判断被转型的类是子类的instance(, 用instance of关键字</strong><blockquote><ul><li>Instanceof :  只知道一个变量是superclass的instance，但是不确定是否是subclass的instance，此时需要用instanceof判断</li></ul></blockquote></li></ul></blockquote><p><strong>Example 1:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Car</span> <span class="hljs-variable">audi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Audi</span>();<br><span class="hljs-type">Audi</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (Audi)myCar;<br>a.AudiPrice();<br></code></pre></td></tr></table></figure><blockquote><ul><li>Car的实际类型也是Car，所以不能被downcasting</li><li>所以不能强行将一个子类的引用指向父类的对象,要先判断类型</li></ul></blockquote><h1 id="Upcasting和downcasting的实际作用-—–-实现多态"><a href="#Upcasting和downcasting的实际作用-—–-实现多态" class="headerlink" title="Upcasting和downcasting的实际作用 —– 实现多态"></a>Upcasting和downcasting的实际作用 —– 实现多态</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> downcasting;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Audi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">whatObject</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;This is the car object from Audi&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AudiPrice</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;The price for Audi is 20000&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//编译器进行了upcasting（implicitly）在display方法里，变量myCar的声明类型是Car，但实际类型是Audi或者Benz</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(Car myCar)</span> &#123;<br> <span class="hljs-comment">//但是调用实际类型的方法</span><br> myCar.whatObject();<br> <br> <span class="hljs-keyword">if</span> (myCar <span class="hljs-keyword">instanceof</span> Benz) &#123;<br>  <span class="hljs-comment">//进行downcasting</span><br> <span class="hljs-type">Benz</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> (Benz)myCar;<br> b.BenzPrice();<br> &#125;<br> <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (myCar <span class="hljs-keyword">instanceof</span> Audi) &#123;<br> <span class="hljs-comment">//进行downcasting</span><br> <span class="hljs-type">Audi</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> (Audi)myCar;<br> a.AudiPrice();<br> &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//声明一个 audi，benz类型的变量</span><br><span class="hljs-type">Audi</span> <span class="hljs-variable">audi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Audi</span>();<br><span class="hljs-type">Benz</span> <span class="hljs-variable">benz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benz</span>();<br><br>display(audi);<br>display(benz);<br>&#125;<br>&#125;<br><br>output:<br>This is the car object from Audi<br>The price <span class="hljs-keyword">for</span> Audi is <span class="hljs-number">20000</span><br>This is the car object from Benz<br>The price <span class="hljs-keyword">for</span> Benz is <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>   这样可以达到节省代码量，generic programming的目的，是多态的表现形式之一<br>如果没有upcasting，则需要写两遍display方法，如下：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> downcasting;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Audi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Car</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">whatObject</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;This is the car object from Audi&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">AudiPrice</span><span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;The price for Audi is 20000&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(Audi myCar)</span> &#123;<br> myCar.whatObject();<br> myCar.AudiPrice();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">display</span><span class="hljs-params">(Benz myCar)</span> &#123;<br> myCar.whatObject();<br> myCar.BenzPrice();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-type">Audi</span> <span class="hljs-variable">audi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Audi</span>();<br><span class="hljs-type">Benz</span> <span class="hljs-variable">benz</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Benz</span>();<br><br>display(audi);<br>display(benz);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h1><p><strong>对引用类型的Casting不会创建一个新的变量</strong><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E8%BD%AC%E5%9E%8B%20Casting/1.png" alt="在这里插入图片描述"></p><p><strong>java根据变量的声明类型判断类型是否一致</strong></p><blockquote><ul><li>   编译器没有报错，可以正常运行</li><li>   因为myAudi和car的声明类型都是Car，所以不会报错</li><li>   赋值完成后，myAudi的实际类型也变成car，彻底和子类失去联系</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String [] args)</span> &#123;<br>      <span class="hljs-type">Car</span> <span class="hljs-variable">myAudi</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Audi</span>();<br>      <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>      myAudi.whatObject();<br>      myAudi = car;<br>      myAudi.whatObject();<br>&#125;<br><br>output:<br>This is the car object from Audi<br>This is car object<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- 包装类和自动拆装箱 Wrapper Class and Autoboxing</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%20Wrapper%20Class%20and%20Autoboxing/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%20Wrapper%20Class%20and%20Autoboxing/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是包装类"><a href="#什么是包装类" class="headerlink" title="什么是包装类"></a>什么是包装类</h1><p><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%20Wrapper%20Class%20and%20Autoboxing/1.png" alt="在这里插入图片描述"></p><h1 id="为什么需要包装类and为什么需要基本数据类型"><a href="#为什么需要包装类and为什么需要基本数据类型" class="headerlink" title="为什么需要包装类and为什么需要基本数据类型"></a>为什么需要包装类and为什么需要基本数据类型</h1><blockquote><ul><li>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，将每个基本数据类型设计一个对应的类进行代表，这种方式增强了Java面向对象的性质。把基本数据类型包装成引用类型可以解决很多问题。比如：<blockquote><ul><li>在集合类中，我们是无法将int 、double等类型放进去的，因为集合的容器要求元素是Object类型。</li><li>当我们想知道int取值范围的最小值，我们需要通过运算，如下面所示，但是有了包装类，我们可以直接使用Integer.MAX_VALUE即可</li></ul></blockquote></li><li>为什么需要基本数据类型<blockquote><ul><li>引用类型存储在heap上，读写速度较慢。而基本数据类型存储在stack上，读写速度的比较快</li></ul></blockquote></li></ul></blockquote><h1 id="包装类和基本数据类型的转换"><a href="#包装类和基本数据类型的转换" class="headerlink" title="包装类和基本数据类型的转换"></a>包装类和基本数据类型的转换</h1><h2 id="由primitive-wrapper"><a href="#由primitive-wrapper" class="headerlink" title="由primitive -&gt; wrapper"></a>由primitive -&gt; wrapper</h2><blockquote><ul><li>以下写法已经被淘汰 –&gt; 替换成第二张图，原因是因为value of有缓存<br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%20Wrapper%20Class%20and%20Autoboxing/2.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%20Wrapper%20Class%20and%20Autoboxing/3.png" alt="在这里插入图片描述"></li><li>或者使用自动封箱（auto-boxing），Java自动调用ValueOf函数<br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%20Wrapper%20Class%20and%20Autoboxing/4.png" alt="在这里插入图片描述"></li></ul></blockquote><h2 id="由wrapper-–-primitive"><a href="#由wrapper-–-primitive" class="headerlink" title="由wrapper –&gt; primitive"></a>由wrapper –&gt; primitive</h2><blockquote><ul><li>使用value函数<br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%20Wrapper%20Class%20and%20Autoboxing/5.png" alt="在这里插入图片描述"></li><li>或使用自动拆箱（auto-unboxing）<br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%20Wrapper%20Class%20and%20Autoboxing/6.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="Wrapper-Class的缓存"><a href="#Wrapper-Class的缓存" class="headerlink" title="Wrapper Class的缓存"></a>Wrapper Class的缓存</h1><blockquote><ul><li>Java在第一次使用valueOf函数时，会通过静态代码块（static code block）创建一个常用值数组（ex: integer为-128到127），这样可以避免重复创建新的对象。</li><li>源代码分析（Integer类）<br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%20Wrapper%20Class%20and%20Autoboxing/7.png" alt="在这里插入图片描述"></li><li><strong>可以发现，只要Integer类第一次被使用到（因为创建Integer对象一定会用到valueOf函数，valueOf函数里用到了cache类，所以cache内部类会被加载），Integer的静态内部类就被加载，加载的时候会创建-128到127的Integer对象，同时创建一个数组cache来缓存这些对象。当使用valueOf()方法创建对象时，就直接返回已经缓存的对象，也就是说不会再新建对象；当使用new关键字or使用valueOf()方法创建小于-128大于127的值对象时，就会创建新对象。</strong></li></ul></blockquote><p><strong>各包装类的缓存范围</strong><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1%20Wrapper%20Class%20and%20Autoboxing/8.png" alt="在这里插入图片描述"></p><p><strong>关于缓存：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePassing</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">(Integer i, Integer j)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值前i的地址是: &quot;</span> + System.identityHashCode(i));<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后j的地址是: &quot;</span> + System.identityHashCode(j));<br><span class="hljs-comment">//对i和j同时赋予一样的值后（在-128-127之间)，地址一样</span><br>i = <span class="hljs-number">10</span>; <br>j = <span class="hljs-number">10</span>;<br>System.out.println(<span class="hljs-string">&quot;-----------------------------------------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后i的地址是: &quot;</span> + System.identityHashCode(i));<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后j的地址是: &quot;</span> + System.identityHashCode(j));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        System.out.println(<span class="hljs-string">&quot;在main中i的地址是: &quot;</span> + System.identityHashCode(i));<br>        System.out.println(<span class="hljs-string">&quot;在main中j的地址是: &quot;</span> + System.identityHashCode(j));<br>        System.out.println(<span class="hljs-string">&quot;-----------------------------------------------&quot;</span>);<br>        fun1(i, j);<br>    &#125;<br>&#125;<br><br>output:<br>在main中i的地址是: <span class="hljs-number">1072591677</span><br>在main中j的地址是: <span class="hljs-number">1523554304</span><br>-----------------------------------------------<br>在fun1中赋值前i的地址是: <span class="hljs-number">1072591677</span><br>在fun1中赋值后j的地址是: <span class="hljs-number">1523554304</span><br>-----------------------------------------------<br>在fun1中赋值后i的地址是: <span class="hljs-number">1175962212</span><br>在fun1中赋值后j的地址是: <span class="hljs-number">1175962212</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePassing</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">(Integer i, Integer j)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值前i的地址是: &quot;</span> + System.identityHashCode(i));<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后j的地址是: &quot;</span> + System.identityHashCode(j));<br><br><span class="hljs-comment">//不在-128-127之间地址则不一样</span><br>i = <span class="hljs-number">1000</span>; <br>j = <span class="hljs-number">1000</span>;<br>System.out.println(<span class="hljs-string">&quot;-----------------------------------------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后i的地址是: &quot;</span> + System.identityHashCode(i));<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后j的地址是: &quot;</span> + System.identityHashCode(j));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        System.out.println(<span class="hljs-string">&quot;在main中i的地址是: &quot;</span> + System.identityHashCode(i));<br>        System.out.println(<span class="hljs-string">&quot;在main中j的地址是: &quot;</span> + System.identityHashCode(j));<br>        System.out.println(<span class="hljs-string">&quot;-----------------------------------------------&quot;</span>);<br>        fun1(i, j);<br>    &#125;<br>&#125;<br><br>output:<br>在main中i的地址是: <span class="hljs-number">1072591677</span><br>在main中j的地址是: <span class="hljs-number">1523554304</span><br>-----------------------------------------------<br>在fun1中赋值前i的地址是: <span class="hljs-number">1072591677</span><br>在fun1中赋值后j的地址是: <span class="hljs-number">1523554304</span><br>-----------------------------------------------<br>在fun1中赋值后i的地址是: <span class="hljs-number">1175962212</span><br>在fun1中赋值后j的地址是: <span class="hljs-number">918221580</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- final关键字</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20final%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>@[TOC](Java基础 — final关键字)</p><h1 id="final修饰局部变量"><a href="#final修饰局部变量" class="headerlink" title="final修饰局部变量"></a>final修饰局部变量</h1><blockquote><ul><li>final修饰变量 — 则这个变量永远不能被修改<blockquote><ul><li>**对于基本类型来说，不可变说的是变量当中的数据不可改变</li><li>对于引用类型来说，不可变说的是变量当中的地址值不可改变**</li></ul></blockquote></li></ul></blockquote><h1 id="final修饰成员变量"><a href="#final修饰成员变量" class="headerlink" title="final修饰成员变量"></a>final修饰成员变量</h1><blockquote><ul><li>使用final关键字修饰，那么这个成员变量也是不可变</li><li>成员变量具有默认值，但是用了final之后必须手动赋值，不会再给默认值<blockquote><ul><li>对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一</li></ul></blockquote></li></ul></blockquote><h1 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h1><blockquote><ul><li>当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被重写, 但是可以被继承</li></ul></blockquote><h1 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h1><blockquote><ul><li>当final关键字用来修饰一个类的时候，这个方法就是最终类，也就是不能被继承, 没有子类</li></ul></blockquote><h1 id="final和多线程"><a href="#final和多线程" class="headerlink" title="final和多线程"></a>final和多线程</h1><blockquote><ul><li>由于指令重排的作用，一个线程读取到一个对象的引用时，该对象可能尚未初始化完毕，即这些线程可能读取到该对象的默认值而不是初始值。(比如0或者null)</li><li>final关键字具有特殊的作用：当一个对象发布到其他线程的时候，该对象的所有final变量都是初始化完成的<blockquote><ul><li>即其他线程读取到的都是相应字段的初始值而不是默认值。而非final变量就没有这种保障。</li></ul></blockquote></li><li>对于final修饰的引用类型的变量，该保障该变量所引用的对象 初始化完毕, 而不是null</li><li>这种机制是通过禁止重排序实现的</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- static关键字</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20static%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="静态成员-—-Static-Fields"><a href="#静态成员-—-Static-Fields" class="headerlink" title="静态成员 — Static Fields"></a>静态成员 — Static Fields</h1><blockquote><ul><li>一个类只有这一个这样的成员实例, 直接用类名调用</li><li>即使没有对象实例, 静态成员也存在</li></ul></blockquote><p>Example: 给每个雇员产生unique ID</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">()</span> &#123;<br>id = nextId;<br>nextId++;<br>&#125;<br><br>harry.id = Employee.nextId;<br>Employee.nextId++;<br></code></pre></td></tr></table></figure><h1 id="静态常量-—-Static-Constant"><a href="#静态常量-—-Static-Constant" class="headerlink" title="静态常量 — Static Constant"></a>静态常量 — Static Constant</h1><blockquote><ul><li>和静态成员一样, 只不过是常量</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Math</span> &#123;<br> . . .<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265358979323846</span>;<br> . . .<br>&#125;<br>Math.PI.<br></code></pre></td></tr></table></figure><p>Another static constant that you have used many times is System.out. It is declared in the System class as follows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">System</span> &#123;<br> . . .<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">PrintStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> . . .;<br> . . .<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>it is never a good idea to have public fields, because everyone can modify them. </li><li>However, public constants (that is, final fields) are fine. Since out has been declared as final, you cannot reassign another print stream to it: <code>System.out = new PrintStream(. . .); // Error--out is final</code></li></ul></blockquote><h1 id="静态方法-—-Static-Methods"><a href="#静态方法-—-Static-Methods" class="headerlink" title="静态方法 —  Static Methods"></a>静态方法 —  Static Methods</h1><blockquote><ul><li>静态方法跟类的对象没有关系, 不管有没有对象实例, 静态方法都存在. 也是直接用类名调用</li><li>静态方法不能使用非静态成员变量, 但是可以使用静态成员变量</li></ul></blockquote><p>什么时候使用静态方法:</p><blockquote><ul><li>当一个方法不需要使用对象的状态, 也就是所需的参数都是外部直接传入的, 比如: <code>Math.pow</code></li><li>当一个方法使用的都是静态成员变量时</li></ul></blockquote><h1 id="静态类-—-Static-Class"><a href="#静态类-—-Static-Class" class="headerlink" title="静态类 — Static Class"></a>静态类 — Static Class</h1><blockquote><ul><li>只有内部类可以是静态的, 也只有内部类可以用static关键字修饰</li><li>静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似</li><li>它不能使用外部类的非static成员变量或者方法<blockquote><ul><li>因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象</li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>下面代码中, 如果TaskOne和TaskTwo不用static修饰, 则不能直接在main中创建对应的实例</li><li>因为TaskOne和TaskTwo都为内部类, 而内部类是依赖于外部类(只有先创建外部类实例才能创建内部类实例)</li><li>所以将TaskOne和TaskTwo变为静态内部类,则可以直接现在main中创建对应实例, 因为静态内部类是不需要依赖于外部类的</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> SimpleThread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRunnable</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskOne</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>count++;<br>System.out.println(<span class="hljs-string">&quot;taskOne: &quot;</span> + count);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">500</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskTwo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>count++;<br>System.out.println(<span class="hljs-string">&quot;taskTwo: &quot;</span> + count);<br><span class="hljs-keyword">try</span> &#123;<br>Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br><span class="hljs-comment">// TODO Auto-generated catch block</span><br>e.printStackTrace();<br>&#125;<br>&#125;<br><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">//TaskOne和TaskTwo变为静态内部类,则可以直接现在main中创建对应实例, 因为静态内部类是不需要依赖于外部类的</span><br><span class="hljs-type">TaskOne</span> <span class="hljs-variable">taskOne</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskOne</span>();<br><span class="hljs-type">TaskTwo</span> <span class="hljs-variable">taskTwo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskTwo</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(taskOne);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(taskTwo);<br>t1.start();<br>t2.start();<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- 构造函数和super关键字</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h1 id="有参数构造函数和无参数构造函数"><a href="#有参数构造函数和无参数构造函数" class="headerlink" title="有参数构造函数和无参数构造函数"></a>有参数构造函数和无参数构造函数</h1><p><strong>无参构造函数:</strong></p><blockquote><ul><li>在创建对象时自动调用无参构造函数</li></ul></blockquote><p><strong>有参数构造函数</strong></p><blockquote><ul><li>一个类可以用很多有参构造函数, 也叫constructor overloading</li><li>创建对象时, 根据参数类型和顺序判断调用哪个构造函数</li><li><strong>如果定义了有参构造函数, 则没有无参构造函数 除非显性的写出来</strong></li></ul></blockquote><h1 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h1><p><strong>使用super调用父类constructor</strong></p><blockquote><ul><li><code>super()</code>: The statement super() invokes the no-arg constructor of its superclass</li><li><code>super(argument)</code>:  super(arguments) invokes the superclass constructor that matches the arguments</li></ul></blockquote><p>编译器自动调用super</p><blockquote><ul><li>如果子类的constructor没有显示的调用父类的构造函数, 则编译器自动调用<br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97/1.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="Constructor-Chaining"><a href="#Constructor-Chaining" class="headerlink" title="Constructor Chaining"></a>Constructor Chaining</h1><p><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97/2.png" alt="在这里插入图片描述"><br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97/3.png" alt="在这里插入图片描述"></p><h1 id="如果一个类会被继承-最好显性的写出无参构造函数"><a href="#如果一个类会被继承-最好显性的写出无参构造函数" class="headerlink" title="如果一个类会被继承, 最好显性的写出无参构造函数"></a>如果一个类会被继承, 最好显性的写出无参构造函数</h1><p><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97/4.png" alt="在这里插入图片描述"></p><blockquote><ul><li>上图中Apple没有显性的定义构造函数,则Apple的无参构造函数会被调用</li><li>Apple的无参构造函数会自动调用Fruit的无参构造函数, 但是Fruit有定义有参构造函数,所以没有无参构造函数了</li><li>所以需要在Fruit显性的定义无参构造函数.</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- 重载和重写 Overloading and Overriding</title>
    <link href="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%20Overloading%20and%20Overriding/"/>
    <url>/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%20Overloading%20and%20Overriding/</url>
    
    <content type="html"><![CDATA[<p>@[TOC](Java基础 — 重载和重写 Overloading and Overriding)</p><h1 id="重载–-Overload"><a href="#重载–-Overload" class="headerlink" title="重载– Overload"></a>重载– Overload</h1><blockquote><ul><li>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</li><li>每个重载的方法都必须有一个独一无二的参数类型列表。</li><li>最常用的地方就是构造函数的重载。</li></ul></blockquote><p><strong>重载规则</strong></p><blockquote><ul><li>被重载的方法必须改变参数列表(参数个数或类型不一样)；<blockquote><ul><li><pre><code class="hljs">可以是类型不一样，或者顺序不一样，或者个数不一样</code></pre></li></ul></blockquote></li><li><pre><code class="hljs">被重载的方法可以改变返回类型；</code></pre></li><li><pre><code class="hljs">被重载的方法可以改变访问修饰符；</code></pre></li><li><pre><code class="hljs">被重载的方法可以声明新的或更广的检查异常</code></pre></li><li>   方法能够在同一个类中或者在一个子类中被重载。</li><li>   无法以返回值类型作为重载函数的区分标准（不能只有返回值不同）<blockquote><ul><li>对于 int fun(int x) 和 String fun(int x), 当把返回值赋值时是可以区分的，比如<br>String output &#x3D; fun（int x）此时是可以区分的，但是当没有赋值时是区分不出来的， <strong>比如只写 fun（7）, 此时Java不知道调用哪个方法，所以无法以返回值类型作为重载函数的区分标准</strong></li></ul></blockquote></li><li>Example<br><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%20Overloading%20and%20Overriding/1.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="重写-–-Override"><a href="#重写-–-Override" class="headerlink" title="重写 – Override"></a>重写 – Override</h1><blockquote><ul><li><pre><code class="hljs">子类对父类重写: 子类对父类的允许访问的方法的实现过程进行重新编写</code></pre></li><li>重写interface: 对所用的interface里的方法进行重写, 必须要重写interface里所有方法(可以不写具体实现, 但是要写method signature)</li></ul></blockquote><p><strong>重写规则</strong></p><blockquote><ul><li>返回值和形参都不能改变<br>•子类可以重写父类的除了构造函数的任何方法。<blockquote><ul><li>构造函数不能被子类继承，因此也不可以被重写</li></ul></blockquote></li><li>   访问控制权限不能严于父类。<blockquote><ul><li>如：父类为default访问权限，则子类就为public或者default；若父类是public，则子类必须为public</li></ul></blockquote></li><li>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。<blockquote><ul><li>   例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。</li></ul></blockquote></li><li>   子类不能重写父类为private的方法</li><li>当需要使用父类的方法时，但子类又重写了父类的方法，这时需要使用super关键字调用父类方法</li><li><pre><code class="hljs">super() 和 this（）的区别：</code></pre><blockquote><ul><li>this（） 会先在本类中查找是否存在要调用的方法，如果不存在则查找父类中是否具备此方法。如果有则调用，否则出现编译时错误。</li><li><pre><code class="hljs">使用super（）会明确表示调用父类中的方法，直接去父类寻找要调用的方法。</code></pre></li></ul></blockquote></li></ul></blockquote><h1 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h1><p><img src="/2024/04/26/Java%E5%9F%BA%E7%A1%80%20---%20%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%20Overloading%20and%20Overriding/2.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础--- 静态绑定与动态绑定</title>
    <link href="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---%20%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/"/>
    <url>/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---%20%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<p>@[TOC](Java 基础— 静态绑定与动态绑定)</p><h1 id="declared-type-actual-type"><a href="#declared-type-actual-type" class="headerlink" title="declared type &#x2F; actual type"></a>declared type &#x2F; actual type</h1><blockquote><ul><li>   Object是declared type，</li><li>   String是actual type</li><li><pre><code class="hljs">declared type要大于actual type（继承关系） ---- 符合upcasting</code></pre><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---%20%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/1.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="Static-Binding-–-静态绑定"><a href="#Static-Binding-–-静态绑定" class="headerlink" title="Static Binding – 静态绑定"></a>Static Binding – 静态绑定</h1><blockquote><ul><li><strong>在编译的时候编译器就可以准确知道该调用哪个类的方法就是静态绑定</strong></li><li>•在Java中只有以下的方法是静态绑定：<blockquote><ul><li><strong>static方法</strong>：可以被子类继承，但是不能被子类重写（覆盖）. 所以编译器确认可以直接调用父类的静态方法</li><li><strong>private方法</strong>：不能被继承，则不能通过子类对象调用，而只能通过类本身的对象进行调用，所以可以说private方法是和方法所属的类进行绑定；</li><li>   <strong>构造方法</strong>：父类的构造方法不会被子类继承, 所以可以直接和类绑定</li><li>   <strong>final方法</strong>: 可以被继承，但是不能被重写(覆盖), 虽然子类对象可以调用，但是调用的都是父类中的final方法</li></ul></blockquote></li></ul></blockquote><h1 id="Dynamic-Binding-–-动态绑定"><a href="#Dynamic-Binding-–-动态绑定" class="headerlink" title="Dynamic Binding – 动态绑定"></a>Dynamic Binding – 动态绑定</h1><blockquote><ul><li>在编译时候编译器不知道要调用哪个类的方法，</li><li>当程序运行时，JVM会根据实际类型从最底层的类一层一层往上找到implementation，并执行找到的第一个Implementation</li><li>在写代码时，<strong>一个变量只能使用声明类型的方法，不能使用声明类型中不存在的方法</strong></li><li>下图中，方法helloFromC在其父类（声明类型）中没有定义，所以会报错<br> <img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---%20%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/2.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="为什么要区分动态绑定和静态绑定"><a href="#为什么要区分动态绑定和静态绑定" class="headerlink" title="为什么要区分动态绑定和静态绑定"></a>为什么要区分动态绑定和静态绑定</h1><blockquote><ul><li>什么使用静态绑定：对于在编译时就确定使用哪些方法可以加快运行速度，如static, private, final，构造方法.</li><li>为什么使用动态绑定：支持多态，例如一个答列表list中存有Chiness English, 其父类均为Person， 对于下面的语句：当执行sayHello的时候， 会根据person具体属于Chiness 或English 而执行相应的sayHello方法。<br><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---%20%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E4%B8%8E%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/3.png" alt="在这里插入图片描述"></li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础 --- 接口 Interface</title>
    <link href="/2024/04/25/Java%E5%9F%BA%E7%A1%80---%20%E6%8E%A5%E5%8F%A3%20Interface/"/>
    <url>/2024/04/25/Java%E5%9F%BA%E7%A1%80---%20%E6%8E%A5%E5%8F%A3%20Interface/</url>
    
    <content type="html"><![CDATA[<h1 id="Interface定义"><a href="#Interface定义" class="headerlink" title="Interface定义"></a>Interface定义</h1><blockquote><ul><li>因为java中没有多继承（一个子类只能有一个父类），所以提出了接口的概念</li><li>接口的本质——接口是一种特殊的抽象类，这种抽象类里面只包含常量和方法的定义，而没有变量和方法的实现.</li><li><strong>Java中接口可以多继承, 也就是一个接口同时继承多个接口</strong></li></ul></blockquote><h1 id="关于Interfece的成员变量和成员方法"><a href="#关于Interfece的成员变量和成员方法" class="headerlink" title="关于Interfece的成员变量和成员方法"></a>关于Interfece的成员变量和成员方法</h1><blockquote><ul><li>Interfce的属性（即成员变量）必须是声明成“public static final 类型，即使默认也是成“public static final”. （因为是static final类型，所以在声明时必须要初始化赋值）</li><li>Interface中的方法全部为抽象方法，但是不需要使用abstract修饰，并且默认权限也是public</li><li>Interface中没有构造方法</li></ul></blockquote><h1 id="关于Interface的继承"><a href="#关于Interface的继承" class="headerlink" title="关于Interface的继承"></a>关于Interface的继承</h1><blockquote><ul><li>一个类可以实现多个接口，接口里面的成员变量不专属于某个对象，都是静态的成员变量，是属于整个类的，因此一个类去实现多个接口也是无所谓的，不会存在对象之间互相冲突的问题。实现多个接口，也就实现了多重继承，而且又避免了多重继承容易出现问题的地方（菱形继承），这就是用接口实现多重继承的好处.</li><li>当一个类实现多个接口并且需要使用接口的方法时，需要进行类型转换<blockquote><ul><li>下图中Teacher同时实现people interface和id interface,<br>jobType是people interface的方法，idNumber是ID interface的方法<br><img src="/2024/04/25/Java%E5%9F%BA%E7%A1%80---%20%E6%8E%A5%E5%8F%A3%20Interface/1.png" alt="在这里插入图片描述"></li></ul></blockquote></li></ul></blockquote><blockquote><ul><li>Interface可以继承interface, 继承时使用extends 关键字。比如interfaceＢ继承interfaceA，而实现interfaceB的类必须要implement A和B的所有方法</li><li><strong>注意Java中接口可以多继承, 但是类不能多继承</strong></li></ul></blockquote><h1 id="interface的default方法和static方法"><a href="#interface的default方法和static方法" class="headerlink" title="interface的default方法和static方法"></a>interface的default方法和static方法</h1><blockquote><ul><li>接口中可以定义static方法，可通过接口名称.方法名（）调用，实现类不能继承static方法；</li><li>接口中可以定义default方法，default修饰的方法有方法体，表示这个方法的默认实现，子类可以直接调用，可以选择重写或者不重写；</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.skd.interfacemethod;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Description</span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span> virgosnail</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2018/12/12</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Human</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 必须被重写</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">oldMethod</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 实现类可以选择重写，也可以不重写</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hi</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;interface default method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 不能被实现类重写</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;interface static method&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="两个interface有名字相同的方法"><a href="#两个interface有名字相同的方法" class="headerlink" title="两个interface有名字相同的方法"></a>两个interface有名字相同的方法</h1><p><strong>signature完全一样</strong></p><blockquote><ul><li>如果signature完全一样，则只有一个implementation. 可以正常编译运行</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceTest</span> &#123;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Gift</span>  &#123; <span class="hljs-keyword">void</span> <span class="hljs-title function_">present</span><span class="hljs-params">()</span>; &#125;<br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Guest</span> &#123; <span class="hljs-keyword">void</span> <span class="hljs-title function_">present</span><span class="hljs-params">()</span>; &#125;<br><br>    <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Presentable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Gift</span>, Guest &#123; &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Presentable</span> <span class="hljs-variable">johnny</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Presentable</span>() &#123;<br>            <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">present</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Heeeereee&#x27;s Johnny!!!&quot;</span>);<br>            &#125;<br>        &#125;;<br>        johnny.present();                     <span class="hljs-comment">// &quot;Heeeereee&#x27;s Johnny!!!&quot;</span><br><br>        ((Gift) johnny).present();            <span class="hljs-comment">// &quot;Heeeereee&#x27;s Johnny!!!&quot;</span><br>        ((Guest) johnny).present();           <span class="hljs-comment">// &quot;Heeeereee&#x27;s Johnny!!!&quot;</span><br><br>        <span class="hljs-type">Gift</span> <span class="hljs-variable">johnnyAsGift</span> <span class="hljs-operator">=</span> (Gift) johnny;<br>        johnnyAsGift.present();               <span class="hljs-comment">// &quot;Heeeereee&#x27;s Johnny!!!&quot;</span><br><br>        <span class="hljs-type">Guest</span> <span class="hljs-variable">johnnyAsGuest</span> <span class="hljs-operator">=</span> (Guest) johnny;<br>        johnnyAsGuest.present();              <span class="hljs-comment">// &quot;Heeeereee&#x27;s Johnny!!!&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>return type不一样</strong></p><blockquote><ul><li>不能编译运行， 会报错</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">A</span> &#123;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">B</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">testIml</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">A</span>, B &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span> <span class="hljs-params">()</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;hello&quot;</span>) <span class="hljs-comment">//会报错</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>)</p><p><strong>其中一个或者都为default方法</strong></p><blockquote><ul><li>则必须重写</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">I1</span><br>&#123;<br>    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">getGreeting</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Good Morning!&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">I2</span><br>&#123;<br>    <span class="hljs-keyword">default</span> String <span class="hljs-title function_">getGreeting</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Good Afternoon!&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//会报错， 因为没有重写getGreeting</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">I1</span>, I2<br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">C1</span>().getGreeting());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>所以需要重写getGreeting</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">I1</span>, I2 <span class="hljs-comment">// this will compile, bacause we have overridden getGreeting()</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">C1</span>().getGreeting());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span> <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getGreeting</span><span class="hljs-params">()</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Good Evening!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="Nested-Interface-or-Inner-Interface"><a href="#Nested-Interface-or-Inner-Interface" class="headerlink" title="Nested Interface or Inner Interface"></a>Nested Interface or Inner Interface</h1><blockquote><ul><li>在一个接口里定义另外一个接口, 或者在一个类中定义一个接口</li><li>主要作用是解决interface的namspace问题( 只能通过另外一个类或者一个接口调用，解决了充满问题)<blockquote><ul><li>比如Map中的·Entry interface就是nested interface， 通过Map.Entry得到</li></ul></blockquote></li></ul></blockquote><p><img src="/2024/04/25/Java%E5%9F%BA%E7%A1%80---%20%E6%8E%A5%E5%8F%A3%20Interface/2.png" alt="在这里插入图片描述"><br><img src="/2024/04/25/Java%E5%9F%BA%E7%A1%80---%20%E6%8E%A5%E5%8F%A3%20Interface/3.png" alt="在这里插入图片描述"><br><img src="/2024/04/25/Java%E5%9F%BA%E7%A1%80---%20%E6%8E%A5%E5%8F%A3%20Interface/4.png" alt="在这里插入图片描述"></p><h1 id="Abstract-class和interface的区别"><a href="#Abstract-class和interface的区别" class="headerlink" title="Abstract class和interface的区别"></a>Abstract class和interface的区别</h1><p><img src="/2024/04/25/Java%E5%9F%BA%E7%A1%80---%20%E6%8E%A5%E5%8F%A3%20Interface/5.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java基础--- 抽象方法和类 Abstract Methods and Class</title>
    <link href="/2024/04/25/Java%E5%9F%BA%E7%A1%80---%20%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%20Abstract%20Methods%20and%20Class/"/>
    <url>/2024/04/25/Java%E5%9F%BA%E7%A1%80---%20%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%20Abstract%20Methods%20and%20Class/</url>
    
    <content type="html"><![CDATA[<h1 id="抽象方法-—-Abstract-Method"><a href="#抽象方法-—-Abstract-Method" class="headerlink" title="抽象方法  — Abstract Method"></a>抽象方法  — Abstract Method</h1><blockquote><ul><li>抽象方法只有方法声明没有具体实现,具体是现实是由子类提供</li><li>•抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法）<br> <img src="/2024/04/25/Java%E5%9F%BA%E7%A1%80---%20%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%20Abstract%20Methods%20and%20Class/1.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="抽象类-—-Abstract-Class"><a href="#抽象类-—-Abstract-Class" class="headerlink" title="抽象类  — Abstract Class"></a>抽象类  — Abstract Class</h1><blockquote><ul><li>用abstract修饰的类叫做抽象类，抽象类不能被实例化，即不能通过new生成一个抽象类的对象, <strong>作用是为某类定义通用方法。</strong></li><li>可以有抽象方法也可以有正常方法</li><li>构造方法必须声明为Protected（因为要供子类使用）<blockquote><ul><li>构造方法可以被private修饰,如果当前类只有一个构造方法且被private修饰,那么其它类是无法创建当前类的对象并且当前类也是不能被继承的(因为子类在实例化时需要调用父类的构造方法)</li></ul></blockquote></li><li>子类（如果不是抽象类）则必须覆写抽象类之中的全部抽象方法（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类）</li><li><strong>当一个类有抽象方法时，这个类必须为抽象类</strong></li><li><strong>一个类可以是抽象类即使它的父类不是抽象类</strong></li><li>一个类可以被声明为抽象类即使没有任何抽象方法, 这样的类一般被用于子类的基类</li></ul></blockquote><p>抽象类GeometricObject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GeometricObject</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">color</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;white&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> filled;<br>    <span class="hljs-keyword">private</span> java.util.Date dateCreated;<br><br>    <span class="hljs-comment">//无参构造函数</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">GeometricObject</span><span class="hljs-params">()</span>&#123;<br>        dateCreated = <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date();<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">GeometricObject</span><span class="hljs-params">(String color, <span class="hljs-type">boolean</span> filled)</span>&#123;<br>        dateCreated = <span class="hljs-keyword">new</span> <span class="hljs-title class_">java</span>.util.Date();<br>        <span class="hljs-built_in">this</span>.color = color;<br>        <span class="hljs-built_in">this</span>.filled = filled;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getColor</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setColor</span><span class="hljs-params">(String color)</span>&#123;<br>        <span class="hljs-built_in">this</span>.color = color;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFilled</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> filled;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setFilled</span><span class="hljs-params">(<span class="hljs-type">boolean</span> filled)</span>&#123;<br>        <span class="hljs-built_in">this</span>.filled = filled;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> java.util.Date <span class="hljs-title function_">getDateCreated</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> dateCreated;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;created on &quot;</span> + dateCreated + <span class="hljs-string">&quot;\ncolor: &quot;</span> + color +<br>                <span class="hljs-string">&quot; and filled: &quot;</span> + filled+<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//两个抽象方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPerimeter</span><span class="hljs-params">()</span>;<br>&#125;<span class="hljs-comment">//GeometricObject类结束</span><br></code></pre></td></tr></table></figure><p>抽象类的子类Triangle的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GeometricObject</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> side1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> side2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> side3;<br><br>    <span class="hljs-comment">//三个构造函数</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Triangle</span><span class="hljs-params">(<span class="hljs-type">double</span> side1, <span class="hljs-type">double</span> side2, <span class="hljs-type">double</span> side3)</span> &#123;<br>        <span class="hljs-built_in">this</span>.side1 = side1;<br>        <span class="hljs-built_in">this</span>.side2 = side2;<br>        <span class="hljs-built_in">this</span>.side3 = side3;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Triangle</span><span class="hljs-params">(String color, <span class="hljs-type">boolean</span> filled, <span class="hljs-type">double</span> side1, <span class="hljs-type">double</span> side2, <span class="hljs-type">double</span> side3)</span> &#123;<br>        <span class="hljs-built_in">super</span>(color, filled);<br>        <span class="hljs-built_in">this</span>.side1 = side1;<br>        <span class="hljs-built_in">this</span>.side2 = side2;<br>        <span class="hljs-built_in">this</span>.side3 = side3;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Triangle</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">//一定要重写实现抽象父类中的抽象方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getArea</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (side1 + side2 + side3)/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> Math.sqrt(s*(s-side1)*(s-side2)*(s-side3));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getPerimeter</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-keyword">return</span> side1+side2+side3;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Triangle&#123;&quot;</span> +<br>                <span class="hljs-built_in">super</span>.toString()+<br>                <span class="hljs-string">&quot;,side1=&quot;</span> + side1 +<br>                <span class="hljs-string">&quot;, side2=&quot;</span> + side2 +<br>                <span class="hljs-string">&quot;, side3=&quot;</span> + side3 +<br>                <span class="hljs-string">&quot;,Area = &quot;</span> + getArea()+<br>                <span class="hljs-string">&quot;,Perimeter =  &quot;</span> + getPerimeter()+<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="关于抽象类不能被实列化（使用new-operator）"><a href="#关于抽象类不能被实列化（使用new-operator）" class="headerlink" title="关于抽象类不能被实列化（使用new operator）"></a>关于抽象类不能被实列化（使用new operator）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">GeometricObject</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GrometricObject</span>()<br></code></pre></td></tr></table></figure><blockquote><ul><li>上面代码会报错</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">GeometricObject [] objects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GeometricObject</span>[<span class="hljs-number">10</span>]<br>object[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Circle</span>();<br></code></pre></td></tr></table></figure><blockquote><ul><li>上面代码不会报错</li></ul></blockquote><p><img src="/2024/04/25/Java%E5%9F%BA%E7%A1%80---%20%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95%E5%92%8C%E7%B1%BB%20Abstract%20Methods%20and%20Class/2.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础 --- Java变量储存机制及参数传递</title>
    <link href="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"/>
    <url>/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM内存机制"><a href="#JVM内存机制" class="headerlink" title="JVM内存机制"></a>JVM内存机制</h1><p><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/1.png" alt="在这里插入图片描述"></p><p><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/2.png" alt="在这里插入图片描述"></p><h1 id="Primitive-type的储存和值传递"><a href="#Primitive-type的储存和值传递" class="headerlink" title="Primitive type的储存和值传递"></a>Primitive type的储存和值传递</h1><h2 id="primitive-type的储存"><a href="#primitive-type的储存" class="headerlink" title="primitive type的储存"></a>primitive type的储存</h2><blockquote><ul><li>primitive type的局部变量是储存在JVM stack上, 首先JVM创建一个名为A的变量, 存在于局部变量表中，然后去栈中查找是否存有字面量值为10的内容，如果有就直接把A指向这个地址. 如果没有，JVM会在栈中开辟一块空间来存储10这个内容.</li><li>当写下 <code>int A = 10</code> 时:<br><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/3.png" alt="在这里插入图片描述"></li><li>当写下 <code>int A = 10, int B = 10</code> 时:<br><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/4.png" alt="在这里插入图片描述"></li><li>当 <code>int A = 10, int B = 10, B = 20;</code><br><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/5.png" alt="在这里插入图片描述"></li></ul></blockquote><h2 id="primitive-type的值传递"><a href="#primitive-type的值传递" class="headerlink" title="primitive type的值传递"></a>primitive type的值传递</h2><blockquote><ul><li>如下图，在执行main方法时，JVM会在栈顶加进一个栈帧，此栈帧包括一个A&#x3D;10的变量。在执行passPrimitive方法时，JAM会再加入一个新的栈帧，此栈帧包括一个B&#x3D;10的变量，当执行B&#x3D;100时，在passPrimitive栈帧中的B值会被改变，但在main栈帧中的A值不会被改<br><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/6.png" alt="在这里插入图片描述"></li><li>Before: A is 10</li><li>B is 100</li><li>After: A is 10</li></ul></blockquote><h1 id="Reference-Type的储存和值传递"><a href="#Reference-Type的储存和值传递" class="headerlink" title="Reference Type的储存和值传递"></a>Reference Type的储存和值传递</h1><h2 id="Reference-Type的储存"><a href="#Reference-Type的储存" class="headerlink" title="Reference Type的储存"></a>Reference Type的储存</h2><blockquote><ul><li>reference包括除基础类型之外的其他所有类型，变量中储存的时一个引用（在栈中存一个可以指向heap的引用），具体过程如下<br><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/7.png" alt="在这里插入图片描述"></li></ul></blockquote><h2 id="Reference-Type的传递"><a href="#Reference-Type的传递" class="headerlink" title="Reference Type的传递"></a>Reference Type的传递</h2><blockquote><ul><li>会改变实参<br><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/8.png" alt="在这里插入图片描述"></li><li>Before: S1’ID is 100</li><li>In The method: S1’ID is 200</li><li>After: S1’ID is 200</li></ul></blockquote><blockquote><ul><li>当执行第21行(Student s1 &#x3D; new Student())时<br><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/9.png" alt="在这里插入图片描述"></li><li>当执行第24行时（进入Test方法）<br><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80%20---%20Java%E5%8F%98%E9%87%8F%E5%82%A8%E5%AD%98%E6%9C%BA%E5%88%B6%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/10.png" alt="在这里插入图片描述"></li></ul></blockquote><p>总结：</p><blockquote><ul><li>在Java中没有引用传递，只有值传递。在Java中“值”的概念分为两种，一个是基础类型的实际数值，一个是引用，但是对于任何一种变量Java都拿不到地址（引用变量只是储存的是引用， 但是变量本身的地址是拿不到的， 也就是说Java中对对象的引用本身做不了任何操作，比如替换成另外一个引用）所以不存在引用传递。反之，在C++&#x2F;C中对于任何一个变量（基础变量，类，指针变量等）除了可以拿到变量里的值以外还可以拿到变量的地址，所以有值传递，引用传递，指针传递之分</li></ul></blockquote><h1 id="关于包装类的参数传递问题-Integer-as-example"><a href="#关于包装类的参数传递问题-Integer-as-example" class="headerlink" title="关于包装类的参数传递问题: Integer as example"></a>关于包装类的参数传递问题: Integer as example</h1><blockquote><ul><li>虽然所有的包装类都是引用传递，但是在函数中传递包装类并不能改变实参</li><li>因为所有的包装类都是不可变类, 也就是用final修饰,  比如<code>final int value</code>. 所以当对象被重新赋值时，会生成新的对象<blockquote><ul><li>根据Integer的缓存机制，如果在-128-127之间 就从常量池中获取一个Integer对象返回;如果不在范围内 会new Integer(value)返回</li></ul></blockquote></li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePassing</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">(Integer i)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值前i的地址是: &quot;</span> + System.identityHashCode(i));<br>i = <span class="hljs-number">10</span>; <span class="hljs-comment">//从常量池中获取一个Integer对象，或者new Integer(value)</span><br><span class="hljs-comment">//赋值之后，地址发生改变</span><br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后i的地址是: &quot;</span> + System.identityHashCode(i));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        System.out.println(<span class="hljs-string">&quot;在main中i的地址是: &quot;</span> + System.identityHashCode(i));<br>        fun1(i);<br>        <br>        i = <span class="hljs-number">20</span>;<br>        <span class="hljs-comment">//赋值之后，地址发生改变</span><br>        System.out.println(<span class="hljs-string">&quot;在main中i重新赋值之后的地址是: &quot;</span> + System.identityHashCode(i));<br>    &#125;<br>&#125;<br><br>output：<br>在main中i的地址是: <span class="hljs-number">1072591677</span><br>在fun1中赋值前i的地址是: <span class="hljs-number">1072591677</span><br>在fun1中赋值后i的地址是: <span class="hljs-number">1523554304</span><br>在main中i重新赋值之后的地址是: <span class="hljs-number">1175962212</span><br></code></pre></td></tr></table></figure><p><strong>关于缓存：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePassing</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">(Integer i, Integer j)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值前i的地址是: &quot;</span> + System.identityHashCode(i));<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后j的地址是: &quot;</span> + System.identityHashCode(j));<br><span class="hljs-comment">//对i和j同时赋予一样的值后（在-128-127之间)，地址一样</span><br>i = <span class="hljs-number">10</span>; <br>j = <span class="hljs-number">10</span>;<br>System.out.println(<span class="hljs-string">&quot;-----------------------------------------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后i的地址是: &quot;</span> + System.identityHashCode(i));<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后j的地址是: &quot;</span> + System.identityHashCode(j));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        System.out.println(<span class="hljs-string">&quot;在main中i的地址是: &quot;</span> + System.identityHashCode(i));<br>        System.out.println(<span class="hljs-string">&quot;在main中j的地址是: &quot;</span> + System.identityHashCode(j));<br>        System.out.println(<span class="hljs-string">&quot;-----------------------------------------------&quot;</span>);<br>        fun1(i, j);<br>    &#125;<br>&#125;<br><br>output:<br>在main中i的地址是: <span class="hljs-number">1072591677</span><br>在main中j的地址是: <span class="hljs-number">1523554304</span><br>-----------------------------------------------<br>在fun1中赋值前i的地址是: <span class="hljs-number">1072591677</span><br>在fun1中赋值后j的地址是: <span class="hljs-number">1523554304</span><br>-----------------------------------------------<br>在fun1中赋值后i的地址是: <span class="hljs-number">1175962212</span><br>在fun1中赋值后j的地址是: <span class="hljs-number">1175962212</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ValuePassing</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun1</span><span class="hljs-params">(Integer i, Integer j)</span> &#123;<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值前i的地址是: &quot;</span> + System.identityHashCode(i));<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后j的地址是: &quot;</span> + System.identityHashCode(j));<br><br><span class="hljs-comment">//不在-128-127之间地址则不一样</span><br>i = <span class="hljs-number">1000</span>; <br>j = <span class="hljs-number">1000</span>;<br>System.out.println(<span class="hljs-string">&quot;-----------------------------------------------&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后i的地址是: &quot;</span> + System.identityHashCode(i));<br>System.out.println(<span class="hljs-string">&quot;在fun1中赋值后j的地址是: &quot;</span> + System.identityHashCode(j));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br>        System.out.println(<span class="hljs-string">&quot;在main中i的地址是: &quot;</span> + System.identityHashCode(i));<br>        System.out.println(<span class="hljs-string">&quot;在main中j的地址是: &quot;</span> + System.identityHashCode(j));<br>        System.out.println(<span class="hljs-string">&quot;-----------------------------------------------&quot;</span>);<br>        fun1(i, j);<br>    &#125;<br>&#125;<br><br>output:<br>在main中i的地址是: <span class="hljs-number">1072591677</span><br>在main中j的地址是: <span class="hljs-number">1523554304</span><br>-----------------------------------------------<br>在fun1中赋值前i的地址是: <span class="hljs-number">1072591677</span><br>在fun1中赋值后j的地址是: <span class="hljs-number">1523554304</span><br>-----------------------------------------------<br>在fun1中赋值后i的地址是: <span class="hljs-number">1175962212</span><br>在fun1中赋值后j的地址是: <span class="hljs-number">918221580</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础 --- 权限访问修饰符</title>
    <link href="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---%E6%9D%83%E9%99%90%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/"/>
    <url>/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---%E6%9D%83%E9%99%90%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>Java有四种访问权限，其中三种有访问权限修饰符，分别为private，public和protected，还有一种不带任何修饰符：</p><ol><li>私有权限(private)</li></ol><blockquote><ul><li>private可以修饰成员变量，构造方法，方法，不能修饰类(此处指外部类，不考虑内部类)。被private修饰的成员，只能在定义它们的类中使用，在其他类中不能调用。</li></ul></blockquote><ol start="2"><li>默认权限(default)</li></ol><blockquote><ul><li>成员变量，构造方法，方法都能够使用默认权限，即无需写任何关键字。默认权限即同包权限，同包权限只能由本类中以及同包的类中访问。</li></ul></blockquote><ol start="3"><li>受保护权限(protected)</li></ol><blockquote><ul><li>protected可以修饰成员变量，构造方法，方法成员，不能修饰类(此处指外部类，不考虑内部类)。被protected修饰的成员，能在定义它们的类中，同包的类中被调用。如果有不同包的类想调用它们，那么这个类必须是定义它们的类的子类。</li></ul></blockquote><ol start="4"><li>公共权限(public)</li></ol><blockquote><ul><li>public可以修饰类，成员变量，构造方法，方法。被public修饰的成员，可以在任何一个类中被调用，不管同包或不同包，是权限最大的一个修饰符</li></ul></blockquote><p><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---%E6%9D%83%E9%99%90%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/1.png" alt="在这里插入图片描述"></p><p><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---%E6%9D%83%E9%99%90%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6/2.png" alt="在这里插入图片描述"></p><p>1.并不是每个修饰符都可以修饰类(指外部类)，只有public和default可以。<br>2.所有修饰符都可以修饰成员变量，方法，构造方法<br>3. 如果什么都不写, 则修饰权限符为 default<br>4.为了代码安全起见，修饰符不要使用权限更大的，只要适用即可。</p>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java 基础 --- Object Class</title>
    <link href="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---Object%20Class/"/>
    <url>/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---Object%20Class/</url>
    
    <content type="html"><![CDATA[<h1 id="Object-Class-结构"><a href="#Object-Class-结构" class="headerlink" title="Object Class 结构"></a>Object Class 结构</h1><p><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---Object%20Class/1.png" alt="ObjectClass结构"></p><h1 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h1><blockquote><ul><li>toString源码, 默认返回格式：对象的 class 名称 + @ + hashCode 的十六进制字符串</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RunoobTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>        <span class="hljs-comment">// toString() with Object</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        System.out.println(obj1.toString());<br> <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        System.out.println(obj2.toString());<br> <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        System.out.println(obj3.toString());<br>    &#125;<br>&#125;<br><br>以上程序执行结果为:<br>java.lang.Object<span class="hljs-meta">@d716361</span><br>java.lang.Object@6ff3c5b5<br>java.lang.Object@<span class="hljs-number">3764951d</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>根据实际需求重写, 一般print类中所有属性的值</li></ul></blockquote><h1 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h1><blockquote><ul><li>clone()方法是用于浅克隆或者深克隆一个java对象的</li><li>但是要注意一个误区：clone方法是Object类的，并不是Cloneable接口的，Cloneable只是一个标记接口，标记接口是用于标记实现该接口的类具有某种该接口标记的功能，常见的标记接口有三个：Serializable、Cloneable、RandomAccess，没有实现Cloneable接口，那么调用clone方法就会爆出<strong>CloneNotSupportedException</strong>异常。</li><li>要使得一个java类可以实现克隆，那么该类就需要实现Cloneable接口，并且重写基类Object的clone方法，其实Object的clone方法就已经默认有克隆的能力了，并且实现的是浅克隆，那为什么一定得重写clone方法呢？</li></ul></blockquote><blockquote><ul><li>我们先来看Object类的clone方法源码：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br></code></pre></td></tr></table></figure><blockquote><ul><li>方法被native关键字修饰，并且该方法没有方法体，没有方法体的方法我们认为是抽象方法，可是Object类并不是一个抽象类，而是一个具体类，那为什么还能容纳抽象方法呢，其实就是native关键字在起作用，被native关键字修饰的方法属于本地方法，表示Java的作用范围已经无法达到，底层会去调用C语言或者C++的库。</li></ul></blockquote><blockquote><ul><li>该方法是被protected修饰，这就表明我们在子类中不重写此方法，就在子类外无法访问，因为这个protected权限是仅仅能在Object所在的包和子类能访问的，这也验证了子类重写父类方法权限修饰符可以变大但不能变小的说法。</li></ul></blockquote><blockquote><ul><li>所以我们要使得一个类具有clone的能力，可以先实现Cloneable接口，再重写clone方法，方法内部去调用了父类的clone方法，其实是为了扩大访问权限，也可以把protected改为public，以后再继承就不用重写了。当然这只是浅克隆的clone函数，深克隆就需要修改clone的方法体了。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Mytest</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重写clone方法，调用父类默认的clone方法，实现的是浅克隆</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> CloneNotSupportedException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>————————————————<br>版权声明：本文为CSDN博主「can_chen」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/can_chen/article/details/106816513">https://blog.csdn.net/can_chen/article/details/106816513</a></p><h1 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h1><blockquote><ul><li>Object finalize() 方法用于实例被垃圾回收器回收的时触发的操作。</li><li>当 GC (垃圾回收器) 确定不存在对该对象的有更多引用时，对象的垃圾回收器就会调用这个方法。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RunoobTest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">GregorianCalendar</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建 RunoobTest 对象</span><br>            <span class="hljs-type">RunoobTest</span> <span class="hljs-variable">cal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunoobTest</span>();<br> <br>            <span class="hljs-comment">// 输出当前时间</span><br>            System.out.println(<span class="hljs-string">&quot;&quot;</span> + cal.getTime());<br> <br>            <span class="hljs-comment">// finalize cal</span><br>            System.out.println(<span class="hljs-string">&quot;Finalizing...&quot;</span>);<br>            cal.finalize();<br>            System.out.println(<span class="hljs-string">&quot;Finalized.&quot;</span>);<br> <br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br>输出结果:<br>Sun Oct <span class="hljs-number">11</span> <span class="hljs-number">11</span>:<span class="hljs-number">36</span>:<span class="hljs-number">46</span> CST <span class="hljs-number">2020</span><br>Finalizing...<br>Finalized.<br></code></pre></td></tr></table></figure><h1 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h1><blockquote><ul><li>Object getClass() 方法用于获取对象的运行时对象的类, 可以常在反射中用到<br>import java.util.ArrayList;</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RunoobTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <br>    <span class="hljs-comment">// getClass() with Object</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">obj1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    System.out.println(<span class="hljs-string">&quot;obj1 的类为: &quot;</span> + obj1.getClass());<br> <br>    <span class="hljs-comment">// getClass() with String</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">obj2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>();<br>    System.out.println(<span class="hljs-string">&quot;obj2 的类为: &quot;</span> + obj2.getClass());<br> <br>    <span class="hljs-comment">// getClass() with ArrayList</span><br>    ArrayList&lt;Integer&gt; obj3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    System.out.println(<span class="hljs-string">&quot;obj3 的类为: &quot;</span> + obj3.getClass());<br>    <br>    <span class="hljs-comment">// 创建 RunoobTest 类的对象</span><br>    <span class="hljs-type">RunoobTest</span> <span class="hljs-variable">obj4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunoobTest</span>();<br>    System.out.println(<span class="hljs-string">&quot;obj3 的类为: &quot;</span> + obj4.getClass());<br>    &#125;<br>&#125;<br><br>以上程序执行结果为:<br>obj1 的类为: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.Object<br>obj2 的类为: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.lang.String<br>obj3 的类为: <span class="hljs-keyword">class</span> <span class="hljs-title class_">java</span>.util.ArrayList<br>obj4 的类为: <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunoobTest</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>在获得类型类之后，你就可以调用其中的一些方法获得类型的信息了，主要的方法有：</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">getName():String：获得该类型的全称名称。<br><br>getSuperClass():Class：获得该类型的直接父类，如果该类型没有直接父类，那么返回<span class="hljs-literal">null</span>。<br><br>getInterfaces():Class[]：获得该类型实现的所有接口。<br><br>isArray():<span class="hljs-type">boolean</span>：判断该类型是否是数组。<br><br>isEnum():<span class="hljs-type">boolean</span>：判断该类型是否是枚举类型。<br><br>isInterface():<span class="hljs-type">boolean</span>：判断该类型是否是接口。<br><br>isPrimitive():<span class="hljs-type">boolean</span>：判断该类型是否是基本类型，即是否是<span class="hljs-type">int</span>，<span class="hljs-type">boolean</span>，<span class="hljs-type">double</span>等等。<br><br>isAssignableFrom(Class cls):<span class="hljs-type">boolean</span>：判断这个类型是否是类型cls的父(祖先)类或父(祖先)接口。<br><br>getComponentType():Class：如果该类型是一个数组，那么返回该数组的组件类型。<br><br></code></pre></td></tr></table></figure><h1 id="equals-Object-obj"><a href="#equals-Object-obj" class="headerlink" title="equals(Object obj)"></a>equals(Object obj)</h1><blockquote><ul><li>equals方法是 判断两个对象是否相等</li><li>equals源码</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>在Object类中的equals方法当中, 用“ &#x3D;&#x3D;”判断的是两个java对象的内存地址是否相等</li><li>我们应该判断两个java对象的内容是否相等。所以需要子类重写equals。<blockquote><ul><li>基本数据类型，判断相等用“&#x3D;&#x3D;”</li><li><strong>引用数据类型，判断相等必须重写equals()方法</strong>，不然比较的是内存地址</li></ul></blockquote></li></ul></blockquote><h1 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h1><h2 id="什么是hashcode"><a href="#什么是hashcode" class="headerlink" title="什么是hashcode"></a>什么是hashcode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>; <span class="hljs-comment">//native 关键字修饰的方法，用 C/C++ 语言实现</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>java根据一定的规则将与对象相关的信息（比如对象的存储地址，对象的字段等）映射成一个数值，这个数值称作为hashcode</li></ul></blockquote><h2 id="hashcode的主要作用"><a href="#hashcode的主要作用" class="headerlink" title="hashcode的主要作用"></a>hashcode的主要作用</h2><blockquote><ul><li>对于hashset, hashmap, hashtable等方法需要判断数据是否一样, 可以使用 equals() 方法进行逐个比较, 但是这种方如果数据量特别特别大，采用 equals() 方法进行逐个对比的效率肯定很低. 最好的解决方案就是哈希表.</li></ul></blockquote><h2 id="关于重写equals必须重写hashcode方法"><a href="#关于重写equals必须重写hashcode方法" class="headerlink" title="关于重写equals必须重写hashcode方法"></a>关于重写equals必须重写hashcode方法</h2><blockquote><ul><li>每个覆盖了equals方法的类中，必须覆盖hashCode。如果不这么做，就违背了hashCode的通用约定，也就是上面注释中所说的。进而导致该类无法结合所以与散列的集合一起正常运作，这里指的是HashMap、HashSet、HashTable、ConcurrentHashMap。 —  <strong>Effective Java 第三版</strong></li></ul></blockquote><p>具体Example</p><blockquote><ul><li>我们知道HashMap中的key是不能重复的，如果重复添加，后添加的会覆盖前面的内容。那么我们看看HashMap是如何来确定key的唯一性的。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>查看代码发现，它是通过计算Map key的hashCode值来确定在链表中的存储位置的。那么这样就可以推测出，如果我们重写了equals但是没重写hashCode，那么可能存在元素重复的矛盾情况</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br><br><span class="hljs-keyword">private</span> String name;<br><br><span class="hljs-keyword">private</span> Integer age;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Employee</span><span class="hljs-params">(String name, Integer age)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == o) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (o == <span class="hljs-literal">null</span> || getClass() != o.getClass()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee</span> <span class="hljs-operator">=</span> (Employee) o;<br>    <span class="hljs-keyword">return</span> Objects.equals(name, employee.name) &amp;&amp;<br>            Objects.equals(age, employee.age);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;冰峰&quot;</span>, <span class="hljs-number">20</span>);<br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;冰峰&quot;</span>, <span class="hljs-number">22</span>);<br>    <span class="hljs-type">Employee</span> <span class="hljs-variable">employee3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Employee</span>(<span class="hljs-string">&quot;冰峰&quot;</span>, <span class="hljs-number">20</span>);<br><br>    HashMap&lt;Employee, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    map.put(employee1, <span class="hljs-string">&quot;1&quot;</span>);<br>    map.put(employee2, <span class="hljs-string">&quot;1&quot;</span>);<br>    map.put(employee3, <span class="hljs-string">&quot;1&quot;</span>);<br><br>    System.out.println(<span class="hljs-string">&quot;equals：&quot;</span> + employee1.equals(employee3));<br>    System.out.println(<span class="hljs-string">&quot;hashCode：&quot;</span> + (employee1.hashCode() == employee3.hashCode()));<br>    System.out.println(JSONObject.toJSONString(map));<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>按正常情况来推测，map中值存在两个元素，employee2和employee3, 因为employee1和employee3一样(equal被重写了) 会被覆盖</li><li>实际执行结果<br><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---Object%20Class/2.png" alt="在这里插入图片描述"></li><li>出现这种问题的原因就是因为没有重写hashCode，导致map在计算key的hash值的时候，绝对值相同的对象计算除了不一致的hash值。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Objects.hash(name, age);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>加入重写hashcode, 根据name和age产生hash值</li><li>运行结果<br><img src="/2024/04/25/Java%20%E5%9F%BA%E7%A1%80---Object%20Class/3.png" alt="在这里插入图片描述"></li></ul></blockquote><h2 id="关于利用hashcode和equals比较两个object"><a href="#关于利用hashcode和equals比较两个object" class="headerlink" title="关于利用hashcode和equals比较两个object"></a>关于利用hashcode和equals比较两个object</h2><blockquote><ul><li>先对比两个object的hashcode<blockquote><ul><li>如果hahcode不一样则一定不一样</li><li>如果两个object的hashcode一致, 则说明有可能一样(因为存在hash冲突)</li></ul></blockquote></li><li>所以还需要调用equals进行实际比较</li></ul></blockquote><h1 id="wait-and-notify-—-to-be-continued"><a href="#wait-and-notify-—-to-be-continued" class="headerlink" title="wait()  and  notify()   —  to be continued"></a>wait()  and  notify()   —  to be continued</h1><p>Object wait() 方法让当前线程进入等待状态。直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</p><p>当前线程必须是此对象的监视器所有者，否则还是会发生 IllegalMonitorStateException 异常。</p><p>如果当前线程在等待之前或在等待时被任何线程中断，则会抛出 InterruptedException 异常。</p><h2 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h2><h2 id="wait-long-timeout"><a href="#wait-long-timeout" class="headerlink" title="wait(long timeout)"></a>wait(long timeout)</h2><h2 id="wait-long-timeout-int-nanos"><a href="#wait-long-timeout-int-nanos" class="headerlink" title="wait(long timeout, int nanos)"></a>wait(long timeout, int nanos)</h2>]]></content>
    
    
    <categories>
      
      <category>Java SE</category>
      
      <category>Java --- 基础/封装/多态</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
